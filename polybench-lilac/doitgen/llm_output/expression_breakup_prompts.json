{
  "system_prompt": "You are an expert C programmer specializing in code refactoring and readability.\nYour task is to analyze a C function and identify expressions that would benefit from being broken up into multiple lines using temporary variables for better readability.\n\nConsider these principles when deciding which expressions to break up:\n- Expressions that are visually long or complex on a single line\n- Expressions with multiple operators or function calls\n- Expressions that mix different types of operations\n- Nested function calls or complex arithmetic\n- Boolean expressions with many conditions\n- Any expression that makes the code hard to understand at a glance\n\nFor each expression you decide should be broken up, suggest:\n1. The exact line number where the expression appears (relative to the function start)\n2. The original expression text\n3. How to break it up into smaller sub-expressions with temporary variables\n4. Appropriate names for temporary variables (following C naming conventions)\n5. The optimal order of operations to maintain correctness\n\nReturn your response as JSON with this structure:\n{\n    \"function_name\": \"function_name_here\",\n    \"breakups\": [\n        {\n            \"line_number\": 5,\n            \"original_expression\": \"a + b * c + d / e + sin(a) * cos(b)\",\n            \"breakup_steps\": [\n                {\n                    \"temp_var\": \"product_term\",\n                    \"expression\": \"b * c\",\n                    \"description\": \"Calculate the product of b and c\"\n                },\n                {\n                    \"temp_var\": \"quotient_term\",\n                    \"expression\": \"d / e\",\n                    \"description\": \"Calculate the quotient of d and e\"\n                },\n                {\n                    \"temp_var\": \"trig_term\",\n                    \"expression\": \"sin(a) * cos(b)\",\n                    \"description\": \"Calculate the trigonometric product\"\n                },\n                {\n                    \"temp_var\": \"result\",\n                    \"expression\": \"a + product_term + quotient_term + trig_term\",\n                    \"description\": \"Combine all calculated terms\"\n                }\n            ],\n            \"final_expression\": \"result\"\n        }\n    ]\n}\n\nImportant:\n- Only suggest breakups for expressions that genuinely need it for readability\n- Line numbers should be relative to the function (first line of function is line 1)\n- The breakup_steps should be in the correct order of evaluation\n- Use descriptive temporary variable names\n- The final_expression should be what replaces the original expression in the code",
  "user_prompt": "Analyze this C function and identify expressions that should be broken up into multiple lines with temporary variables for better readability.\n\nFunction: kernel_sum\n\nPotential long expressions detected (1-indexed):\n  - Line 209: length=33, operators=4, expression=sum[((r * nq + q) * np + p)] = 0;\n  - Line 212: length=62, operators=8, expression=dot = (dot + (A[((r * nq + q) * np + s)] * C4[(s * np + p)]));\n  - Line 214: length=35, operators=4, expression=sum[((r * nq + q) * np + p)] = dot;\n\nLook through all the expressions in this function and decide which ones are too long or complex to be easily understood on a single line. Focus on expressions similar to the ones listed above. Consider:\n- Arithmetic expressions with multiple operations\n- Boolean conditions with many clauses\n- Function calls with complex arguments\n- Any expression that hurts code readability\n\nRespond with JSON only, suggesting breakups for expressions that truly need them. If no expressions need breaking up, return an empty breakups array with the function_name.\n\nFunction code (line numbers are relative to function start):\n```c\n   1: void kernel_sum(uint32_t nr, uint32_t nq, uint32_t np, double* A, double* C4, double* sum, uint32_t __FIXME__gridDim_2e_x, uint32_t __FIXME__gridDim_2e_y, uint32_t __FIXME__gridDim_2e_z, uint32_t __FIXME__blockDim_2e_x, uint32_t __FIXME__blockDim_2e_y, uint32_t __FIXME__blockDim_2e_z, uint32_t __FIXME__blockIdx_2e_x, uint32_t __FIXME__blockIdx_2e_y, uint32_t __FIXME__blockIdx_2e_z, uint32_t __FIXME__threadIdx_2e_x, uint32_t __FIXME__threadIdx_2e_y, uint32_t __FIXME__threadIdx_2e_z) {\n   2:   int32_t r;\n   3:   int32_t q;\n   4:   int32_t p;\n   5:   int64_t s;\n   6:   double dot;\n   7: \n   8: // INSERT COMMENT IFELSE: kernel_sum::entry\n   9:   r = __FIXME__blockDim_2e_x * __FIXME__blockIdx_2e_x + __FIXME__threadIdx_2e_x;\n  10:   q = __FIXME__blockDim_2e_y * __FIXME__blockIdx_2e_y + __FIXME__threadIdx_2e_y;\n  11:   p = __FIXME__blockDim_2e_z * __FIXME__blockIdx_2e_z + __FIXME__threadIdx_2e_z;\n  12:   if (r < nr) { // IFELSE MARKER: entry IF\n  13:   if (q < nq) { // IFELSE MARKER: land.lhs.true IF\n  14:   if (p < np) { // IFELSE MARKER: land.lhs.true14 IF\n  15:   sum[((r * nq + q) * np + p)] = 0;\n  16:   dot = 0;\n  17: for(int64_t s = 0; s < np;   s = s + 1){\n  18:   dot = (dot + (A[((r * nq + q) * np + s)] * C4[(s * np + p)]));\n  19: }\n  20:   sum[((r * nq + q) * np + p)] = dot;\n  21:   }\n  22:   }\n  23:   }\n  24:   return;\n  25: }\n```"
}