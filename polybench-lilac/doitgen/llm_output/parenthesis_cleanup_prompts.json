{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 68 potential parentheses to evaluate:\n\nLine 227: __auto_type idx_rq_np_after = idx_rq_after * np;\n  Potential parentheses to evaluate: (noinline)\nLine 305: \n  Potential parentheses to evaluate: (noinline), (noinline), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (uint32_t a, uint32_t b), (argv[1]), (argv[2]), (argv[3]), (argv[4]), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (j), (double), (k), (double), (np), (double), (i), (double), (j), (double), (np), (uint32_t num, uint32_t factor), (nr, block.x), (nq, block.y), (np, block.z), (uint8_t*), (&grid_copy), (uint8_t*), (&grid), (uint8_t*), (&block_copy), (uint8_t*), (&block), (uint8_t*), (&grid_copy_coerce), (uint8_t*), (&grid_copy), (uint8_t*), (&block_copy_coerce), (uint8_t*), (&block_copy), (2), (nr, nq, np, A, C4, sum, num_blocks_x, num_blocks_y, num_blocks_z, 1, 8, 32, i, j, k, 0, l, m), (double_fmt_space), (newline_fmt), (newline_fmt)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct io_file_struct;\nstruct dim3_t;\nstruct dim3_coerce_t;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array1_t {\n  uint8_t array[1];\n};\nstruct uint8_array20_t {\n  uint8_t array[20];\n};\nstruct io_file_struct {\n  uint32_t field0;\n  uint8_t* field1;\n  uint8_t* field2;\n  uint8_t* field3;\n  uint8_t* field4;\n  uint8_t* field5;\n  uint8_t* field6;\n  uint8_t* field7;\n  uint8_t* field8;\n  uint8_t* field9;\n  uint8_t* field10;\n  uint8_t* field11;\n  void* field12;\n  struct io_file_struct* field13;\n  uint32_t field14;\n  uint32_t field15;\n  uint64_t field16;\n  uint16_t field17;\n  uint8_t field18;\n  uint8_t field19[1];\n  uint8_t* field20;\n  uint64_t field21;\n  void* field22;\n  void* field23;\n  struct io_file_struct* field24;\n  uint8_t* field25;\n  uint64_t field26;\n  uint32_t field27;\n  uint8_t field28[20];\n};\nstruct dim3_t {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct dim3_coerce_t {\n  uint64_t batch;\n  uint32_t batch_extra;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, uint32_t, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, uint32_t, uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, uint32_t, uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_sum(uint32_t, uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t double_fmt_space[8] = { \"%0.2lf \" };\nuint8_t newline_fmt[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_urem_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t nr;\n  int32_t nq;\n  int32_t np;\n  uint8_t* A;\n  uint8_t* sum;\n  uint8_t* C4;\n  int32_t init_array_ret;\n  int32_t kernel_ret;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[1]);\n  nr = atoi(argv[2]);\n  nq = atoi(argv[3]);\n  np = atoi(argv[4]);\n  A = malloc(nr * nq * np * 8);\n  sum = malloc(nr * nq * np * 8);\n  C4 = malloc(np * np * 8);\n  init_array(nr, nq, np, ((double*)A), ((double*)C4));\n;\n  kernel(nr, nq, np, ((double*)A), ((double*)C4), ((double*)sum));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(nr, nq, np, ((double*)sum));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)sum)));\nfree(((uint8_t*)((double*)C4)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t nr, uint32_t nq, uint32_t np, double* A, double* C4) {\n  int64_t i;\n  int64_t j;\n  int64_t k;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < nr;   i = i + 1){\nfor(int64_t j = 0; j < nq;   j = j + 1){\nfor(int64_t k = 0; k < np;   k = k + 1){\n  A[((i * np * nq + j * nq) + k)] = ((((double)(i) * (double)(j)) + (double)(k)) / (double)(np));\n}\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond21\nfor(int64_t i = 0; i < np;   i = i + 1){\nfor(int64_t j = 0; j < np;   j = j + 1){\n  C4[(i * np + j)] = (((double)(i) * (double)(j)) / (double)(np));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_sum\nvoid kernel_sum(uint32_t nr, uint32_t nq, uint32_t np, double* A, double* C4, double* sum, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t r;\n  int32_t q;\n  int32_t p;\n  int64_t s;\n  double dot;\n\n// INSERT COMMENT IFELSE: kernel_sum::entry\n  r = blockDim_x * blockIdx_x + threadIdx_x;\n  q = blockDim_y * blockIdx_y + threadIdx_y;\n  p = blockDim_z * blockIdx_z + threadIdx_z;\n  if (r < nr) { // IFELSE MARKER: entry IF\n  if (q < nq) { // IFELSE MARKER: land.lhs.true IF\n  if (p < np) { // IFELSE MARKER: land.lhs.true14 IF\n  __auto_type idx_rq = r * nq + q;\n  __auto_type idx_rq_np = idx_rq * np;\n  __auto_type idx_rq_np_p = idx_rq_np + p;\n  __auto_type sum_zero_tmp = sum[idx_rq_np_p] = 0;;\n  sum[((r * nq + q) * np + p)] = 0;\n  dot = 0;\nfor(int64_t s = 0; s < np;   s = s + 1){\n  __auto_type idx_rq_loop = r * nq + q;\n  __auto_type idx_rq_np_loop = idx_rq_loop * np;\n  __auto_type idx_rq_np_s = idx_rq_np_loop + s;\n  __auto_type idx_sp = s * np + p;\n  __auto_type aval = A[idx_rq_np_s];\n  __auto_type c4val = C4[idx_sp];\n  __auto_type prod = aval * c4val;\n  __auto_type dot_update = dot = dot + prod;\n  dot = dot + prod;\n}\n  __auto_type idx_rq_after = r * nq + q;\n  __auto_type idx_rq_np_after = idx_rq_after * np;\n  __auto_type idx_rq_np_p_after = idx_rq_np_after + p;\n  __auto_type sum_store = sum[idx_rq_np_p_after] = dot;;\n  sum[((r * nq + q) * np + p)] = dot;\n  }\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t nr, uint32_t nq, uint32_t np, double* A, double* C4, double* sum) {\n  struct dim3_t block;    /* Address-exposed local */\n  struct dim3_t grid;    /* Address-exposed local */\n  struct dim3_t grid_copy;    /* Address-exposed local */\n  struct dim3_t block_copy;    /* Address-exposed local */\n  struct dim3_coerce_t grid_copy_coerce;    /* Address-exposed local */\n  struct dim3_coerce_t block_copy_coerce;    /* Address-exposed local */\n  int32_t num_blocks_x;\n  int32_t num_blocks_y;\n  int32_t num_blocks_z;\n  uint8_t* byte_ptr1;\n  uint8_t* byte_ptr2;\n  uint8_t* byte_ptr3;\n  uint8_t* byte_ptr4;\n  uint32_t i;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n  block.x = 1;\n  block.y = 8;\n  block.z = 32;\n  num_blocks_x = num_blocks(nr, block.x);\n  num_blocks_y = num_blocks(nq, block.y);\n  num_blocks_z = num_blocks(np, block.z);\n  grid.x = num_blocks_x;\n  grid.y = num_blocks_y;\n  grid.z = num_blocks_z;\n  memcpy(((uint8_t*)(&grid_copy)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&block_copy)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&grid_copy_coerce)), ((uint8_t*)(&grid_copy)), 12);\n  memcpy(((uint8_t*)(&block_copy_coerce)), ((uint8_t*)(&block_copy)), 12);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_x;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_y;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_z;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_sum(nr, nq, np, A, C4, sum, num_blocks_x, num_blocks_y, num_blocks_z, 1, 8, 32, i, j, k, 0, l, m);\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t nr, uint32_t nq, uint32_t np, double* A) {\n  int64_t i;\n  int64_t j;\n  int64_t k;\n  int32_t unused_int;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < nr;   i = i + 1){\nfor(int64_t j = 0; j < nq;   j = j + 1){\nfor(int64_t k = 0; k < np;   k = k + 1){\n  fprintf(stderr, (double_fmt_space), A[((i * nq * np + j * nq) + k)]);\n  if (i % 20 == 0) { // IFELSE MARKER: for.body6 IF\n  fprintf(stderr, (newline_fmt));\n  }\n}\n}\n}\n  fprintf(stderr, (newline_fmt));\n}\n\n```"
}