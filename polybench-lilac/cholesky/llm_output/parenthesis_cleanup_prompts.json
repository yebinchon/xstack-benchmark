{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 70 potential parentheses to evaluate:\n\nLine 310: \n  Potential parentheses to evaluate: (noinline), (noinline), (uint32_t, uint32_t), (noinline, nothrow), (double), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[2]), (argv[1]), (double*), (double*), (double*), (uint8_t*), (double*), (double), (n), (uint32_t num, uint32_t factor), (cond_all), (uint8_t*), (&dim_temp_a_coerce), (uint8_t*), (&dim_temp_a), (uint8_t*), (&dim_temp_b_coerce), (uint8_t*), (&dim_temp_b), (n, iter, dev_A, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0), (n, 256), (uint8_t*), (&blocks_k1_coerce), (uint8_t*), (&blocks_k1), (uint8_t*), (&threads_k1_coerce), (uint8_t*), (&threads_k1), (2), (n, iter, dev_A, num_blocks_256, 1, 1, 256, 1, 1, j, 0, 0, k, 0, 0), (n, block.x), (n, block.y), (uint8_t*), (&block_copy), (uint8_t*), (&block), (uint8_t*), (&grid_copy), (uint8_t*), (&grid), (uint8_t*), (&block_copy_coerce), (uint8_t*), (&block_copy), (uint8_t*), (&grid_copy_coerce), (uint8_t*), (&grid_copy), (2), (n, iter, dev_A, 8, 32, 1, num_blocks_x, num_blocks_y, 1, j, k, 0, l, m, 0), (print_format_str), (int), (int), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct IOFile;\nstruct dim3;\nstruct dim3_coerce_t;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array1_t {\n  uint8_t array[1];\n};\nstruct uint8_array20_t {\n  uint8_t array[20];\n};\nstruct IOFile {\n  uint32_t flags;\n  uint8_t* read_ptr;\n  uint8_t* read_end;\n  uint8_t* read_base;\n  uint8_t* write_base;\n  uint8_t* write_ptr;\n  uint8_t* write_end;\n  uint8_t* buf_base;\n  uint8_t* buf_end;\n  uint8_t* save_base;\n  uint8_t* backup_base;\n  uint8_t* save_end;\n  void* markers;\n  struct IOFile* chain;\n  uint32_t fileno;\n  uint32_t flags2;\n  uint64_t old_offset;\n  uint16_t cur_column;\n  uint8_t vtable_offset;\n  uint8_t shortbuf[1];\n  uint8_t* lock;\n  uint64_t offset;\n  void* pad1;\n  void* pad2;\n  struct IOFile* freeres_list;\n  uint8_t* freeres_buf;\n  uint64_t pad5;\n  uint32_t mode;\n  uint8_t unused2[20];\n};\nstruct dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct dim3_coerce_t {\n  uint64_t x;\n  uint32_t y;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel_polly(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\ndouble sqrt(double);\nvoid kernel0(uint32_t, uint32_t, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel1(uint32_t, uint32_t, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel2(uint32_t, uint32_t, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_format_str[8] = { \"%0.2lf \" };\nuint8_t newline_str[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t n;\n  int32_t dump_code;\n  uint8_t* A;\n  int32_t tmp_call12;\n  int32_t tmp_call16;\n\n// INSERT COMMENT IFELSE: main::entry\n  n = atoi(argv[2]);\n  dump_code = atoi(argv[1]);\n  A = malloc(n * n * 8);\n  init_array(n, ((double*)A));\n;\n  kernel_polly(n, ((double*)A));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(n, ((double*)A));\n  }\nfree(((uint8_t*)((double*)A)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = (1 / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel0\nvoid kernel0(uint32_t n, uint32_t j, double* A, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  double diag_val;\n\n  diag_val = sqrt(A[(j * n + j)]);\n  A[(j * n + j)] = diag_val;\n}\n// INSERT COMMENT FUNCTION: kernel1\nvoid kernel1(uint32_t n, uint32_t j, double* A, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n\n// INSERT COMMENT IFELSE: kernel1::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n & i > j) { // IFELSE MARKER: entry IF\n  A[(i * n + j)] = (A[(i * n + j)] / A[(j * n + j)]);\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel2\nvoid kernel2(uint32_t n, uint32_t j, double* A, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t k;\n\n// INSERT COMMENT IFELSE: kernel2::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  k = blockDim_y * blockIdx_y + threadIdx_y;\n  __auto_type cond_j_lt_n = (j < n);\n  __auto_type cond_j_lt_i = (j < i);\n  __auto_type cond_i_lt_n = (i < n);\n  __auto_type cond_j_lt_k = (j < k);\n  __auto_type cond_k_le_i = (k <= i);\n  __auto_type cond_all = cond_j_lt_n & cond_j_lt_i & cond_i_lt_n & cond_j_lt_k & cond_k_le_i;\n  if (cond_all) { // IFELSE MARKER: entry IF\n  __auto_type index_i_n_k = (i * n + k);\n  __auto_type index_i_n_j = (i * n + j);\n  __auto_type index_k_n_j = (k * n + j);\n  __auto_type val_A_i_k = A[index_i_n_k];\n  __auto_type val_A_i_j = A[index_i_n_j];\n  __auto_type val_A_k_j = A[index_k_n_j];\n  __auto_type prod_A_i_j_A_k_j = val_A_i_j * val_A_k_j;\n  __auto_type updated_A_i_k = val_A_i_k - prod_A_i_j_A_k_j;\n  A[(i * n + k)] = updated_A_i_k;\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_polly\nvoid kernel_polly(uint32_t n, double* dev_A) {\n  struct dim3 dim_temp_a;    /* Address-exposed local */\n  struct dim3 dim_temp_b;    /* Address-exposed local */\n  struct dim3_coerce_t dim_temp_a_coerce;    /* Address-exposed local */\n  struct dim3_coerce_t dim_temp_b_coerce;    /* Address-exposed local */\n  struct dim3 blocks_k1;    /* Address-exposed local */\n  struct dim3 threads_k1;    /* Address-exposed local */\n  struct dim3_coerce_t blocks_k1_coerce;    /* Address-exposed local */\n  struct dim3_coerce_t threads_k1_coerce;    /* Address-exposed local */\n  struct dim3 block;    /* Address-exposed local */\n  struct dim3 grid;    /* Address-exposed local */\n  struct dim3 block_copy;    /* Address-exposed local */\n  struct dim3 grid_copy;    /* Address-exposed local */\n  struct dim3_coerce_t block_copy_coerce;    /* Address-exposed local */\n  struct dim3_coerce_t grid_copy_coerce;    /* Address-exposed local */\n  int32_t iter;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n// INSERT COMMENT LOOP: kernel_polly::for.cond\nfor(int32_t iter = 0; iter < n;   iter = iter + 1){\n  dim_temp_a.x = 1;\n  dim_temp_a.y = 1;\n  dim_temp_a.z = 1;\n  dim_temp_b.x = 1;\n  dim_temp_b.y = 1;\n  dim_temp_b.z = 1;\n  memcpy(((uint8_t*)(&dim_temp_a_coerce)), ((uint8_t*)(&dim_temp_a)), 12);\n  memcpy(((uint8_t*)(&dim_temp_b_coerce)), ((uint8_t*)(&dim_temp_b)), 12);\nkernel0(n, iter, dev_A, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0);\n  uint32_t num_blocks_256 = num_blocks(n, 256);\n  blocks_k1.x = num_blocks_256;\n  blocks_k1.y = 1;\n  blocks_k1.z = 1;\n  threads_k1.x = 256;\n  threads_k1.y = 1;\n  threads_k1.z = 1;\n  memcpy(((uint8_t*)(&blocks_k1_coerce)), ((uint8_t*)(&blocks_k1)), 12);\n  memcpy(((uint8_t*)(&threads_k1_coerce)), ((uint8_t*)(&threads_k1)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < num_blocks_256;   j = j + 1){\nfor(int32_t k = 0; k < 256;   k = k + 1){\n  kernel1(n, iter, dev_A, num_blocks_256, 1, 1, 256, 1, 1, j, 0, 0, k, 0, 0);\n;\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  uint32_t num_blocks_x = num_blocks(n, block.x);\n  uint32_t num_blocks_y = num_blocks(n, block.y);\n  grid.x = num_blocks_x;\n  grid.y = num_blocks_y;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&block_copy)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&grid_copy)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&block_copy_coerce)), ((uint8_t*)(&block_copy)), 12);\n  memcpy(((uint8_t*)(&grid_copy_coerce)), ((uint8_t*)(&grid_copy)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < 8;   j = j + 1){\nfor(int32_t k = 0; k < 32;   k = k + 1){\nfor(int32_t l = 0; l < num_blocks_x;   l = l + 1){\nfor(int32_t m = 0; m < num_blocks_y;   m = m + 1){\n  kernel2(n, iter, dev_A, 8, 32, 1, num_blocks_x, num_blocks_y, 1, j, k, 0, l, m, 0);\n;\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* A) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  fprintf(stderr, (print_format_str), A[(i * n + j)]);\n  if ((int)(i * n + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline_str));\n  }\n}\n}\n  return;\n}\n\n```"
}