{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize the n x n matrix A so every element is set to the constant 1.0/n"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num/factor) to determine how many blocks of size 'factor' are needed to cover 'num' items"
    },
    {
      "id": "unknown_FUNCTION_kernel0",
      "original": "// INSERT COMMENT FUNCTION: kernel0",
      "replacement": "// Compute sqrt of the pivot element A[j,j] and store it back (diagonal step, e.g., in Cholesky factorization)"
    },
    {
      "id": "unknown_FUNCTION_kernel1",
      "original": "// INSERT COMMENT FUNCTION: kernel1",
      "replacement": "// CUDA-style kernel that scales column j below the diagonal: for eligible i, set A[i,j] /= A[j,j]"
    },
    {
      "id": "unknown_FUNCTION_kernel2",
      "original": "// INSERT COMMENT FUNCTION: kernel2",
      "replacement": "// 2D CUDA kernel that computes (i,k) from thread indices and readies bounds checks for trailing submatrix updates at step j"
    },
    {
      "id": "unknown_FUNCTION_kernel_polly",
      "original": "// INSERT COMMENT FUNCTION: kernel_polly",
      "replacement": "// Host driver that configures grid/block dimensions and iterates over n steps to launch GPU kernels operating on A"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the n x n matrix A element-by-element to stderr using the configured floating-point format"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over all (i,j) entries to initialize A[i,j] to 1.0/n"
    },
    {
      "id": "unknown_LOOP_kernel_polly",
      "original": "// INSERT COMMENT LOOP: kernel_polly",
      "replacement": "// Iterate n times, configuring grid dimensions (and subsequently launching kernels) for each step"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Nested loops over all rows i and columns j to output A[i,j] in row-major order"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line arguments, allocate an n x n double matrix, and initialize its contents"
    },
    {
      "id": "unknown_IFELSE_kernel1::entry",
      "original": "// INSERT COMMENT IFELSE: kernel1::entry",
      "replacement": "// If this thread\u2019s i is within bounds and below the diagonal (j < i < n), normalize A[i,j] by the pivot A[j,j]; otherwise skip"
    },
    {
      "id": "unknown_IFELSE_kernel2::entry",
      "original": "// INSERT COMMENT IFELSE: kernel2::entry",
      "replacement": "// Compute thread coordinates (i,k) and precompute bound checks (j < n, j < i, i < n) for the subsequent update logic"
    }
  ]
}