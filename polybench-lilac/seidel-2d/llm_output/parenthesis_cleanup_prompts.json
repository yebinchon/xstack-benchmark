{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 50 potential parentheses to evaluate:\n\nLine 146: for(int64_t j = 0; j < n;   j = j + 1){\n  Potential parentheses to evaluate: (x)\nLine 253: \n  Potential parentheses to evaluate: (noinline), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[ARG_DUMP_INDEX]), (argv[ARG_N_INDEX]), (argv[ARG_TSTEPS_INDEX]), (double*), (double*), (double*), (uint8_t*), (double*), (double), (i), (double), (double), (n), (uint32_t num, uint32_t factor), (average), (uint8_t*), (&grid_tmp), (uint8_t*), (&grid), (uint8_t*), (&block_tmp), (uint8_t*), (&block), (uint8_t*), (&grid_coerce), (uint8_t*), (&grid_tmp), (uint8_t*), (&block_coerce), (uint8_t*), (&block_tmp), (2), (tsteps, n, A, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (print_format_str), (int), (int), (newline_str), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n/* Magic number constants */\n#define BYTES_PER_DOUBLE 8\n#define INIT_J_OFFSET 2\n#define INIT_CONST_TERM 2\n#define STENCIL_HALO_RADIUS 1\n#define STENCIL_BORDER_THICKNESS 2\n#define STENCIL_NEIGHBOR_COUNT 9\n#define BLOCK_DIM_X 8\n#define BLOCK_DIM_Y 32\n#define BLOCK_DIM_Z 1\n#define GRID_DIM_Z 1\n#define DIM3_BYTE_SIZE 12\n#define PRINT_FORMAT_BUF_SIZE 8\n#define NEWLINE_BUF_SIZE 2\n#define ARG_DUMP_INDEX 1\n#define ARG_N_INDEX 2\n#define ARG_TSTEPS_INDEX 3\n\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct Dim3;\nstruct Dim3Coerce;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array_1 {\n  uint8_t array[1];\n};\nstruct uint8_array_20 {\n  uint8_t array[20];\n};\nstruct Dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct Dim3Coerce {\n  uint64_t value64;\n  uint32_t value32;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel(uint32_t, uint32_t, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_stencil(uint32_t, uint32_t, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_format_str[PRINT_FORMAT_BUF_SIZE] = { \"%0.2lf \" };\nuint8_t newline_str[NEWLINE_BUF_SIZE] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t n;\n  int32_t tsteps;\n  uint8_t* A;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[ARG_DUMP_INDEX]);\n  n = atoi(argv[ARG_N_INDEX]);\n  tsteps = atoi(argv[ARG_TSTEPS_INDEX]);\n  A = malloc(n * n * BYTES_PER_DOUBLE);\n  init_array(n, ((double*)A));\n;\n  kernel(tsteps, n, ((double*)A));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(n, ((double*)A));\n  }\nfree(((uint8_t*)((double*)A)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = ((((double)(i) * (double)((j + INIT_J_OFFSET))) + INIT_CONST_TERM) / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_stencil\nvoid kernel_stencil(uint32_t tsteps, uint32_t n, double* A, uint32_t gridDimX, uint32_t gridDimY, uint32_t gridDimZ, uint32_t blockDimX, uint32_t blockDimY, uint32_t blockDimZ, uint32_t blockIdxX, uint32_t blockIdxY, uint32_t blockIdxZ, uint32_t threadIdxX, uint32_t threadIdxY, uint32_t threadIdxZ) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_stencil::entry\n  i = blockDimX * blockIdxX + threadIdxX + STENCIL_HALO_RADIUS;\n  j = blockDimY * blockIdxY + threadIdxY + STENCIL_HALO_RADIUS;\n  if (i < (n - STENCIL_HALO_RADIUS)) { // IFELSE MARKER: entry IF\n  if (j < (n - STENCIL_HALO_RADIUS)) { // IFELSE MARKER: land.lhs.true IF\n  int centerIndex = i * n + j;\n  __auto_type haloRadius = STENCIL_HALO_RADIUS;\n  int iMinusRadius = i - haloRadius;\n  int jMinusRadius = j - haloRadius;\n  int iMinus1 = i - 1;\n  int jPlus1 = j + 1;\n  int iPlus1 = i + 1;\n  int jMinus1 = j - 1;\n  int topLeftIndex = iMinusRadius * n + jMinusRadius;\n  int topIndex = iMinusRadius * n + j;\n  int topRightIndex = iMinus1 * n + jPlus1;\n  int leftIndex = centerIndex - 1;\n  int rightIndex = centerIndex + 1;\n  int bottomLeftIndex = iPlus1 * n + jMinus1;\n  int bottomIndex = iPlus1 * n + j;\n  int bottomRightIndex = iPlus1 * n + jPlus1;\n  double sum1 = A[topLeftIndex] + A[topIndex];\n  double sum2 = sum1 + A[topRightIndex];\n  double sum3 = sum2 + A[leftIndex];\n  double sum4 = sum3 + A[centerIndex];\n  double sum5 = sum4 + A[rightIndex];\n  double sum6 = sum5 + A[bottomLeftIndex];\n  double sum7 = sum6 + A[bottomIndex];\n  double sum8 = sum7 + A[bottomRightIndex];\n  double average = sum8 / STENCIL_NEIGHBOR_COUNT;\n  A[(i * n + j)] = (average);\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t tsteps, uint32_t n, double* A) {\n  struct Dim3 block;    /* Address-exposed local */\n  struct Dim3 grid;    /* Address-exposed local */\n  struct Dim3 grid_tmp;    /* Address-exposed local */\n  struct Dim3 block_tmp;    /* Address-exposed local */\n  struct Dim3Coerce grid_coerce;    /* Address-exposed local */\n  struct Dim3Coerce block_coerce;    /* Address-exposed local */\n  int32_t t;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n// INSERT COMMENT LOOP: kernel::for.cond\nfor(int32_t t = 1; t <= tsteps;   t = t + 1){\n  block.x = BLOCK_DIM_X;\n  block.y = BLOCK_DIM_Y;\n  block.z = BLOCK_DIM_Z;\n  uint32_t num_blocks_x = num_blocks((n - STENCIL_BORDER_THICKNESS), block.x);\n  uint32_t num_blocks_y = num_blocks((n - STENCIL_BORDER_THICKNESS), block.y);\n  grid.x = num_blocks_x;\n  grid.y = num_blocks_y;\n  grid.z = GRID_DIM_Z;\n  memcpy(((uint8_t*)(&grid_tmp)), ((uint8_t*)(&grid)), DIM3_BYTE_SIZE);\n  memcpy(((uint8_t*)(&block_tmp)), ((uint8_t*)(&block)), DIM3_BYTE_SIZE);\n  memcpy(((uint8_t*)(&grid_coerce)), ((uint8_t*)(&grid_tmp)), DIM3_BYTE_SIZE);\n  memcpy(((uint8_t*)(&block_coerce)), ((uint8_t*)(&block_tmp)), DIM3_BYTE_SIZE);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < num_blocks_x;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_stencil(tsteps, n, A, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* A) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  fprintf(stderr, (print_format_str), A[(i * n + j)]);\n  if ((int)(i * n + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline_str));\n  }\n}\n}\n  fprintf(stderr, (newline_str));\n}\n\n```"
}