{
  "system_prompt": "You are an expert C programmer specializing in code refactoring and readability.\nYour task is to analyze a C function and identify expressions that would benefit from being broken up into multiple lines using temporary variables for better readability.\n\nConsider these principles when deciding which expressions to break up:\n- Expressions that are visually long or complex on a single line\n- Expressions with multiple operators or function calls\n- Expressions that mix different types of operations\n- Nested function calls or complex arithmetic\n- Boolean expressions with many conditions\n- Any expression that makes the code hard to understand at a glance\n\nFor each expression you decide should be broken up, suggest:\n1. The exact line number where the expression appears (relative to the function start)\n2. The original expression text\n3. How to break it up into smaller sub-expressions with temporary variables\n4. Appropriate names for temporary variables (following C naming conventions)\n5. The optimal order of operations to maintain correctness\n\nReturn your response as JSON with this structure:\n{\n    \"function_name\": \"function_name_here\",\n    \"breakups\": [\n        {\n            \"line_number\": 5,\n            \"original_expression\": \"a + b * c + d / e + sin(a) * cos(b)\",\n            \"breakup_steps\": [\n                {\n                    \"temp_var\": \"product_term\",\n                    \"expression\": \"b * c\",\n                    \"description\": \"Calculate the product of b and c\"\n                },\n                {\n                    \"temp_var\": \"quotient_term\",\n                    \"expression\": \"d / e\",\n                    \"description\": \"Calculate the quotient of d and e\"\n                },\n                {\n                    \"temp_var\": \"trig_term\",\n                    \"expression\": \"sin(a) * cos(b)\",\n                    \"description\": \"Calculate the trigonometric product\"\n                },\n                {\n                    \"temp_var\": \"result\",\n                    \"expression\": \"a + product_term + quotient_term + trig_term\",\n                    \"description\": \"Combine all calculated terms\"\n                }\n            ],\n            \"final_expression\": \"result\"\n        }\n    ]\n}\n\nImportant:\n- Only suggest breakups for expressions that genuinely need it for readability\n- Line numbers should be relative to the function (first line of function is line 1)\n- The breakup_steps should be in the correct order of evaluation\n- Use descriptive temporary variable names\n- The final_expression should be what replaces the original expression in the code",
  "user_prompt": "Analyze this C function and identify expressions that should be broken up into multiple lines with temporary variables for better readability.\n\nFunction: kernel\n\nPotential long expressions detected (1-indexed):\n  - Line 318: length=129, operators=0, expression=kernel_ey(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call3, __FIXME__call4, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n  - Line 340: length=131, operators=0, expression=kernel_ex(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call14, __FIXME__call17, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n  - Line 362: length=131, operators=0, expression=kernel_hz(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call28, __FIXME__call31, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n\nLook through all the expressions in this function and decide which ones are too long or complex to be easily understood on a single line. Focus on expressions similar to the ones listed above. Consider:\n- Arithmetic expressions with multiple operations\n- Boolean conditions with many clauses\n- Function calls with complex arguments\n- Any expression that hurts code readability\n\nRespond with JSON only, suggesting breakups for expressions that truly need them. If no expressions need breaking up, return an empty breakups array with the function_name.\n\nFunction code (line numbers are relative to function start):\n```c\n   1: void kernel(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict) {\n   2:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp;    /* Address-exposed local */\n   3:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp1;    /* Address-exposed local */\n   4:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp_2e_coerce;    /* Address-exposed local */\n   5:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp1_2e_coerce;    /* Address-exposed local */\n   6:   struct __FIXME__l_struct_struct_OC_dim3 block;    /* Address-exposed local */\n   7:   struct __FIXME__l_struct_struct_OC_dim3 grid;    /* Address-exposed local */\n   8:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp5;    /* Address-exposed local */\n   9:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp6;    /* Address-exposed local */\n  10:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp5_2e_coerce;    /* Address-exposed local */\n  11:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp6_2e_coerce;    /* Address-exposed local */\n  12:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp18;    /* Address-exposed local */\n  13:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp19;    /* Address-exposed local */\n  14:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp18_2e_coerce;    /* Address-exposed local */\n  15:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp19_2e_coerce;    /* Address-exposed local */\n  16:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp32;    /* Address-exposed local */\n  17:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp33;    /* Address-exposed local */\n  18:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp32_2e_coerce;    /* Address-exposed local */\n  19:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp33_2e_coerce;    /* Address-exposed local */\n  20:   int32_t t;\n  21:   uint32_t j;\n  22:   uint32_t k;\n  23:   uint32_t l;\n  24:   uint32_t m;\n  25: \n  26: // INSERT COMMENT LOOP: kernel::for.cond\n  27: for(int32_t t = 0; t < tmax;   t = t + 1){\n  28:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field0 = 256;\n  29:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  30:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  31:   uint32_t __FIXME__call = num_blocks(ny, BLOCK_SIZE_NY_1);\n  32:   __FIXME__agg_2e_tmp1.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call;\n  33:   __FIXME__agg_2e_tmp1.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  34:   __FIXME__agg_2e_tmp1.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  35:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp)), 12);\n  36:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp1_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp1)), 12);\n  37: #pragma omp parallel for collapse(2)\n  38: for(int32_t j = 0; j < 256;   j = j + 1){\n  39: for(int32_t k = 0; k < __FIXME__call;   k = k + 1){\n  40: kernel_splat(tmax, nx, ny, ex, ey, hz, fict, t, BLOCK_SIZE_NY_1, 1, 1, __FIXME__call, 1, 1, j, 0, 0, k, 0, 0);\n  41: }\n  42: }\n  43:   block.__FIXME__l_struct_struct_OC_dim3_field0 = TILE_DIM_L_1;\n  44:   block.__FIXME__l_struct_struct_OC_dim3_field1 = TILE_DIM_M_1;\n  45:   block.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  46:   uint32_t __FIXME__call3 = num_blocks((nx - 1), block.__FIXME__l_struct_struct_OC_dim3_field0);\n  47:   uint32_t __FIXME__call4 = num_blocks(ny, block.__FIXME__l_struct_struct_OC_dim3_field1);\n  48:   grid.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call3;\n  49:   grid.__FIXME__l_struct_struct_OC_dim3_field1 = __FIXME__call4;\n  50:   grid.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  51:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp5)), ((uint8_t*)(&grid)), 12);\n  52:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp6)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  53:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp5_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp5)), 12);\n  54:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp6_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp6)), 12);\n  55: #pragma omp parallel for collapse(2)\n  56: for(int32_t j = 0; j < __FIXME__call3;   j = j + 1){\n  57: for(int32_t k = 0; k < __FIXME__call4;   k = k + 1){\n  58: for(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\n  59: for(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n  60: kernel_ey(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call3, __FIXME__call4, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n  61: }\n  62: }\n  63: }\n  64: }\n  65:   block.__FIXME__l_struct_struct_OC_dim3_field0 = TILE_DIM_L_1;\n  66:   block.__FIXME__l_struct_struct_OC_dim3_field1 = TILE_DIM_M_1;\n  67:   block.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  68:   uint32_t __FIXME__call14 = num_blocks(nx, block.__FIXME__l_struct_struct_OC_dim3_field0);\n  69:   uint32_t __FIXME__call17 = num_blocks((ny - 1), block.__FIXME__l_struct_struct_OC_dim3_field1);\n  70:   grid.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call14;\n  71:   grid.__FIXME__l_struct_struct_OC_dim3_field1 = __FIXME__call17;\n  72:   grid.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  73:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp18)), ((uint8_t*)(&grid)), 12);\n  74:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp19)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  75:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp18_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp18)), 12);\n  76:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp19_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp19)), 12);\n  77: #pragma omp parallel for collapse(2)\n  78: for(int32_t j = 0; j < __FIXME__call14;   j = j + 1){\n  79: for(int32_t k = 0; k < __FIXME__call17;   k = k + 1){\n  80: for(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\n  81: for(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n  82: kernel_ex(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call14, __FIXME__call17, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n  83: }\n  84: }\n  85: }\n  86: }\n  87:   block.__FIXME__l_struct_struct_OC_dim3_field0 = TILE_DIM_L_1;\n  88:   block.__FIXME__l_struct_struct_OC_dim3_field1 = TILE_DIM_M_1;\n  89:   block.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  90:   uint32_t __FIXME__call28 = num_blocks((nx - 1), block.__FIXME__l_struct_struct_OC_dim3_field0);\n  91:   uint32_t __FIXME__call31 = num_blocks((ny - 1), block.__FIXME__l_struct_struct_OC_dim3_field1);\n  92:   grid.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call28;\n  93:   grid.__FIXME__l_struct_struct_OC_dim3_field1 = __FIXME__call31;\n  94:   grid.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  95:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp32)), ((uint8_t*)(&grid)), 12);\n  96:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp33)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  97:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp32_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp32)), 12);\n  98:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp33_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp33)), 12);\n  99: #pragma omp parallel for collapse(2)\n 100: for(int32_t j = 0; j < __FIXME__call28;   j = j + 1){\n 101: for(int32_t k = 0; k < __FIXME__call31;   k = k + 1){\n 102: for(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\n 103: for(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n 104: kernel_hz(tmax, nx, ny, ex, ey, hz, fict, t, __FIXME__call28, __FIXME__call31, 1, TILE_DIM_L_1, TILE_DIM_M_1, 1, j, k, 0, l, m, 0);\n 105: }\n 106: }\n 107: }\n 108: }\n 109: }\n 110:   return;\n 111: }\n```"
}