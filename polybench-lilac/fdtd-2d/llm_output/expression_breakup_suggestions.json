{
  "function_name": "init_array",
  "breakups": [
    {
      "line_number": 160,
      "original_expression": "ex[(i * ny + j)] = (((double)(i) * (double)((j + 1))) / (double)(nx));",
      "breakup_steps": [
        {
          "temp_var": "idx",
          "expression": "i * ny + j",
          "description": "Compute the flattened 2D index into ex/ey/hz"
        },
        {
          "temp_var": "j_plus_1",
          "expression": "j + 1",
          "description": "Increment j by 1 for the offset term"
        },
        {
          "temp_var": "i_as_double",
          "expression": "(double)i",
          "description": "Convert i to double before multiplication"
        },
        {
          "temp_var": "j_plus_1_as_double",
          "expression": "(double)j_plus_1",
          "description": "Convert j_plus_1 to double before multiplication"
        },
        {
          "temp_var": "ex_numerator",
          "expression": "i_as_double * j_plus_1_as_double",
          "description": "Compute the numerator of the fraction"
        },
        {
          "temp_var": "nx_as_double",
          "expression": "(double)nx",
          "description": "Convert nx to double for division"
        },
        {
          "temp_var": "ex_value",
          "expression": "ex_numerator / nx_as_double",
          "description": "Compute the final value to store in ex"
        }
      ],
      "final_expression": "ex[idx] = ex_value;"
    },
    {
      "line_number": 161,
      "original_expression": "ey[(i * ny + j)] = (((double)(i) * (double)((j + INIT_EY_J_OFFSET))) / (double)(ny));",
      "breakup_steps": [
        {
          "temp_var": "idx",
          "expression": "i * ny + j",
          "description": "Compute the flattened 2D index into ex/ey/hz"
        },
        {
          "temp_var": "j_ey_offset",
          "expression": "j + INIT_EY_J_OFFSET",
          "description": "Apply the EY-specific j offset"
        },
        {
          "temp_var": "i_as_double",
          "expression": "(double)i",
          "description": "Convert i to double before multiplication"
        },
        {
          "temp_var": "j_ey_as_double",
          "expression": "(double)j_ey_offset",
          "description": "Convert the offset j term to double"
        },
        {
          "temp_var": "ey_numerator",
          "expression": "i_as_double * j_ey_as_double",
          "description": "Compute the numerator of the fraction"
        },
        {
          "temp_var": "ny_as_double",
          "expression": "(double)ny",
          "description": "Convert ny to double for division"
        },
        {
          "temp_var": "ey_value",
          "expression": "ey_numerator / ny_as_double",
          "description": "Compute the final value to store in ey"
        }
      ],
      "final_expression": "ey[idx] = ey_value;"
    },
    {
      "line_number": 162,
      "original_expression": "hz[(i * ny + j)] = (((double)(i) * (double)((j + INIT_HZ_J_OFFSET))) / (double)(nx));",
      "breakup_steps": [
        {
          "temp_var": "idx",
          "expression": "i * ny + j",
          "description": "Compute the flattened 2D index into ex/ey/hz"
        },
        {
          "temp_var": "j_hz_offset",
          "expression": "j + INIT_HZ_J_OFFSET",
          "description": "Apply the HZ-specific j offset"
        },
        {
          "temp_var": "i_as_double",
          "expression": "(double)i",
          "description": "Convert i to double before multiplication"
        },
        {
          "temp_var": "j_hz_as_double",
          "expression": "(double)j_hz_offset",
          "description": "Convert the offset j term to double"
        },
        {
          "temp_var": "hz_numerator",
          "expression": "i_as_double * j_hz_as_double",
          "description": "Compute the numerator of the fraction"
        },
        {
          "temp_var": "nx_as_double",
          "expression": "(double)nx",
          "description": "Convert nx to double for division"
        },
        {
          "temp_var": "hz_value",
          "expression": "hz_numerator / nx_as_double",
          "description": "Compute the final value to store in hz"
        }
      ],
      "final_expression": "hz[idx] = hz_value;"
    }
  ]
}