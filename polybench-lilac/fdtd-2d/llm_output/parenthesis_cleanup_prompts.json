{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 131 potential parentheses to evaluate:\n\nLine 253: hz[(i * ny + j)] = (hz[(i * ny + j)] - (0.69999999999999996 * (((ex[((i * ny + j) + 1)] - ex[(i * ny + j)]) + ey[((i + 1) * ny + j)]) - ey[(i * ny + j)])));\n  Potential parentheses to evaluate: (noinline)\nLine 290: dim_grid_ny.x = nb_blocks_ny_splat;\n  dim_grid_ny.y = 1;\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 425: \n  Potential parentheses to evaluate: (noinline), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[2]), (argv[3]), (argv[4]), (argv[1]), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (i), (double), (double), (nx), (double), (i), (double), (double), (ny), (double), (i), (double), (double), (nx), (uint32_t num, uint32_t factor), (ny, BLOCK_SIZE_NY_1), (uint8_t*), (&dim_thread_256_packed), (uint8_t*), (&dim_thread_256), (uint8_t*), (&dim_grid_ny_packed), (uint8_t*), (&dim_grid_ny), (2), (tmax, nx, ny, ex, ey, hz, fict, t, BLOCK_SIZE_NY_1, 1, 1, nb_blocks_ny_splat, 1, 1, j, 0, 0, k, 0, 0), (ny, block.y), (uint8_t*), (&dim_grid_ey), (uint8_t*), (&grid), (uint8_t*), (&dim_block_ey), (uint8_t*), (&block), (uint8_t*), (&dim_grid_ey_packed), (uint8_t*), (&dim_grid_ey), (uint8_t*), (&dim_block_ey_packed), (uint8_t*), (&dim_block_ey), (2), (tmax, nx, ny, ex, ey, hz, fict, t, ey_grid_x, ey_grid_y, ey_one1, ey_tile_L, ey_tile_M, ey_one2, ey_j, ey_k, ey_zero0, ey_l, ey_m, ey_zero1), (nx, block.x), (uint8_t*), (&dim_grid_ex), (uint8_t*), (&grid), (uint8_t*), (&dim_block_ex), (uint8_t*), (&block), (uint8_t*), (&dim_grid_ex_packed), (uint8_t*), (&dim_grid_ex), (uint8_t*), (&dim_block_ex_packed), (uint8_t*), (&dim_block_ex), (2), (tmax, nx, ny, ex, ey, hz, fict, t, ex_grid_x, ex_grid_y, ex_one1, ex_tile_L, ex_tile_M, ex_one2, ex_j, ex_k, ex_zero0, ex_l, ex_m, ex_zero1), (uint8_t*), (&dim_grid_hz), (uint8_t*), (&grid), (uint8_t*), (&dim_block_hz), (uint8_t*), (&block), (uint8_t*), (&dim_grid_hz_packed), (uint8_t*), (&dim_grid_hz), (uint8_t*), (&dim_block_hz_packed), (uint8_t*), (&dim_block_hz), (2), (tmax, nx, ny, ex, ey, hz, fict, t, hz_grid_x, hz_grid_y, hz_one1, hz_tile_L, hz_tile_M, hz_one2, hz_j, hz_k, hz_zero0, hz_l, hz_m, hz_zero1), (print_format), (print_format), (print_format), (int), (int), (newline), (newline)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n#define BLOCK_SIZE_NY_1 256\n#define TILE_DIM_L_1 8\n#define TILE_DIM_M_1 32\n#define BLOCK_STRUCT_SIZE_BYTES_1 12\n\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct Internal_FILE;\nstruct dim3_t;\nstruct dim3_packed_u32x3;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct array_u8_1 {\n  uint8_t array[1];\n};\nstruct array_u8_20 {\n  uint8_t array[20];\n};\nstruct Internal_FILE {\n  uint32_t file_flags;\n  uint8_t* read_pos;\n  uint8_t* read_end;\n  uint8_t* write_pos;\n  uint8_t* write_end;\n  uint8_t* buf_base;\n  uint8_t* buf_end;\n  uint8_t* buf_ptr;\n  uint8_t* unget_buf_ptr;\n  uint8_t* linebuf_ptr;\n  uint8_t* save_area;\n  uint8_t* save_end_ptr;\n  void* cookie;\n  struct Internal_FILE* prev;\n  uint32_t mode;\n  uint32_t fd;\n  uint64_t file_pos;\n  uint16_t orientation;\n  uint8_t small_char;\n  uint8_t smallbuf1[1];\n  uint8_t* ungetc_buf;\n  uint64_t file_size;\n  void* lock;\n  void* locale;\n  struct Internal_FILE* next;\n  uint8_t* filename;\n  uint64_t reserved64;\n  uint32_t checksum;\n  uint8_t pad20[20];\n};\nstruct dim3_t {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct dim3_packed_u32x3 {\n  uint64_t dim3_packed_u64;\n  uint32_t dim3_packed_u32;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_splat(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_ey(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_ex(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_hz(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_format[8] = { \"%0.2lf \" };\nuint8_t newline[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t tmax;\n  int32_t nx;\n  int32_t ny;\n  int32_t dump_code;\n  uint8_t* ex;\n  uint8_t* ey;\n  uint8_t* hz;\n  uint8_t* _fict_;\n  int32_t unused_call38;\n  int32_t unused_call53;\n\n// INSERT COMMENT IFELSE: main::entry\n  tmax = atoi(argv[2]);\n  nx = atoi(argv[3]);\n  ny = atoi(argv[4]);\n  dump_code = atoi(argv[1]);\n  ex = malloc(nx * ny * 8);\n  ey = malloc(nx * ny * 8);\n  hz = malloc(nx * ny * 8);\n  _fict_ = malloc(ny * 8);\n  init_array(nx, ny, ((double*)ex), ((double*)ey), ((double*)hz), ((double*)_fict_));\n;\n  kernel(tmax, nx, ny, ((double*)ex), ((double*)ey), ((double*)hz), ((double*)_fict_));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(nx, ny, ((double*)ex), ((double*)ey), ((double*)hz));\n  }\nfree(((uint8_t*)((double*)ex)));\nfree(((uint8_t*)((double*)ey)));\nfree(((uint8_t*)((double*)hz)));\nfree(((uint8_t*)((double*)_fict_)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* _fict_) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < ny;   i = i + 1){\n  _fict_[i] = (double)(i);\n}\n// INSERT COMMENT LOOP: init_array::for.cond1\nfor(int64_t i = 0; i < nx;   i = i + 1){\nfor(int64_t j = 0; j < ny;   j = j + 1){\n  ex[(i * ny + j)] = (((double)(i) * (double)((j + 1))) / (double)(nx));\n  ey[(i * ny + j)] = (((double)(i) * (double)((j + 2))) / (double)(ny));\n  hz[(i * ny + j)] = (((double)(i) * (double)((j + 3))) / (double)(nx));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_splat\nvoid kernel_splat(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_splat::entry\n  j = blockDim_x * blockIdx_x + threadIdx_x;\n  if (j < ny) { // IFELSE MARKER: entry IF\n  ey[(0 * ny + j)] = fict[t];\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_ey\nvoid kernel_ey(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_ey::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x + 1;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < nx) { // IFELSE MARKER: entry IF\n  if (j < ny) { // IFELSE MARKER: land.lhs.true IF\n  ey[(i * ny + j)] = (ey[(i * ny + j)] - (0.5 * (hz[(i * ny + j)] - hz[((i - 1) * ny + j)])));\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_ex\nvoid kernel_ex(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_ex::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y + 1;\n  if (i < nx) { // IFELSE MARKER: entry IF\n  if (j < ny) { // IFELSE MARKER: land.lhs.true IF\n  ex[(i * ny + j)] = (ex[(i * ny + j)] - (0.5 * (hz[(i * ny + j)] - hz[((i * ny + j) - 1)])));\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_hz\nvoid kernel_hz(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_hz::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < (nx - 1)) { // IFELSE MARKER: entry IF\n  if (j < (ny - 1)) { // IFELSE MARKER: land.lhs.true IF\n  hz[(i * ny + j)] = (hz[(i * ny + j)] - (0.69999999999999996 * (((ex[((i * ny + j) + 1)] - ex[(i * ny + j)]) + ey[((i + 1) * ny + j)]) - ey[(i * ny + j)])));\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict) {\n  struct dim3_t dim_thread_256;    /* Address-exposed local */\n  struct dim3_t dim_grid_ny;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_thread_256_packed;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_grid_ny_packed;    /* Address-exposed local */\n  struct dim3_t block;    /* Address-exposed local */\n  struct dim3_t grid;    /* Address-exposed local */\n  struct dim3_t dim_grid_ey;    /* Address-exposed local */\n  struct dim3_t dim_block_ey;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_grid_ey_packed;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_block_ey_packed;    /* Address-exposed local */\n  struct dim3_t dim_grid_ex;    /* Address-exposed local */\n  struct dim3_t dim_block_ex;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_grid_ex_packed;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_block_ex_packed;    /* Address-exposed local */\n  struct dim3_t dim_grid_hz;    /* Address-exposed local */\n  struct dim3_t dim_block_hz;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_grid_hz_packed;    /* Address-exposed local */\n  struct dim3_packed_u32x3 dim_block_hz_packed;    /* Address-exposed local */\n  int32_t t;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n// INSERT COMMENT LOOP: kernel::for.cond\nfor(int32_t t = 0; t < tmax;   t = t + 1){\n  dim_thread_256.x = 256;\n  dim_thread_256.y = 1;\n  dim_thread_256.z = 1;\n  uint32_t nb_blocks_ny_splat = num_blocks(ny, BLOCK_SIZE_NY_1);\n  dim_grid_ny.x = nb_blocks_ny_splat;\n  dim_grid_ny.y = 1;\n  dim_grid_ny.z = 1;\n  memcpy(((uint8_t*)(&dim_thread_256_packed)), ((uint8_t*)(&dim_thread_256)), 12);\n  memcpy(((uint8_t*)(&dim_grid_ny_packed)), ((uint8_t*)(&dim_grid_ny)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < 256;   j = j + 1){\nfor(int32_t k = 0; k < nb_blocks_ny_splat;   k = k + 1){\nkernel_splat(tmax, nx, ny, ex, ey, hz, fict, t, BLOCK_SIZE_NY_1, 1, 1, nb_blocks_ny_splat, 1, 1, j, 0, 0, k, 0, 0);\n}\n}\n  block.x = TILE_DIM_L_1;\n  block.y = TILE_DIM_M_1;\n  block.z = 1;\n  uint32_t nb_blocks_nx_minus1_stage1 = num_blocks((nx - 1), block.x);\n  uint32_t nb_blocks_ny_stage1 = num_blocks(ny, block.y);\n  grid.x = nb_blocks_nx_minus1_stage1;\n  grid.y = nb_blocks_ny_stage1;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&dim_grid_ey)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&dim_block_ey)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  memcpy(((uint8_t*)(&dim_grid_ey_packed)), ((uint8_t*)(&dim_grid_ey)), 12);\n  memcpy(((uint8_t*)(&dim_block_ey_packed)), ((uint8_t*)(&dim_block_ey)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < nb_blocks_nx_minus1_stage1;   j = j + 1){\nfor(int32_t k = 0; k < nb_blocks_ny_stage1;   k = k + 1){\nfor(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\nfor(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n__auto_type ey_grid_x = nb_blocks_nx_minus1_stage1;\n__auto_type ey_grid_y = nb_blocks_ny_stage1;\n__auto_type ey_one1 = 1;\n__auto_type ey_tile_L = TILE_DIM_L_1;\n__auto_type ey_tile_M = TILE_DIM_M_1;\n__auto_type ey_one2 = 1;\n__auto_type ey_j = j;\n__auto_type ey_k = k;\n__auto_type ey_zero0 = 0;\n__auto_type ey_l = l;\n__auto_type ey_m = m;\n__auto_type ey_zero1 = 0;\nkernel_ey(tmax, nx, ny, ex, ey, hz, fict, t, ey_grid_x, ey_grid_y, ey_one1, ey_tile_L, ey_tile_M, ey_one2, ey_j, ey_k, ey_zero0, ey_l, ey_m, ey_zero1);\n}\n}\n}\n}\n  block.x = TILE_DIM_L_1;\n  block.y = TILE_DIM_M_1;\n  block.z = 1;\n  uint32_t nb_blocks_nx_stage2 = num_blocks(nx, block.x);\n  uint32_t nb_blocks_ny_minus1_stage2 = num_blocks((ny - 1), block.y);\n  grid.x = nb_blocks_nx_stage2;\n  grid.y = nb_blocks_ny_minus1_stage2;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&dim_grid_ex)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&dim_block_ex)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  memcpy(((uint8_t*)(&dim_grid_ex_packed)), ((uint8_t*)(&dim_grid_ex)), 12);\n  memcpy(((uint8_t*)(&dim_block_ex_packed)), ((uint8_t*)(&dim_block_ex)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < nb_blocks_nx_stage2;   j = j + 1){\nfor(int32_t k = 0; k < nb_blocks_ny_minus1_stage2;   k = k + 1){\nfor(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\nfor(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n__auto_type ex_grid_x = nb_blocks_nx_stage2;\n__auto_type ex_grid_y = nb_blocks_ny_minus1_stage2;\n__auto_type ex_one1 = 1;\n__auto_type ex_tile_L = TILE_DIM_L_1;\n__auto_type ex_tile_M = TILE_DIM_M_1;\n__auto_type ex_one2 = 1;\n__auto_type ex_j = j;\n__auto_type ex_k = k;\n__auto_type ex_zero0 = 0;\n__auto_type ex_l = l;\n__auto_type ex_m = m;\n__auto_type ex_zero1 = 0;\nkernel_ex(tmax, nx, ny, ex, ey, hz, fict, t, ex_grid_x, ex_grid_y, ex_one1, ex_tile_L, ex_tile_M, ex_one2, ex_j, ex_k, ex_zero0, ex_l, ex_m, ex_zero1);\n}\n}\n}\n}\n  block.x = TILE_DIM_L_1;\n  block.y = TILE_DIM_M_1;\n  block.z = 1;\n  uint32_t nb_blocks_nx_minus1_stage3 = num_blocks((nx - 1), block.x);\n  uint32_t nb_blocks_ny_minus1_stage3 = num_blocks((ny - 1), block.y);\n  grid.x = nb_blocks_nx_minus1_stage3;\n  grid.y = nb_blocks_ny_minus1_stage3;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&dim_grid_hz)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&dim_block_hz)), ((uint8_t*)(&block)), BLOCK_STRUCT_SIZE_BYTES_1);\n  memcpy(((uint8_t*)(&dim_grid_hz_packed)), ((uint8_t*)(&dim_grid_hz)), 12);\n  memcpy(((uint8_t*)(&dim_block_hz_packed)), ((uint8_t*)(&dim_block_hz)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < nb_blocks_nx_minus1_stage3;   j = j + 1){\nfor(int32_t k = 0; k < nb_blocks_ny_minus1_stage3;   k = k + 1){\nfor(int32_t l = 0; l < TILE_DIM_L_1;   l = l + 1){\nfor(int32_t m = 0; m < TILE_DIM_M_1;   m = m + 1){\n__auto_type hz_grid_x = nb_blocks_nx_minus1_stage3;\n__auto_type hz_grid_y = nb_blocks_ny_minus1_stage3;\n__auto_type hz_one1 = 1;\n__auto_type hz_tile_L = TILE_DIM_L_1;\n__auto_type hz_tile_M = TILE_DIM_M_1;\n__auto_type hz_one2 = 1;\n__auto_type hz_j = j;\n__auto_type hz_k = k;\n__auto_type hz_zero0 = 0;\n__auto_type hz_l = l;\n__auto_type hz_m = m;\n__auto_type hz_zero1 = 0;\nkernel_hz(tmax, nx, ny, ex, ey, hz, fict, t, hz_grid_x, hz_grid_y, hz_one1, hz_tile_L, hz_tile_M, hz_one2, hz_j, hz_k, hz_zero0, hz_l, hz_m, hz_zero1);\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz) {\n  int64_t i;\n  int64_t j;\n  int32_t print_counter;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < nx;   i = i + 1){\nfor(int64_t j = 0; j < ny;   j = j + 1){\n  fprintf(stderr, (print_format), ex[(i * ny + j)]);\n  fprintf(stderr, (print_format), ey[(i * ny + j)]);\n  fprintf(stderr, (print_format), hz[(i * ny + j)]);\n  if ((int)(i * nx + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline));\n  }\n}\n}\n  fprintf(stderr, (newline));\n}\n\n```"
}