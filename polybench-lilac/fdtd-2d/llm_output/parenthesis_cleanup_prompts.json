{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 124 potential parentheses to evaluate:\n\nLine 65: /* External Global Variable Declarations */\n  Potential parentheses to evaluate: (__GNUC__)\nLine 67: /* Function Declarations */\n  Potential parentheses to evaluate: (x)\nLine 272: splat_block_dim.x = SPLAT_BLOCK_DIM_X;\n  Potential parentheses to evaluate: (noinline)\nLine 374: \n  Potential parentheses to evaluate: (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[ARG_IDX_TMAX]), (argv[ARG_IDX_NX]), (argv[ARG_IDX_NY]), (argv[ARG_IDX_DUMP]), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (double), (double), (double), (double), (double), (double), (double), (double), (uint32_t num, uint32_t factor), (ny, SPLAT_BLOCK_DIM_X), (uint8_t*), (&splat_block_dim_coerce), (uint8_t*), (&splat_block_dim), (uint8_t*), (&splat_grid_dim_coerce), (uint8_t*), (&splat_grid_dim), (2), (tmax, nx, ny, ex, ey, hz, fict, t, 256, 1, 1, splat_grid_x, 1, 1, j, 0, 0, k, 0, 0), (ny, block.y), (uint8_t*), (&ey_grid_dim), (uint8_t*), (&grid), (uint8_t*), (&ey_block_dim), (uint8_t*), (&block), (uint8_t*), (&ey_grid_dim_coerce), (uint8_t*), (&ey_grid_dim), (uint8_t*), (&ey_block_dim_coerce), (uint8_t*), (&ey_block_dim), (2), (tmax, nx, ny, ex, ey, hz, fict, t, ey_grid_x, ey_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (nx, block.x), (uint8_t*), (&ex_grid_dim), (uint8_t*), (&grid), (uint8_t*), (&ex_block_dim), (uint8_t*), (&block), (uint8_t*), (&ex_grid_dim_coerce), (uint8_t*), (&ex_grid_dim), (uint8_t*), (&ex_block_dim_coerce), (uint8_t*), (&ex_block_dim), (2), (tmax, nx, ny, ex, ey, hz, fict, t, ex_grid_x, ex_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (uint8_t*), (&hz_grid_dim), (uint8_t*), (&grid), (uint8_t*), (&hz_block_dim), (uint8_t*), (&block), (uint8_t*), (&hz_grid_dim_coerce), (uint8_t*), (&hz_grid_dim), (uint8_t*), (&hz_block_dim_coerce), (uint8_t*), (&hz_block_dim), (2), (tmax, nx, ny, ex, ey, hz, fict, t, hz_grid_x, hz_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (print_fmt_double_2dp_space), (print_fmt_double_2dp_space), (print_fmt_double_2dp_space), (int), (int), (newline_str), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n/* Magic number constants */\n#define BYTES_PER_DOUBLE 8\n#define FDTD_E_UPDATE_COEFF 0.5\n#define SPLAT_BLOCK_DIM_X 256\n#define DIM3_STRUCT_SIZE_BYTES 12\n#define ARG_IDX_TMAX 2\n#define ARG_IDX_NX 3\n#define ARG_IDX_NY 4\n#define ARG_IDX_DUMP 1\n#define DUMP_ENABLED_VALUE 1\n#define INIT_EY_J_OFFSET 2\n#define INIT_HZ_J_OFFSET 3\n\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct Dim3;\nstruct Dim3Coerce;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array_1 {\n  uint8_t array[1];\n};\nstruct uint8_array_20 {\n  uint8_t array[20];\n};\nstruct Dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct Dim3Coerce {\n  uint64_t offset;\n  uint32_t length;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_splat(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_ey(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_ex(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_hz(uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_fmt_double_2dp_space[8] = { \"%0.2lf \" };\nuint8_t newline_str[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t tmax;\n  int32_t nx;\n  int32_t ny;\n  int32_t dump_code;\n  uint8_t* ex;\n  uint8_t* ey;\n  uint8_t* hz;\n  uint8_t* _fict_;\n\n// INSERT COMMENT IFELSE: main::entry\n  tmax = atoi(argv[ARG_IDX_TMAX]);\n  nx = atoi(argv[ARG_IDX_NX]);\n  ny = atoi(argv[ARG_IDX_NY]);\n  dump_code = atoi(argv[ARG_IDX_DUMP]);\n  ex = malloc(nx * ny * BYTES_PER_DOUBLE);\n  ey = malloc(nx * ny * BYTES_PER_DOUBLE);\n  hz = malloc(nx * ny * BYTES_PER_DOUBLE);\n  _fict_ = malloc(ny * BYTES_PER_DOUBLE);\n  init_array(nx, ny, ((double*)ex), ((double*)ey), ((double*)hz), ((double*)_fict_));\n;\n  kernel(tmax, nx, ny, ((double*)ex), ((double*)ey), ((double*)hz), ((double*)_fict_));\n;\n  if (dump_code == DUMP_ENABLED_VALUE) { // IFELSE MARKER: entry IF\nprint_array(nx, ny, ((double*)ex), ((double*)ey), ((double*)hz));\n  }\nfree(((uint8_t*)((double*)ex)));\nfree(((uint8_t*)((double*)ey)));\nfree(((uint8_t*)((double*)hz)));\nfree(((uint8_t*)((double*)_fict_)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* _fict_) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < ny;   i = i + 1){\n  _fict_[i] = (double)(i);\n}\n// INSERT COMMENT LOOP: init_array::for.cond1\nfor(int64_t i = 0; i < nx;   i = i + 1){\nfor(int64_t j = 0; j < ny;   j = j + 1){\n  int ex_index = i * ny + j;\n  int ex_j_plus_1 = j + 1;\n  double i_as_double_ex = (double)i;\n  double ex_jp1_as_double = (double)ex_j_plus_1;\n  double ex_numer = i_as_double_ex * ex_jp1_as_double;\n  double nx_as_double_ex = (double)nx;\n  double ex_value = ex_numer / nx_as_double_ex;\n  ex[(i * ny + j)] = ex_value;\n  int ey_index = i * ny + j;\n  int ey_j_offset = j + INIT_EY_J_OFFSET;\n  double i_as_double_ey = (double)i;\n  double ey_j_off_as_double = (double)ey_j_offset;\n  double ey_numer = i_as_double_ey * ey_j_off_as_double;\n  double ny_as_double_ey = (double)ny;\n  double ey_value = ey_numer / ny_as_double_ey;\n  ey[(i * ny + j)] = ey_value;\n  int hz_index = i * ny + j;\n  int hz_j_offset = j + INIT_HZ_J_OFFSET;\n  double i_as_double_hz = (double)i;\n  double hz_j_off_as_double = (double)hz_j_offset;\n  double hz_numer = i_as_double_hz * hz_j_off_as_double;\n  double nx_as_double_hz = (double)nx;\n  double hz_value = hz_numer / nx_as_double_hz;\n  hz[(i * ny + j)] = hz_value;\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_splat\nvoid kernel_splat(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_splat::entry\n  j = blockDim_x * blockIdx_x + threadIdx_x;\n  if (j < ny) { // IFELSE MARKER: entry IF\n  ey[(0 * ny + j)] = fict[t];\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_ey\nvoid kernel_ey(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_ey::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x + 1;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < nx && j < ny) {\n    ey[(i * ny + j)] = (ey[(i * ny + j)] - (FDTD_E_UPDATE_COEFF * (hz[(i * ny + j)] - hz[((i - 1) * ny + j)])));\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_ex\nvoid kernel_ex(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_ex::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y + 1;\n  if (i < nx && j < ny) {\n    ex[(i * ny + j)] = (ex[(i * ny + j)] - (FDTD_E_UPDATE_COEFF * (hz[(i * ny + j)] - hz[((i * ny + j) - 1)])));\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_hz\nvoid kernel_hz(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict, uint32_t t, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_hz::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < (nx - 1)) { // IFELSE MARKER: entry IF\n  if (j < (ny - 1)) { // IFELSE MARKER: land.lhs.true IF\n  hz[(i * ny + j)] = (hz[(i * ny + j)] - (0.69999999999999996 * (((ex[((i * ny + j) + 1)] - ex[(i * ny + j)]) + ey[((i + 1) * ny + j)]) - ey[(i * ny + j)])));\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t tmax, uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz, double* fict) {\n  struct Dim3 splat_block_dim;    /* Address-exposed local */\n  struct Dim3 splat_grid_dim;    /* Address-exposed local */\n  struct Dim3Coerce splat_block_dim_coerce;    /* Address-exposed local */\n  struct Dim3Coerce splat_grid_dim_coerce;    /* Address-exposed local */\n  struct Dim3 block;    /* Address-exposed local */\n  struct Dim3 grid;    /* Address-exposed local */\n  struct Dim3 ey_grid_dim;    /* Address-exposed local */\n  struct Dim3 ey_block_dim;    /* Address-exposed local */\n  struct Dim3Coerce ey_grid_dim_coerce;    /* Address-exposed local */\n  struct Dim3Coerce ey_block_dim_coerce;    /* Address-exposed local */\n  struct Dim3 ex_grid_dim;    /* Address-exposed local */\n  struct Dim3 ex_block_dim;    /* Address-exposed local */\n  struct Dim3Coerce ex_grid_dim_coerce;    /* Address-exposed local */\n  struct Dim3Coerce ex_block_dim_coerce;    /* Address-exposed local */\n  struct Dim3 hz_grid_dim;    /* Address-exposed local */\n  struct Dim3 hz_block_dim;    /* Address-exposed local */\n  struct Dim3Coerce hz_grid_dim_coerce;    /* Address-exposed local */\n  struct Dim3Coerce hz_block_dim_coerce;    /* Address-exposed local */\n  int32_t t;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n// INSERT COMMENT LOOP: kernel::for.cond\nfor(int32_t t = 0; t < tmax;   t = t + 1){\n  splat_block_dim.x = SPLAT_BLOCK_DIM_X;\n  splat_block_dim.y = 1;\n  splat_block_dim.z = 1;\n  uint32_t splat_grid_x = num_blocks(ny, SPLAT_BLOCK_DIM_X);\n  splat_grid_dim.x = splat_grid_x;\n  splat_grid_dim.y = 1;\n  splat_grid_dim.z = 1;\n  memcpy(((uint8_t*)(&splat_block_dim_coerce)), ((uint8_t*)(&splat_block_dim)), DIM3_STRUCT_SIZE_BYTES);\n  memcpy(((uint8_t*)(&splat_grid_dim_coerce)), ((uint8_t*)(&splat_grid_dim)), DIM3_STRUCT_SIZE_BYTES);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < SPLAT_BLOCK_DIM_X;   j = j + 1){\nfor(int32_t k = 0; k < splat_grid_x;   k = k + 1){\nkernel_splat(tmax, nx, ny, ex, ey, hz, fict, t, 256, 1, 1, splat_grid_x, 1, 1, j, 0, 0, k, 0, 0);\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  uint32_t ey_grid_x = num_blocks((nx - 1), block.x);\n  uint32_t ey_grid_y = num_blocks(ny, block.y);\n  grid.x = ey_grid_x;\n  grid.y = ey_grid_y;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&ey_grid_dim)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&ey_block_dim)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&ey_grid_dim_coerce)), ((uint8_t*)(&ey_grid_dim)), 12);\n  memcpy(((uint8_t*)(&ey_block_dim_coerce)), ((uint8_t*)(&ey_block_dim)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < ey_grid_x;   j = j + 1){\nfor(int32_t k = 0; k < ey_grid_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_ey(tmax, nx, ny, ex, ey, hz, fict, t, ey_grid_x, ey_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  uint32_t ex_grid_x = num_blocks(nx, block.x);\n  uint32_t ex_grid_y = num_blocks((ny - 1), block.y);\n  grid.x = ex_grid_x;\n  grid.y = ex_grid_y;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&ex_grid_dim)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&ex_block_dim)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&ex_grid_dim_coerce)), ((uint8_t*)(&ex_grid_dim)), 12);\n  memcpy(((uint8_t*)(&ex_block_dim_coerce)), ((uint8_t*)(&ex_block_dim)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < ex_grid_x;   j = j + 1){\nfor(int32_t k = 0; k < ex_grid_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_ex(tmax, nx, ny, ex, ey, hz, fict, t, ex_grid_x, ex_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  uint32_t hz_grid_x = num_blocks((nx - 1), block.x);\n  uint32_t hz_grid_y = num_blocks((ny - 1), block.y);\n  grid.x = hz_grid_x;\n  grid.y = hz_grid_y;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&hz_grid_dim)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&hz_block_dim)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&hz_grid_dim_coerce)), ((uint8_t*)(&hz_grid_dim)), 12);\n  memcpy(((uint8_t*)(&hz_block_dim_coerce)), ((uint8_t*)(&hz_block_dim)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < hz_grid_x;   j = j + 1){\nfor(int32_t k = 0; k < hz_grid_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_hz(tmax, nx, ny, ex, ey, hz, fict, t, hz_grid_x, hz_grid_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t nx, uint32_t ny, double* ex, double* ey, double* hz) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < nx;   i = i + 1){\nfor(int64_t j = 0; j < ny;   j = j + 1){\n  fprintf(stderr, (print_fmt_double_2dp_space), ex[(i * ny + j)]);\n  fprintf(stderr, (print_fmt_double_2dp_space), ey[(i * ny + j)]);\n  fprintf(stderr, (print_fmt_double_2dp_space), hz[(i * ny + j)]);\n  if ((int)(i * nx + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline_str));\n  }\n}\n}\n  fprintf(stderr, (newline_str));\n}\n\n```"
}