{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 74 potential parentheses to evaluate:\n\nLine 176: __auto_type prod_plus_2 = prod_i_jp2 + 2.0;\n  Potential parentheses to evaluate: (uint8_t*)\nLine 285: \n  Potential parentheses to evaluate: (noinline), (noinline), (uint8_t*), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[1]), (argv[2]), (argv[3]), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (double), (double), (double), (double), (double), (uint32_t num, uint32_t factor), (uint8_t*), (&grid_copy), (uint8_t*), (&grid), (uint8_t*), (&block_copy), (uint8_t*), (&block), (uint8_t*), (&grid_pair_coerce), (uint8_t*), (&grid_copy), (uint8_t*), (&block_pair_coerce), (uint8_t*), (&block_copy), (2), (n, A, B, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (uint8_t*), (&grid_copy2), (uint8_t*), (&grid), (uint8_t*), (&block_copy2), (uint8_t*), (&block), (uint8_t*), (&grid_pair_coerce2), (uint8_t*), (&grid_copy2), (uint8_t*), (&block_pair_coerce2), (uint8_t*), (&block_copy2), (2), (n, B, A, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0), (print_format_double), (int), (int), (print_newline), (print_newline)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct StdFile;\nstruct Dim3;\nstruct UInt64UInt32Pair;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct UInt8Array1 {\n  uint8_t array[1];\n};\nstruct UInt8Array20 {\n  uint8_t array[20];\n};\nstruct StdFile {\n  uint32_t batch_flags;\n  uint8_t* batch_buf_base;\n  uint8_t* batch_buf_pos;\n  uint8_t* batch_buf_end;\n  uint8_t* batch_buf_read;\n  uint8_t* batch_buf_write;\n  uint8_t* batch_buf_aux0;\n  uint8_t* batch_buf_aux1;\n  uint8_t* batch_buf_aux2;\n  uint8_t* batch_buf_aux3;\n  uint8_t* batch_buf_aux4;\n  uint8_t* batch_buf_aux5;\n  void* batch_cookie;\n  struct StdFile* batch_prev;\n  uint32_t batch_u32_14;\n  uint32_t batch_u32_15;\n  uint64_t batch_u64_16;\n  uint16_t batch_u16_17;\n  uint8_t batch_u8_18;\n  uint8_t batch_smallbuf[1];\n  uint8_t* batch_buf_extra;\n  uint64_t batch_u64_21;\n  void* batch_lock;\n  void* batch_cookie2;\n  struct StdFile* batch_next;\n  uint8_t* batch_buf_dynamic;\n  uint64_t batch_u64_26;\n  uint32_t batch_u32_27;\n  uint8_t batch_padding[20];\n};\nstruct Dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct UInt64UInt32Pair {\n  uint64_t first64;\n  uint32_t second32;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, uint32_t, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t cudaFree(uint8_t*);\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_stencil(uint32_t, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_format_double[8] = { \"%0.2lf \" };\nuint8_t print_newline[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t n;\n  int32_t tsteps;\n  uint8_t* A;\n  uint8_t* B;\n  int32_t unused_call22;\n  int32_t unused_call30;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[1]);\n  n = atoi(argv[2]);\n  tsteps = atoi(argv[3]);\n  A = malloc(n * n * 8);\n  B = malloc(n * n * 8);\n  init_array(n, ((double*)A), ((double*)B));\n;\n  kernel(tsteps, n, ((double*)A), ((double*)B));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(n, ((double*)A));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)B)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A, double* B) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  __auto_type index_A = i * n + j;\n  __auto_type i_double = (double)i;\n  __auto_type j_plus_2_double = (double)(j + 2);\n  __auto_type prod_i_jp2 = i_double * j_plus_2_double;\n  __auto_type prod_plus_2 = prod_i_jp2 + 2.0;\n  __auto_type A_value = prod_plus_2 / (double)n;\n  A[(i * n + j)] = A_value;\n  __auto_type index_B = i * n + j;\n  __auto_type i_double2 = (double)i;\n  __auto_type j_plus_3_double = (double)(j + 3);\n  __auto_type prod_i_jp3 = i_double2 * j_plus_3_double;\n  __auto_type prod_plus_3 = prod_i_jp3 + 3.0;\n  __auto_type B_value = prod_plus_3 / (double)n;\n  B[(i * n + j)] = B_value;\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_stencil\nvoid kernel_stencil(uint32_t n, double* A, double* B, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n\n// INSERT COMMENT IFELSE: kernel_stencil::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x + 1;\n  j = blockDim_y * blockIdx_y + threadIdx_y + 1;\n  if (i < (n - 1)) { // IFELSE MARKER: entry IF\n  if (j < (n - 1)) { // IFELSE MARKER: land.lhs.true IF\n  B[(i * n + j)] = (((((A[(i * n + j)] + A[((i * n + j) - 1)]) + A[((i * n + 1) + j)]) + A[((1 + i) * n + j)]) + A[((i - 1) * n + j)]) / 5);\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t tsteps, uint32_t n, double* A, double* B) {\n  struct Dim3 block;    /* Address-exposed local */\n  struct Dim3 grid;    /* Address-exposed local */\n  struct Dim3 grid_copy;    /* Address-exposed local */\n  struct Dim3 block_copy;    /* Address-exposed local */\n  struct UInt64UInt32Pair grid_pair_coerce;    /* Address-exposed local */\n  struct UInt64UInt32Pair block_pair_coerce;    /* Address-exposed local */\n  struct Dim3 grid_copy2;    /* Address-exposed local */\n  struct Dim3 block_copy2;    /* Address-exposed local */\n  struct UInt64UInt32Pair grid_pair_coerce2;    /* Address-exposed local */\n  struct UInt64UInt32Pair block_pair_coerce2;    /* Address-exposed local */\n  int32_t t;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  uint32_t m;\n\n// INSERT COMMENT LOOP: kernel::for.cond\nfor(int32_t t = 1; t <= tsteps;   t = t + 1){\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  uint32_t num_blocks_x = num_blocks((n - 2), block.x);\n  uint32_t num_blocks_y = num_blocks((n - 2), block.y);\n  grid.x = num_blocks_x;\n  grid.y = num_blocks_y;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&grid_copy)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&block_copy)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&grid_pair_coerce)), ((uint8_t*)(&grid_copy)), 12);\n  memcpy(((uint8_t*)(&block_pair_coerce)), ((uint8_t*)(&block_copy)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < num_blocks_x;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_stencil(n, A, B, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n  memcpy(((uint8_t*)(&grid_copy2)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&block_copy2)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&grid_pair_coerce2)), ((uint8_t*)(&grid_copy2)), 12);\n  memcpy(((uint8_t*)(&block_pair_coerce2)), ((uint8_t*)(&block_copy2)), 12);\n#pragma omp parallel for collapse(2)\nfor(int32_t j = 0; j < num_blocks_x;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_y;   k = k + 1){\nfor(int32_t l = 0; l < 8;   l = l + 1){\nfor(int32_t m = 0; m < 32;   m = m + 1){\nkernel_stencil(n, B, A, num_blocks_x, num_blocks_y, 1, 8, 32, 1, j, k, 0, l, m, 0);\n}\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* A) {\n  int64_t i;\n  uint64_t j;\n  int32_t temp_i32;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < n;   j = j + 1){\n  fprintf(stderr, (print_format_double), A[(i * n + j)]);\n  if ((int)(i * n + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (print_newline));\n  }\n}\n}\n  fprintf(stderr, (print_newline));\n}\n\n```"
}