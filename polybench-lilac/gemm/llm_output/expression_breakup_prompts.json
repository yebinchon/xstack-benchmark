{
  "system_prompt": "You are an expert C programmer specializing in code refactoring and readability.\nYour task is to analyze a C function and identify expressions that would benefit from being broken up into multiple lines using temporary variables for better readability.\n\nConsider these principles when deciding which expressions to break up:\n- Expressions that are visually long or complex on a single line\n- Expressions with multiple operators or function calls\n- Expressions that mix different types of operations\n- Nested function calls or complex arithmetic\n- Boolean expressions with many conditions\n- Any expression that makes the code hard to understand at a glance\n\nFor each expression you decide should be broken up, suggest:\n1. The exact line number where the expression appears (relative to the function start)\n2. The original expression text\n3. How to break it up into smaller sub-expressions with temporary variables\n4. Appropriate names for temporary variables (following C naming conventions)\n5. The optimal order of operations to maintain correctness\n\nReturn your response as JSON with this structure:\n{\n    \"function_name\": \"function_name_here\",\n    \"breakups\": [\n        {\n            \"line_number\": 5,\n            \"original_expression\": \"a + b * c + d / e + sin(a) * cos(b)\",\n            \"breakup_steps\": [\n                {\n                    \"temp_var\": \"product_term\",\n                    \"expression\": \"b * c\",\n                    \"description\": \"Calculate the product of b and c\"\n                },\n                {\n                    \"temp_var\": \"quotient_term\",\n                    \"expression\": \"d / e\",\n                    \"description\": \"Calculate the quotient of d and e\"\n                },\n                {\n                    \"temp_var\": \"trig_term\",\n                    \"expression\": \"sin(a) * cos(b)\",\n                    \"description\": \"Calculate the trigonometric product\"\n                },\n                {\n                    \"temp_var\": \"result\",\n                    \"expression\": \"a + product_term + quotient_term + trig_term\",\n                    \"description\": \"Combine all calculated terms\"\n                }\n            ],\n            \"final_expression\": \"result\"\n        }\n    ]\n}\n\nImportant:\n- Only suggest breakups for expressions that genuinely need it for readability\n- Line numbers should be relative to the function (first line of function is line 1)\n- The breakup_steps should be in the correct order of evaluation\n- Use descriptive temporary variable names\n- The final_expression should be what replaces the original expression in the code",
  "user_prompt": "Analyze this C function and identify expressions that should be broken up into multiple lines with temporary variables for better readability.\n\nFunction: kernel\n\nPotential long expressions detected (1-indexed):\n  - Line 227: length=122, operators=2, expression=memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp)), LAUNCH_COERCE_STRUCT_SIZE_BYTES);\n  - Line 228: length=124, operators=2, expression=memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp2_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp2)), LAUNCH_COERCE_STRUCT_SIZE_BYTES);\n  - Line 235: length=146, operators=0, expression=kernel_dev(ni, nj, nk, alpha, beta, C, A, B, __FIXME__call, __FIXME__call1, GRID_DIM_Z, __FIXME__div, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0);\n\nLook through all the expressions in this function and decide which ones are too long or complex to be easily understood on a single line. Focus on expressions similar to the ones listed above. Consider:\n- Arithmetic expressions with multiple operations\n- Boolean conditions with many clauses\n- Function calls with complex arguments\n- Any expression that hurts code readability\n\nRespond with JSON only, suggesting breakups for expressions that truly need them. If no expressions need breaking up, return an empty breakups array with the function_name.\n\nFunction code (line numbers are relative to function start):\n```c\n   1: void kernel(uint32_t ni, uint32_t nj, uint32_t nk, double alpha, double beta, double* C, double* A, double* B) {\n   2:   struct __FIXME__l_struct_struct_OC_dim3 block;    /* Address-exposed local */\n   3:   struct __FIXME__l_struct_struct_OC_dim3 grid;    /* Address-exposed local */\n   4:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp;    /* Address-exposed local */\n   5:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp2;    /* Address-exposed local */\n   6:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp_2e_coerce;    /* Address-exposed local */\n   7:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp2_2e_coerce;    /* Address-exposed local */\n   8:   uint32_t __FIXME__div;\n   9:   int32_t __FIXME__call;\n  10:   int32_t __FIXME__call1;\n  11:   uint32_t i;\n  12:   uint32_t j;\n  13:   uint32_t k;\n  14:   uint32_t l;\n  15: \n  16:   __FIXME__div = (BLOCK_THREADS_TOTAL / BLOCK_DIM_Y);\n  17:   block.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__div;\n  18:   block.__FIXME__l_struct_struct_OC_dim3_field1 = BLOCK_DIM_Y;\n  19:   block.__FIXME__l_struct_struct_OC_dim3_field2 = BLOCK_DIM_Z;\n  20:   __FIXME__call = num_blocks(ni, block.__FIXME__l_struct_struct_OC_dim3_field0);\n  21:   __FIXME__call1 = num_blocks(nj, block.__FIXME__l_struct_struct_OC_dim3_field1);\n  22:   grid.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call;\n  23:   grid.__FIXME__l_struct_struct_OC_dim3_field1 = __FIXME__call1;\n  24:   grid.__FIXME__l_struct_struct_OC_dim3_field2 = GRID_DIM_Z;\n  25:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp)), ((uint8_t*)(&grid)), DIM3_STRUCT_SIZE_BYTES);\n  26:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp2)), ((uint8_t*)(&block)), DIM3_STRUCT_SIZE_BYTES);\n  27:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp)), LAUNCH_COERCE_STRUCT_SIZE_BYTES);\n  28:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp2_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp2)), LAUNCH_COERCE_STRUCT_SIZE_BYTES);\n  29: // INSERT COMMENT LOOP: kernel::header.0\n  30: #pragma omp parallel for collapse(2)\n  31: for(int32_t i = 0; i < __FIXME__call;   i = i + 1){\n  32: for(int32_t j = 0; j < __FIXME__call1;   j = j + 1){\n  33: for(int32_t k = 0; k < BLOCK_DIM_X;   k = k + 1){\n  34: for(int32_t l = 0; l < BLOCK_DIM_Y;   l = l + 1){\n  35: kernel_dev(ni, nj, nk, alpha, beta, C, A, B, __FIXME__call, __FIXME__call1, GRID_DIM_Z, __FIXME__div, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0);\n  36: }\n  37: }\n  38: }\n  39: }\n  40:   return;\n  41: }\n```"
}