{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initializes matrices for GEMM: fills A (ni x nk), B (nk x nj), and C (ni x nj) with predictable index-based values for testing"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Returns ceil(num / factor): the number of blocks of size 'factor' needed to cover 'num' items"
    },
    {
      "id": "unknown_FUNCTION_kernel_dev",
      "original": "// INSERT COMMENT FUNCTION: kernel_dev",
      "replacement": "// Device-style kernel where each thread computes one C[i,j] = beta*C[i,j] + alpha*sum_k A[i,k]*B[k,j] using its block/thread indices"
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Host wrapper that sets up grid/block dimensions and launches kernel_dev across a 2D grid to compute C = alpha*A*B + beta*C"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Prints the ni-by-nj matrix C to stderr using a fixed floating-point format"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Fill B (nk x nj) in row-major order with (i*j)/ni to create a reproducible input matrix"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Fill B (nk x nj) in row-major order with (i*j)/ni to create a reproducible input matrix"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Fill B (nk x nj) in row-major order with (i*j)/ni to create a reproducible input matrix"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel nested loops over all grid blocks (grid_dim_x by grid_dim_y) to process each block of the computation"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Iterate over all rows and columns of C and print each element in row-major order"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line args for dump flag and matrix sizes (ni, nj, nk), then allocate A (ni*nk doubles)"
    },
    {
      "id": "unknown_IFELSE_kernel_dev::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_dev::entry",
      "replacement": "// Bounds-check the thread's (i,j); if within [0,ni) x [0,nj), initialize dot = beta*C[i,j] and loop over k to accumulate the A\u00b7B product"
    }
  ]
}