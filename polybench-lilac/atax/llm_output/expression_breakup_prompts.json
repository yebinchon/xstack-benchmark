{
  "system_prompt": "You are an expert C programmer specializing in code refactoring and readability.\nYour task is to analyze a C function and identify expressions that would benefit from being broken up into multiple lines using temporary variables for better readability.\n\nConsider these principles when deciding which expressions to break up:\n- Expressions that are visually long or complex on a single line\n- Expressions with multiple operators or function calls\n- Expressions that mix different types of operations\n- Nested function calls or complex arithmetic\n- Boolean expressions with many conditions\n- Any expression that makes the code hard to understand at a glance\n\nFor each expression you decide should be broken up, suggest:\n1. The exact line number where the expression appears (relative to the function start)\n2. The original expression text\n3. How to break it up into smaller sub-expressions with temporary variables\n4. Appropriate names for temporary variables (following C naming conventions)\n5. The optimal order of operations to maintain correctness\n\nReturn your response as JSON with this structure:\n{\n    \"function_name\": \"function_name_here\",\n    \"breakups\": [\n        {\n            \"line_number\": 5,\n            \"original_expression\": \"a + b * c + d / e + sin(a) * cos(b)\",\n            \"breakup_steps\": [\n                {\n                    \"temp_var\": \"product_term\",\n                    \"expression\": \"b * c\",\n                    \"description\": \"Calculate the product of b and c\"\n                },\n                {\n                    \"temp_var\": \"quotient_term\",\n                    \"expression\": \"d / e\",\n                    \"description\": \"Calculate the quotient of d and e\"\n                },\n                {\n                    \"temp_var\": \"trig_term\",\n                    \"expression\": \"sin(a) * cos(b)\",\n                    \"description\": \"Calculate the trigonometric product\"\n                },\n                {\n                    \"temp_var\": \"result\",\n                    \"expression\": \"a + product_term + quotient_term + trig_term\",\n                    \"description\": \"Combine all calculated terms\"\n                }\n            ],\n            \"final_expression\": \"result\"\n        }\n    ]\n}\n\nImportant:\n- Only suggest breakups for expressions that genuinely need it for readability\n- Line numbers should be relative to the function (first line of function is line 1)\n- The breakup_steps should be in the correct order of evaluation\n- Use descriptive temporary variable names\n- The final_expression should be what replaces the original expression in the code",
  "user_prompt": "Analyze this C function and identify expressions that should be broken up into multiple lines with temporary variables for better readability.\n\nFunction: main\n\nPotential long expressions detected (1-indexed):\n  - Line 139: length=77, operators=4, expression=init_array(nx, ny, ((double*)A), ((double*)x), ((double*)tmp), ((double*)y));\n  - Line 153: length=142, operators=4, expression=kernel3(nx, ny, ((double*)A), ((double*)x), ((double*)y), ((double*)tmp), __FIXME__call42, 1, 1, THREADS_PER_BLOCK_X, 1, 1, i, 0, 0, j, 0, 0);\n  - Line 169: length=142, operators=4, expression=kernel4(nx, ny, ((double*)A), ((double*)x), ((double*)y), ((double*)tmp), __FIXME__call46, 1, 1, THREADS_PER_BLOCK_X, 1, 1, i, 0, 0, j, 0, 0);\n\nLook through all the expressions in this function and decide which ones are too long or complex to be easily understood on a single line. Focus on expressions similar to the ones listed above. Consider:\n- Arithmetic expressions with multiple operations\n- Boolean conditions with many clauses\n- Function calls with complex arguments\n- Any expression that hurts code readability\n\nRespond with JSON only, suggesting breakups for expressions that truly need them. If no expressions need breaking up, return an empty breakups array with the function_name.\n\nFunction code (line numbers are relative to function start):\n```c\n   1: int main(int argc, char ** argv) {\n   2:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp;    /* Address-exposed local */\n   3:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp43;    /* Address-exposed local */\n   4:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp_2e_coerce;    /* Address-exposed local */\n   5:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp43_2e_coerce;    /* Address-exposed local */\n   6:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp45;    /* Address-exposed local */\n   7:   struct __FIXME__l_struct_struct_OC_dim3 __FIXME__agg_2e_tmp47;    /* Address-exposed local */\n   8:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp45_2e_coerce;    /* Address-exposed local */\n   9:   struct __FIXME__l_unnamed_1 __FIXME__agg_2e_tmp47_2e_coerce;    /* Address-exposed local */\n  10:   int32_t nx;\n  11:   int32_t ny;\n  12:   int32_t dump_code;\n  13:   uint8_t* A;\n  14:   uint8_t* x;\n  15:   uint8_t* y;\n  16:   uint8_t* tmp;\n  17:   int32_t __FIXME__call42;\n  18:   uint32_t i;\n  19:   uint32_t j;\n  20:   int32_t __FIXME__call46;\n  21: \n  22:   nx = atoi(argv[ARG_IDX_NX]);\n  23:   ny = atoi(argv[ARG_IDX_NY]);\n  24:   dump_code = atoi(argv[ARG_IDX_DUMP_FLAG]);\n  25:   A = malloc(nx * ny * BYTES_PER_DOUBLE);\n  26:   x = malloc(ny * BYTES_PER_DOUBLE);\n  27:   y = malloc(ny * BYTES_PER_DOUBLE);\n  28:   tmp = malloc(nx * BYTES_PER_DOUBLE);\n  29: init_array(nx, ny, ((double*)A), ((double*)x), ((double*)tmp), ((double*)y));\n  30:   __FIXME__call42 = num_blocks(nx, THREADS_PER_BLOCK_X);\n  31:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call42;\n  32:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  33:   __FIXME__agg_2e_tmp.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  34:   __FIXME__agg_2e_tmp43.__FIXME__l_struct_struct_OC_dim3_field0 = THREADS_PER_BLOCK_X;\n  35:   __FIXME__agg_2e_tmp43.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  36:   __FIXME__agg_2e_tmp43.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  37:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp)), DIM3_STRUCT_SIZE_BYTES);\n  38:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp43_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp43)), DIM3_STRUCT_SIZE_BYTES);\n  39: // INSERT COMMENT LOOP: main::header.014\n  40: #pragma omp parallel for collapse(2)\n  41: for(int32_t i = 0; i < __FIXME__call42;   i = i + 1){\n  42: for(int32_t j = 0; j < THREADS_PER_BLOCK_X;   j = j + 1){\n  43: kernel3(nx, ny, ((double*)A), ((double*)x), ((double*)y), ((double*)tmp), __FIXME__call42, 1, 1, THREADS_PER_BLOCK_X, 1, 1, i, 0, 0, j, 0, 0);\n  44: }\n  45: }\n  46:   __FIXME__call46 = num_blocks(ny, THREADS_PER_BLOCK_X);\n  47:   __FIXME__agg_2e_tmp45.__FIXME__l_struct_struct_OC_dim3_field0 = __FIXME__call46;\n  48:   __FIXME__agg_2e_tmp45.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  49:   __FIXME__agg_2e_tmp45.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  50:   __FIXME__agg_2e_tmp47.__FIXME__l_struct_struct_OC_dim3_field0 = THREADS_PER_BLOCK_X;\n  51:   __FIXME__agg_2e_tmp47.__FIXME__l_struct_struct_OC_dim3_field1 = 1;\n  52:   __FIXME__agg_2e_tmp47.__FIXME__l_struct_struct_OC_dim3_field2 = 1;\n  53:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp45_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp45)), DIM3_STRUCT_SIZE_BYTES);\n  54:   memcpy(((uint8_t*)(&__FIXME__agg_2e_tmp47_2e_coerce)), ((uint8_t*)(&__FIXME__agg_2e_tmp47)), DIM3_STRUCT_SIZE_BYTES);\n  55: // INSERT COMMENT LOOP: main::header.0\n  56: #pragma omp parallel for collapse(2)\n  57: for(int32_t i = 0; i < __FIXME__call46;   i = i + 1){\n  58: for(int32_t j = 0; j < THREADS_PER_BLOCK_X;   j = j + 1){\n  59: kernel4(nx, ny, ((double*)A), ((double*)x), ((double*)y), ((double*)tmp), __FIXME__call46, 1, 1, THREADS_PER_BLOCK_X, 1, 1, i, 0, 0, j, 0, 0);\n  60: }\n  61: }\n  62: // INSERT COMMENT IFELSE: main::kcall.end51\n  63:   if (dump_code == 1) { // IFELSE MARKER: kcall.end51 IF\n  64: print_array(nx, ((double*)y));\n  65:   }\n  66: free(((uint8_t*)((double*)A)));\n  67: free(((uint8_t*)((double*)x)));\n  68: free(((uint8_t*)((double*)y)));\n  69: free(((uint8_t*)((double*)tmp)));\n  70:   return 0;\n  71: }\n```"
}