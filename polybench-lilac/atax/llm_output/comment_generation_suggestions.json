{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize test data: fill matrix A (nx-by-ny) and prepare vectors x, tmp, and y with deterministic values for subsequent kernels"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Compute ceil(num / factor) to get the number of blocks needed to cover 'num' items with block size 'factor'"
    },
    {
      "id": "unknown_FUNCTION_kernel3",
      "original": "// INSERT COMMENT FUNCTION: kernel3",
      "replacement": "// CUDA-like row kernel: for each row i < m, compute tmp[i] as the dot product of A[i, 0..n-1] with x using 1D grid/block indices"
    },
    {
      "id": "unknown_FUNCTION_kernel4",
      "original": "// INSERT COMMENT FUNCTION: kernel4",
      "replacement": "// CUDA-like column kernel: for each column j < n, compute y[j] = dot(A[0..m-1, j], tmp) (i.e., y = A^T * tmp) using 1D grid/block indices"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the nx elements of vector y in a fixed format, grouping outputs every PRINT_VALUES_PER_LINE values"
    },
    {
      "id": "unknown_LOOP_main",
      "original": "// INSERT COMMENT LOOP: main",
      "replacement": "// OpenMP-parallel nested loops over blocks and threads to emulate a 1D GPU launch for kernel4 (grid_dim_x_k4 \u00d7 THREADS_PER_BLOCK_X)"
    },
    {
      "id": "unknown_LOOP_main",
      "original": "// INSERT COMMENT LOOP: main",
      "replacement": "// OpenMP-parallel nested loops over blocks and threads to emulate a 1D GPU launch for kernel4 (grid_dim_x_k4 \u00d7 THREADS_PER_BLOCK_X)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over all i in [0, nx) and j in [0, ny) to set A[i*ny + j] = i*(j+1)/nx (deterministic initialization pattern)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over all i in [0, nx) and j in [0, ny) to set A[i*ny + j] = i*(j+1)/nx (deterministic initialization pattern)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over all i in [0, nx) and j in [0, ny) to set A[i*ny + j] = i*(j+1)/nx (deterministic initialization pattern)"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Walk through y and print each element; start a new output line every PRINT_VALUES_PER_LINE entries"
    },
    {
      "id": "unknown_IFELSE_main::kcall.end51",
      "original": "// INSERT COMMENT IFELSE: main::kcall.end51",
      "replacement": "// If dump_code is enabled, print the result vector y for verification; then proceed with memory cleanup"
    },
    {
      "id": "unknown_IFELSE_kernel3::entry",
      "original": "// INSERT COMMENT IFELSE: kernel3::entry",
      "replacement": "// Check that thread i maps to a valid row; if so, accumulate the dot product of row i of A with x to populate tmp[i]"
    },
    {
      "id": "unknown_IFELSE_kernel4::entry",
      "original": "// INSERT COMMENT IFELSE: kernel4::entry",
      "replacement": "// Check that thread j maps to a valid column; if so, accumulate y[j] as the dot product of column j of A with tmp"
    }
  ]
}