{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 62 potential parentheses to evaluate:\n\nLine 90: return r;\n  Potential parentheses to evaluate: (x)\nLine 115: struct cuda_dim3_packed block_dim_packed;    /* Address-exposed local */\n  Potential parentheses to evaluate: (X)\nLine 213: return;\n}\n// INSERT COMMENT FUNCTION: print_array\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 228: \n  Potential parentheses to evaluate: (noinline), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (uint32_t a, uint32_t b), (argv[ARG_IDX_N]), (argv[ARG_IDX_DUMP_CODE]), (double*), (double*), (double*), (n, THREADS_PER_BLOCK_X), (uint8_t*), (&grid_dim_packed), (uint8_t*), (&grid_dim), (uint8_t*), (&block_dim_packed), (uint8_t*), (&block_dim), (2), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (n), (double), (i), (double), (j), (double), (n), (double), (i), (double), (j), (double), (n), (uint32_t num, uint32_t factor), (print_double_format), (newline_string)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n/* Magic number constants */\n#define BYTES_PER_DOUBLE 8\n#define THREADS_PER_BLOCK_X 256\n#define DIM3_SIZE_BYTES 12\n#define PRINTF_FMT_STR_LEN 8\n#define NEWLINE_STR_LEN 2\n#define DEFAULT_ALPHA 43532\n#define DEFAULT_BETA 12313\n#define PRINT_ITEMS_PER_LINE 20\n#define ARG_IDX_N 2\n#define ARG_IDX_DUMP_CODE 1\n\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct cuda_dim3;\nstruct cuda_dim3_packed;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct array_1_uint8_t {\n  uint8_t array[1];\n};\nstruct array_20_uint8_t {\n  uint8_t array[20];\n};\nstruct cuda_dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct cuda_dim3_packed {\n  uint64_t xy;\n  uint32_t z;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nvoid kernel_y(uint32_t, double, double, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_double_format[PRINTF_FMT_STR_LEN] = { \"%0.2lf \" };\nuint8_t newline_string[NEWLINE_STR_LEN] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_urem_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  struct cuda_dim3 grid_dim;    /* Address-exposed local */\n  struct cuda_dim3 block_dim;    /* Address-exposed local */\n  struct cuda_dim3_packed grid_dim_packed;    /* Address-exposed local */\n  struct cuda_dim3_packed block_dim_packed;    /* Address-exposed local */\n  int32_t n;\n  int32_t dump_code;\n  uint8_t* A;\n  uint8_t* B;\n  uint8_t* tmp;\n  uint8_t* x;\n  uint8_t* y;\n  int32_t num_blocks_x;\n  uint32_t i;\n  uint32_t j;\n\n  n = atoi(argv[ARG_IDX_N]);\n  dump_code = atoi(argv[ARG_IDX_DUMP_CODE]);\n  A = malloc(n * n * BYTES_PER_DOUBLE);\n  B = malloc(n * n * BYTES_PER_DOUBLE);\n  tmp = malloc(n * BYTES_PER_DOUBLE);\n  x = malloc(n * BYTES_PER_DOUBLE);\n  y = malloc(n * BYTES_PER_DOUBLE);\ninit_array(n, ((double*)A), ((double*)B), ((double*)x));\n  num_blocks_x = num_blocks(n, THREADS_PER_BLOCK_X);\n  grid_dim.x = num_blocks_x;\n  grid_dim.y = 1;\n  grid_dim.z = 1;\n  block_dim.x = THREADS_PER_BLOCK_X;\n  block_dim.y = 1;\n  block_dim.z = 1;\n  memcpy(((uint8_t*)(&grid_dim_packed)), ((uint8_t*)(&grid_dim)), DIM3_SIZE_BYTES);\n  memcpy(((uint8_t*)(&block_dim_packed)), ((uint8_t*)(&block_dim)), DIM3_SIZE_BYTES);\n// INSERT COMMENT LOOP: main::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_x;   i = i + 1){\nfor(int32_t j = 0; j < THREADS_PER_BLOCK_X;   j = j + 1){\nkernel_y(n, DEFAULT_ALPHA, DEFAULT_BETA, ((double*)A), ((double*)B), ((double*)tmp), ((double*)x), ((double*)y), num_blocks_x, 1, 1, THREADS_PER_BLOCK_X, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n// INSERT COMMENT IFELSE: main::kcall.end\n  if (dump_code == 1) { // IFELSE MARKER: kcall.end IF\nprint_array(n, ((double*)y));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)B)));\nfree(((uint8_t*)((double*)tmp)));\nfree(((uint8_t*)((double*)x)));\nfree(((uint8_t*)((double*)y)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A, double* B, double* x) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  x[i] = ((double)(i) / (double)(n));\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n  B[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_y\nvoid kernel_y(uint32_t n, double alpha, double beta, double* A, double* B, double* tmp, double* x, double* y, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_y::entry\n  int block_offset = blockDim_x * blockIdx_x;\n  uint32_t thread_index = threadIdx_x;\n  int global_index = block_offset + thread_index;\n  int linear_index = global_index;\n  i = linear_index;\n  if (i < n) { // IFELSE MARKER: entry IF\n  tmp[i] = 0;\n  y[i] = 0;\nfor(int64_t j = 0; j < n;   j = j + 1){\n  int a_index = i * n + j;\n  double a_val = A[a_index];\n  double x_val_a = x[j];\n  double prod_a = a_val * x_val_a;\n  double tmp_acc = tmp[i];\n  double tmp_sum = tmp_acc + prod_a;\n  tmp[i] = tmp_sum;\n  int b_index = i * n + j;\n  double b_val = B[b_index];\n  double x_val_b = x[j];\n  double prod_b = b_val * x_val_b;\n  double y_acc = y[i];\n  double y_sum = y_acc + prod_b;\n  y[i] = y_sum;\n}\n  y[i] = ((alpha * tmp[i]) + (beta * y[i]));\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* y) {\n  int64_t i;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  fprintf(stderr, (print_double_format), y[i]);\n  if (i % PRINT_ITEMS_PER_LINE == 0) { // IFELSE MARKER: for.body IF\n  fprintf(stderr, (newline_string));\n  }\n}\n  return;\n}\n\n```"
}