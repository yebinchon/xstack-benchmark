{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 64 potential parentheses to evaluate:\n\nLine 218: if (i < n) { // IFELSE MARKER: entry IF\n  Potential parentheses to evaluate: (noinline)\nLine 250: fprintf(stderr, (fmt_newline));\n  }\n}\n  return;\n}\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 255: \n  Potential parentheses to evaluate: (uint32_t, uint32_t), (noinline, nothrow), (noinline), (uint8_t*), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (uint32_t a, uint32_t b), (argv[2]), (argv[1]), (double*), (double*), (double*), (n, 256), (uint8_t*), (&gridDimPacked), (uint8_t*), (&gridDim), (uint8_t*), (&blockDimPacked), (uint8_t*), (&blockDim), (2), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (n), (double), (i), (double), (j), (double), (n), (double), (i), (double), (j), (double), (n), (uint32_t num, uint32_t factor), (fmt_double_space), (fmt_newline)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct IOFileStruct;\nstruct dim3_t;\nstruct Dim3Packed;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array1_t {\n  uint8_t array[1];\n};\nstruct uint8_array20_t {\n  uint8_t array[20];\n};\nstruct IOFileStruct {\n  uint32_t file_flags;\n  uint8_t* read_buffer;\n  uint8_t* write_buffer;\n  uint8_t* read_ptr;\n  uint8_t* write_ptr;\n  uint8_t* buf_end;\n  uint8_t* buf_base;\n  uint8_t* buf_last;\n  uint8_t* buf_mark;\n  uint8_t* buf_save;\n  uint8_t* buf_free;\n  uint8_t* buf_alloc;\n  void* file_cookie;\n  struct IOFileStruct* next;\n  uint32_t mode;\n  uint32_t fd;\n  uint64_t file_pos;\n  uint16_t orientation;\n  uint8_t unget;\n  uint8_t unget_buf[1];\n  uint8_t* wide_buf_ptr;\n  uint64_t file_size;\n  void* lock;\n  void* mutex;\n  struct IOFileStruct* prev;\n  uint8_t* ext_buf;\n  uint64_t last_sync;\n  uint32_t reserved;\n  uint8_t padding20[20];\n};\nstruct dim3_t {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct Dim3Packed {\n  uint64_t batch0;\n  uint32_t batch1;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t cudaFree(uint8_t*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_y(uint32_t, double, double, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t fmt_double_space[8] = { \"%0.2lf \" };\nuint8_t fmt_newline[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_urem_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  struct dim3_t gridDim;    /* Address-exposed local */\n  struct dim3_t blockDim;    /* Address-exposed local */\n  struct Dim3Packed gridDimPacked;    /* Address-exposed local */\n  struct Dim3Packed blockDimPacked;    /* Address-exposed local */\n  int32_t n;\n  int32_t dump_code;\n  uint8_t* A;\n  uint8_t* B;\n  uint8_t* tmp;\n  uint8_t* x;\n  uint8_t* y;\n  int32_t call38_result;\n  int32_t numBlocks;\n  uint8_t* unused_ptr1;\n  uint8_t* unused_ptr2;\n  uint32_t i;\n  uint32_t j;\n  int32_t call57_result;\n\n  n = atoi(argv[2]);\n  dump_code = atoi(argv[1]);\n  A = malloc(n * n * 8);\n  B = malloc(n * n * 8);\n  tmp = malloc(n * 8);\n  x = malloc(n * 8);\n  y = malloc(n * 8);\ninit_array(n, ((double*)A), ((double*)B), ((double*)x));\n  numBlocks = num_blocks(n, 256);\n  gridDim.x = numBlocks;\n  gridDim.y = 1;\n  gridDim.z = 1;\n  blockDim.x = 256;\n  blockDim.y = 1;\n  blockDim.z = 1;\n  memcpy(((uint8_t*)(&gridDimPacked)), ((uint8_t*)(&gridDim)), 12);\n  memcpy(((uint8_t*)(&blockDimPacked)), ((uint8_t*)(&blockDim)), 12);\n// INSERT COMMENT LOOP: main::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < numBlocks;   i = i + 1){\nfor(int32_t j = 0; j < 256;   j = j + 1){\nkernel_y(n, 43532, 12313, ((double*)A), ((double*)B), ((double*)tmp), ((double*)x), ((double*)y), numBlocks, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n// INSERT COMMENT IFELSE: main::kcall.end\n  if (dump_code == 1) { // IFELSE MARKER: kcall.end IF\nprint_array(n, ((double*)y));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)B)));\nfree(((uint8_t*)((double*)tmp)));\nfree(((uint8_t*)((double*)x)));\nfree(((uint8_t*)((double*)y)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A, double* B, double* x) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  x[i] = ((double)(i) / (double)(n));\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n  B[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_y\nvoid kernel_y(uint32_t n, double alpha, double beta, double* A, double* B, double* tmp, double* x, double* y, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_y::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\n  tmp[i] = 0;\n  y[i] = 0;\nfor(int64_t j = 0; j < n;   j = j + 1){\n  __auto_type idx_ij = i * n + j;\n  __auto_type a_val = A[idx_ij];\n  __auto_type x_j = x[j];\n  __auto_type prod_a_x = a_val * x_j;\n  __auto_type tmp_sum = tmp[i] + prod_a_x;\n  tmp[i] = tmp_sum;\n  __auto_type idx_ij2 = i * n + j;\n  __auto_type b_val = B[idx_ij2];\n  __auto_type x_j2 = x[j];\n  __auto_type prod_b_x = b_val * x_j2;\n  __auto_type y_sum = y[i] + prod_b_x;\n  y[i] = y_sum;\n}\n  __auto_type alpha_tmp = alpha * tmp[i];\n  __auto_type beta_y = beta * y[i];\n  __auto_type final_y = alpha_tmp + beta_y;\n  y[i] = final_y;\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* y) {\n  int64_t i;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  fprintf(stderr, (fmt_double_space), y[i]);\n  if (i % 20 == 0) { // IFELSE MARKER: for.body IF\n  fprintf(stderr, (fmt_newline));\n  }\n}\n  return;\n}\n\n```"
}