{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize problem data of size n; populate vectors (e.g., x1, x2) with deterministic values used by subsequent GEMV kernels"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num/factor): number of blocks of size 'factor' required to cover 'num' elements"
    },
    {
      "id": "unknown_FUNCTION_kernel_x1",
      "original": "// INSERT COMMENT FUNCTION: kernel_x1",
      "replacement": "// CUDA-style kernel: for thread index i < n, accumulate x1[i] += dot(row i of A, y_1)"
    },
    {
      "id": "unknown_FUNCTION_kernel_x2",
      "original": "// INSERT COMMENT FUNCTION: kernel_x2",
      "replacement": "// CUDA-style kernel: for thread index i < n, accumulate x2[i] += dot(column i of A, y_2)"
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Host dispatcher: configure grid/block dimensions and run x1/x2 kernels over n\u00d7n matrix A and vectors"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the contents of result vectors x1 and x2 using the configured floating-point format"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// For each i in [0, n), initialize x1[i] = i/n and x2[i] = (i + X2_INIT_OFFSET)/n"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D sweep over block indices (256 \u00d7 numBlocks2) to execute work across the grid"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D sweep over block indices (256 \u00d7 numBlocks2) to execute work across the grid"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Iterate i from 0 to n-1 and emit x1[i] then x2[i] to stderr using double_format_str"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse dump flag from argv and allocate host memory for A, x1, x2, and y_1"
    },
    {
      "id": "unknown_IFELSE_kernel_x1::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_x1::entry",
      "replacement": "// Compute CUDA-like thread index i; if i < n, update x1[i] with sum_j A[i*n + j] * y_1[j] (row-wise dot product)"
    },
    {
      "id": "unknown_IFELSE_kernel_x2::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_x2::entry",
      "replacement": "// Compute CUDA-like thread index i; if i < n, update x2[i] with sum_j A[j*n + i] * y_2[j] (column-wise dot product)"
    }
  ]
}