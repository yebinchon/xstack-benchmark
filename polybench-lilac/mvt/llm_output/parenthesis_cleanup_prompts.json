{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 87 potential parentheses to evaluate:\n\nLine 230: // INSERT COMMENT FUNCTION: kernel\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 297: \n  Potential parentheses to evaluate: (noinline), (noinline, nothrow), (noinline), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (uint32_t a, uint32_t b), (argv[1]), (1800000000), (double*), (double*), (double*), (double*), (double*), (num_elements_init, x1_double_init, x2_double_init, y1_double_init, y2_double_init, A_double_init), (double*), (double*), (double*), (double*), (double*), (num_elements_kernel, x1_double_kernel, x2_double_kernel, y1_double_kernel, y2_double_kernel, A_double_kernel), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (n), (double), (i), (double), (n), (double), (i), (double), (n), (double), (i), (double), (n), (double), (i), (double), (j), (double), (n), (int16_t num, int16_t factor), (n, 256), (uint8_t*), (&dim_block256_coerce), (uint8_t*), (&dim_block256), (uint8_t*), (&dim_grid_coerce), (uint8_t*), (&dim_grid), (2), (n, x1, x2, y_1, y_2, A, 256, 1, 1, num_blocks_256, 1, 1, i, 0, 0, j, 0, 0), (n, 256), (uint8_t*), (&dim_block256_b_coerce), (uint8_t*), (&dim_block256_b), (uint8_t*), (&dim_grid_b_coerce), (uint8_t*), (&dim_grid_b), (2), (n, x1, x2, y_1, y_2, A, 256, 1, 1, num_blocks_256_2, 1, 1, i, 0, 0, j, 0, 0), (double_print_format), (double_print_format), (newline_string)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct IOFile;\nstruct Dim3;\nstruct Dim3Coerce;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array_1 {\n  uint8_t array[1];\n};\nstruct uint8_array_20 {\n  uint8_t array[20];\n};\nstruct IOFile {\n  uint32_t f0;\n  uint8_t* f1;\n  uint8_t* f2;\n  uint8_t* f3;\n  uint8_t* f4;\n  uint8_t* f5;\n  uint8_t* f6;\n  uint8_t* f7;\n  uint8_t* f8;\n  uint8_t* f9;\n  uint8_t* f10;\n  uint8_t* f11;\n  void* f12;\n  struct IOFile* f13;\n  uint32_t f14;\n  uint32_t f15;\n  uint64_t f16;\n  uint16_t f17;\n  uint8_t f18;\n  uint8_t f19[1];\n  uint8_t* f20;\n  uint64_t f21;\n  void* f22;\n  void* f23;\n  struct IOFile* f24;\n  uint8_t* f25;\n  uint64_t f26;\n  uint32_t f27;\n  uint8_t f28[20];\n};\nstruct Dim3 {\n  uint32_t batch;\n  uint32_t height;\n  uint32_t width;\n};\nstruct Dim3Coerce {\n  uint64_t batch;\n  uint32_t count;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint16_t num_blocks(int16_t, int16_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel(uint32_t, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid print_array(uint32_t, double*, double*) __ATTRIBUTELIST__((noinline));\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_x1(uint32_t, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_x2(uint32_t, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t double_print_format[7] = { \"%0.2lf\" };\nuint8_t newline_string[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_urem_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  uint8_t* A;\n  uint8_t* x1;\n  uint8_t* x2;\n  uint8_t* y_1;\n  uint8_t* y_2;\n  int32_t init_call_ret;\n  int32_t kernel_call_ret;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[1]);\n  A = malloc(1800000000);\n  x1 = malloc(8 * 15000);\n  x2 = malloc(8 * 15000);\n  y_1 = malloc(8 * 15000);\n  y_2 = malloc(8 * 15000);\n  __auto_type num_elements_init = 15000;\n  __auto_type x1_double_init = (double*)x1;\n  __auto_type x2_double_init = (double*)x2;\n  __auto_type y1_double_init = (double*)y_1;\n  __auto_type y2_double_init = (double*)y_2;\n  __auto_type A_double_init = (double*)A;\n  init_array(num_elements_init, x1_double_init, x2_double_init, y1_double_init, y2_double_init, A_double_init);\n;\n  __auto_type num_elements_kernel = 15000;\n  __auto_type x1_double_kernel = (double*)x1;\n  __auto_type x2_double_kernel = (double*)x2;\n  __auto_type y1_double_kernel = (double*)y_1;\n  __auto_type y2_double_kernel = (double*)y_2;\n  __auto_type A_double_kernel = (double*)A;\n  kernel(num_elements_kernel, x1_double_kernel, x2_double_kernel, y1_double_kernel, y2_double_kernel, A_double_kernel);\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(15000, ((double*)x1), ((double*)x2));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)x1)));\nfree(((uint8_t*)((double*)x2)));\nfree(((uint8_t*)((double*)y_1)));\nfree(((uint8_t*)((double*)y_2)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* x1, double* x2, double* y_1, double* y_2, double* A) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  x1[i] = ((double)(i) / (double)(n));\n  x2[i] = (((double)(i) + 1) / (double)(n));\n  y_1[i] = (((double)(i) + 3) / (double)(n));\n  y_2[i] = (((double)(i) + 4) / (double)(n));\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nint16_t num_blocks(int16_t num, int16_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_x1\nvoid kernel_x1(uint32_t n, double* x1, double* x2, double* y_1, double* y_2, double* A, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_x1::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\nfor(int64_t j = 0; j < n;   j = j + 1){\n  x1[i] = (x1[i] + (A[(i * n + j)] * y_1[j]));\n}\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_x2\nvoid kernel_x2(uint32_t n, double* x1, double* x2, double* y_1, double* y_2, double* A, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_x2::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\nfor(int64_t j = 0; j < n;   j = j + 1){\n  x2[i] = (x2[i] + (A[(j * n + i)] * y_2[j]));\n}\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t n, double* x1, double* x2, double* y_1, double* y_2, double* A) {\n  struct Dim3 dim_block256;    /* Address-exposed local */\n  struct Dim3 dim_grid;    /* Address-exposed local */\n  struct Dim3Coerce dim_block256_coerce;    /* Address-exposed local */\n  struct Dim3Coerce dim_grid_coerce;    /* Address-exposed local */\n  struct Dim3 dim_block256_b;    /* Address-exposed local */\n  struct Dim3 dim_grid_b;    /* Address-exposed local */\n  struct Dim3Coerce dim_block256_b_coerce;    /* Address-exposed local */\n  struct Dim3Coerce dim_grid_b_coerce;    /* Address-exposed local */\n  int32_t num_blocks_256;\n  uint8_t* tmp_bytes1;\n  uint8_t* tmp_bytes2;\n  uint32_t i;\n  uint32_t j;\n  int32_t num_blocks_256_2;\n  uint8_t* tmp_bytes3;\n  uint8_t* tmp_bytes4;\n\n  dim_block256.batch = 256;\n  dim_block256.height = 1;\n  dim_block256.width = 1;\n  num_blocks_256 = num_blocks(n, 256);\n  dim_grid.batch = num_blocks_256;\n  dim_grid.height = 1;\n  dim_grid.width = 1;\n  memcpy(((uint8_t*)(&dim_block256_coerce)), ((uint8_t*)(&dim_block256)), 12);\n  memcpy(((uint8_t*)(&dim_grid_coerce)), ((uint8_t*)(&dim_grid)), 12);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < 256;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_256;   j = j + 1){\nkernel_x1(n, x1, x2, y_1, y_2, A, 256, 1, 1, num_blocks_256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  dim_block256_b.batch = 256;\n  dim_block256_b.height = 1;\n  dim_block256_b.width = 1;\n  num_blocks_256_2 = num_blocks(n, 256);\n  dim_grid_b.batch = num_blocks_256_2;\n  dim_grid_b.height = 1;\n  dim_grid_b.width = 1;\n  memcpy(((uint8_t*)(&dim_block256_b_coerce)), ((uint8_t*)(&dim_block256_b)), 12);\n  memcpy(((uint8_t*)(&dim_grid_b_coerce)), ((uint8_t*)(&dim_grid_b)), 12);\n// INSERT COMMENT LOOP: kernel::header.010\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < 256;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_256_2;   j = j + 1){\nkernel_x2(n, x1, x2, y_1, y_2, A, 256, 1, 1, num_blocks_256_2, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* x1, double* x2) {\n  int64_t i;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  fprintf(stderr, (double_print_format), x1[i]);\n  fprintf(stderr, (double_print_format), x2[i]);\n  if (i % 20 == 0) { // IFELSE MARKER: for.body IF\n  fprintf(stderr, (newline_string));\n  }\n}\n  return;\n}\n\n```"
}