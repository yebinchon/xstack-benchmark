CBackend: iterating function 1759: llvm.dbg.declare
CBackend: iterating function 1759: llvm.nvvm.read.ptx.sreg.ntid.x
CBackend: iterating function 1759: llvm.nvvm.read.ptx.sreg.ctaid.x
CBackend: iterating function 1759: llvm.nvvm.read.ptx.sreg.tid.x
CBackend: iterating function 1759: cudaSetupArgument
CBackend: iterating function 1759: cudaLaunch
CBackend: iterating function 1759: _Z10num_blocksss
CBackend: printing function 1770_Z10num_blocksss
ANDREW: CBackend: runOnModule function: _Z10num_blocksss
=========LOOP PROFILES=========
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762

YEBIN: in Function _Z10num_blocksss
YEBIN: creating CBE Region with entry to entry
YEBIN: new topmost region
SUSAN: block is a linear region! entry
global: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
type: [7 x i8]
global: @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
type: [2 x i8]
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
========== IV MAP==========
currInst :  %conv = sext i16 %num to i32, !dbg !755
currInst :  %add = add nsw i32 %conv, %conv1, !dbg !757
currInst :  %sub = sub nsw i32 %add, 1, !dbg !758
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
currInst :  %conv3 = trunc i32 %div to i16, !dbg !761
currInst :  ret i16 %conv3, !dbg !762
currInst :  %conv1 = sext i16 %factor to i32, !dbg !756
currInst :  %add = add nsw i32 %conv, %conv1, !dbg !757
currInst :  %sub = sub nsw i32 %add, 1, !dbg !758
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
currInst :  %conv3 = trunc i32 %div to i16, !dbg !761
currInst :  ret i16 %conv3, !dbg !762
currInst :  %add = add nsw i32 %conv, %conv1, !dbg !757
currInst :  %sub = sub nsw i32 %add, 1, !dbg !758
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
SUSAN: add () to inst:   %add = add nsw i32 %conv, %conv1, !dbg !757
currInst :  %sub = sub nsw i32 %add, 1, !dbg !758
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
SUSAN: add () to inst:   %sub = sub nsw i32 %add, 1, !dbg !758
currInst :  %conv2 = sext i16 %factor to i32, !dbg !759
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
currInst :  %conv3 = trunc i32 %div to i16, !dbg !761
currInst :  ret i16 %conv3, !dbg !762
currInst :  %div = sdiv i32 %sub, %conv2, !dbg !760
currInst :  %conv3 = trunc i32 %div to i16, !dbg !761
currInst :  ret i16 %conv3, !dbg !762
currInst :  %conv3 = trunc i32 %div to i16, !dbg !761
currInst :  ret i16 %conv3, !dbg !762
SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

SUSAN: found argument 6346: i16 %num
CBackend: varname: num
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
SUSAN: found argument 6346: i16 %factor
CBackend: varname: factor
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
=========================_Z10num_blocksss: IR NAMING BEFORE=====================
i16 %num -> num
i16 %factor -> factor
SUSAN: inst:  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
SUSAN: inst:  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
SUSAN: inst:  %conv = sext i16 %num to i32, !dbg !755
SUSAN: inst:  %conv1 = sext i16 %factor to i32, !dbg !756
SUSAN: inst:  %add = add nsw i32 %conv, %conv1, !dbg !757
SUSAN: inst:  %sub = sub nsw i32 %add, 1, !dbg !758
SUSAN: inst:  %conv2 = sext i16 %factor to i32, !dbg !759
SUSAN: inst:  %div = sdiv i32 %sub, %conv2, !dbg !760
SUSAN: inst:  %conv3 = trunc i32 %div to i16, !dbg !761
SUSAN: inst:  ret i16 %conv3, !dbg !762
=========================_Z10num_blocksss: IR NAMING=====================
i16 %num -> num
i16 %factor -> factor
SUSAN: getting value name for: i16 %num
inst from IRNaming: i16 %num
original name : num
returning name: num
SUSAN: getting value name for: i16 %factor
inst from IRNaming: i16 %factor
original name : factor
returning name: factor
SUSAN: am I here 6807??
Linear Region with entering block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
CBackend: writeOperand 3595:   %conv3 = trunc i32 %div to i16, !dbg !761
SUSAN: visiting cast:   %conv3 = trunc i32 %div to i16, !dbg !761
CBackend: writeOperand 3595:   %div = sdiv i32 %sub, %conv2, !dbg !760
CBackend: writeOperand 3595:   %sub = sub nsw i32 %add, 1, !dbg !758
CBackend: writeOperand 3595:   %add = add nsw i32 %conv, %conv1, !dbg !757
CBackend: writeOperand 3595:   %conv = sext i16 %num to i32, !dbg !755
SUSAN: visiting cast:   %conv = sext i16 %num to i32, !dbg !755
CBackend: writeOperand 3595: i16 %num
SUSAN: getting value name for: i16 %num
inst from IRNaming: i16 %num
original name : num
returning name: num
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv1 = sext i16 %factor to i32, !dbg !756
SUSAN: visiting cast:   %conv1 = sext i16 %factor to i32, !dbg !756
CBackend: writeOperand 3595: i16 %factor
SUSAN: getting value name for: i16 %factor
inst from IRNaming: i16 %factor
original name : factor
returning name: factor
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv2 = sext i16 %factor to i32, !dbg !759
SUSAN: visiting cast:   %conv2 = sext i16 %factor to i32, !dbg !759
CBackend: writeOperand 3595: i16 %factor
SUSAN: getting value name for: i16 %factor
inst from IRNaming: i16 %factor
original name : factor
returning name: factor
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: iterating function 1759: _Z6kerneliPdS_S_S_S_
CBackend: printing function 1770_Z6kerneliPdS_S_S_S_
ANDREW: CBackend: runOnModule function: _Z6kerneliPdS_S_S_S_
CBackend: here? 1175
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
none omp loop ub: i32 256
CBackend: here? 1175
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
none omp loop ub: i32 256
CBackend: here? 1175
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
none omp loop ub:   %conv10 = sext i16 %call9 to i32, !dbg !767
CBackend: here? 1175
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
none omp loop ub:   %conv3 = sext i16 %call to i32, !dbg !762
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

isomp: 0
Loop: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

isomp: 0
Loop: Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

isomp: 0
Loop: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

isomp: 0
SUSAN: opnd0  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: opnd1i32 256
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: opnd0  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: opnd1  %conv3 = sext i16 %call to i32, !dbg !762
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: opnd0  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: opnd1i32 256
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: opnd0  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: opnd1  %conv10 = sext i16 %call9 to i32, !dbg !767
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: BB:
entry:
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp1 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  %agg.tmp5 = alloca %struct.dim3, align 4
  %agg.tmp7 = alloca %struct.dim3, align 4
  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !751, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x1, metadata !753, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x2, metadata !754, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_1, metadata !755, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_2, metadata !756, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %A, metadata !757, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata i16 256, metadata !758, metadata !DIExpression()), !dbg !752
  %conv = sext i16 256 to i32, !dbg !760
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %conv, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %conv2 = trunc i32 %n to i16, !dbg !761
  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
  %conv3 = sext i16 %call to i32, !dbg !762
  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
  store i32 %conv3, i32* %dim3gep.01
  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
  store i32 1, i32* %dim3gep.12
  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
  store i32 1, i32* %dim3gep.23
  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !763
  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !763
  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
  br label %header.0

SUSAN: BB:
header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !764

SUSAN: BB:
header.1.preheader:                               ; preds = %header.0
  br label %header.1

SUSAN: BB:
header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !764

SUSAN: BB:
latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add i32 %indvar.1, 1
  br label %header.1

SUSAN: BB:
latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
  br label %header.0

SUSAN: BB:
kcall.configok:                                   ; preds = %header.1
  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

SUSAN: BB:
kcall.end:                                        ; preds = %header.0
  %conv6 = sext i16 256 to i32, !dbg !765
  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
  store i32 %conv6, i32* %dim3gep.04
  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
  store i32 1, i32* %dim3gep.15
  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
  store i32 1, i32* %dim3gep.26
  %conv8 = trunc i32 %n to i16, !dbg !766
  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
  %conv10 = sext i16 %call9 to i32, !dbg !767
  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
  store i32 %conv10, i32* %dim3gep.07
  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
  store i32 1, i32* %dim3gep.18
  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
  store i32 1, i32* %dim3gep.29
  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !768
  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !768
  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !768
  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !768
  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
  br label %header.010

SUSAN: BB:
header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !764

SUSAN: BB:
header.111.preheader:                             ; preds = %header.010
  br label %header.111

SUSAN: BB:
header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !764

SUSAN: BB:
latch.112:                                        ; preds = %kcall.configok13
  %indvar.next.116 = add i32 %indvar.114, 1
  br label %header.111

SUSAN: BB:
latch.013:                                        ; preds = %header.111
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
  br label %header.010

SUSAN: BB:
kcall.configok13:                                 ; preds = %header.111
  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
  br label %latch.112

SUSAN: BB:
kcall.end14:                                      ; preds = %header.010
  ret void, !dbg !769

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN exitBB: 
header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !764

SUSAN: trying to get exit for loop: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN exitBB: 
header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !764

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN exitBB: 
header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !764

SUSAN: trying to get exit for loop: Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN exitBB: 
header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !764

YEBIN: in Function _Z6kerneliPdS_S_S_S_
YEBIN: creating CBE Region with entry to kcall.end14
YEBIN: new topmost region
SUSAN: block is a linear region! entry
CBERegion: including entry in a linear region
SUSAN: nextRegionEntryBB header.0
YEBIN: in Function _Z6kerneliPdS_S_S_S_
YEBIN: creating CBE Region with header.0 to kcall.end14
YEBIN: new topmost region
CBackend: entryBB is a loop: header.0
SUSAN: block is a loop region! header.0

creating loop region for entryBB: header.0
YEBIN For Loop _Z6kerneliPdS_S_S_S_::header.0
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
YEBIN CBERegion: startBB 393: _Z6kerneliPdS_S_S_S_::header.1.preheader
YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.0
CBackend: entryBB is a loop: header.1.preheader
but not a header!
SUSAN: block is a linear region! header.1.preheader
CBERegion: including header.1.preheader in a linear region
SUSAN: nextRegionEntryBB header.1for region: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.0
CBackend: entryBB is a loop: header.1
SUSAN: block is a loop region! header.1

creating loop region for entryBB: header.1
YEBIN For Loop _Z6kerneliPdS_S_S_S_::header.1
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
YEBIN CBERegion: startBB 393: _Z6kerneliPdS_S_S_S_::kcall.configok
YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.1
CBackend: entryBB is a loop: kcall.configok
but not a header!
SUSAN: block is a linear region! kcall.configok
CBERegion: including kcall.configok in a linear region
SUSAN: nextRegionEntryBB latch.1for region: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: nextRegionEntryBB latch.0for region: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: nextRegionEntryBB kcall.end
YEBIN: in Function _Z6kerneliPdS_S_S_S_
YEBIN: creating CBE Region with kcall.end to kcall.end14
YEBIN: new topmost region
SUSAN: block is a linear region! kcall.end
CBERegion: including kcall.end in a linear region
SUSAN: nextRegionEntryBB header.010
YEBIN: in Function _Z6kerneliPdS_S_S_S_
YEBIN: creating CBE Region with header.010 to kcall.end14
YEBIN: new topmost region
CBackend: entryBB is a loop: header.010
SUSAN: block is a loop region! header.010

creating loop region for entryBB: header.010
YEBIN For Loop _Z6kerneliPdS_S_S_S_::header.010
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
YEBIN CBERegion: startBB 393: _Z6kerneliPdS_S_S_S_::header.111.preheader
YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.010
CBackend: entryBB is a loop: header.111.preheader
but not a header!
SUSAN: block is a linear region! header.111.preheader
CBERegion: including header.111.preheader in a linear region
SUSAN: nextRegionEntryBB header.111for region: Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.010
CBackend: entryBB is a loop: header.111
SUSAN: block is a loop region! header.111

creating loop region for entryBB: header.111
YEBIN For Loop _Z6kerneliPdS_S_S_S_::header.111
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
YEBIN CBERegion: startBB 393: _Z6kerneliPdS_S_S_S_::kcall.configok13
YEBIN: new region in loop _Z6kerneliPdS_S_S_S_::header.111
CBackend: entryBB is a loop: kcall.configok13
but not a header!
SUSAN: block is a linear region! kcall.configok13
CBERegion: including kcall.configok13 in a linear region
SUSAN: nextRegionEntryBB latch.112for region: Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN: nextRegionEntryBB latch.013for region: Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN: nextRegionEntryBB kcall.end14
YEBIN: in Function _Z6kerneliPdS_S_S_S_
YEBIN: creating CBE Region with kcall.end14 to kcall.end14
YEBIN: new topmost region
SUSAN: block is a linear region! kcall.end14
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
SUSAN: CI at 1400:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: CI at 1400:   %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
SUSAN: CI at 1400:   %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
SUSAN: CI at 1400:   call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
SUSAN: CI at 1400:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: CI at 1400:   %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
SUSAN: CI at 1400:   %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
SUSAN: CI at 1400:   call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN: found LP for L:Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: found LP for L:Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

SUSAN: found LP for L:Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

currInst :  %agg.tmp.coerce = alloca { i64, i32 }, align 4
currInst :  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
currInst :  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
currInst :  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
currInst :  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
currInst :  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
currInst :  %conv = sext i16 256 to i32, !dbg !760
currInst :  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
currInst :  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
currInst :  store i32 %conv, i32* %dim3gep.0
currInst :  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.1
currInst :  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.2
currInst :  %conv2 = trunc i32 %n to i16, !dbg !761
currInst :  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
currInst :  %conv3 = sext i16 %call to i32, !dbg !762
currInst :  %exitcond21 = icmp ne i32 %indvar.1, %conv3
currInst :  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
currInst :  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
currInst :  store i32 %conv3, i32* %dim3gep.01
currInst :  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.12
currInst :  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.23
currInst :  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
currInst :  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
currInst :  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !763
currInst :  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
currInst :  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
currInst :  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
currInst :  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !763
currInst :  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
currInst :  %exitcond22 = icmp ne i32 %indvar.0, 256
currInst :  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !764
currInst :  %exitcond21 = icmp ne i32 %indvar.1, %conv3
currInst :  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !764
currInst :  %conv6 = sext i16 256 to i32, !dbg !765
currInst :  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
currInst :  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
currInst :  store i32 %conv6, i32* %dim3gep.04
currInst :  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.15
currInst :  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.26
currInst :  %conv8 = trunc i32 %n to i16, !dbg !766
currInst :  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
currInst :  %conv10 = sext i16 %call9 to i32, !dbg !767
currInst :  %exitcond = icmp ne i32 %indvar.114, %conv10
currInst :  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
currInst :  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
currInst :  store i32 %conv10, i32* %dim3gep.07
currInst :  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.18
currInst :  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.29
currInst :  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !768
currInst :  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
currInst :  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !768
currInst :  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
currInst :  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !768
currInst :  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
currInst :  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !768
currInst :  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
currInst :  %exitcond20 = icmp ne i32 %indvar.017, 256
currInst :  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !764
currInst :  %exitcond = icmp ne i32 %indvar.114, %conv10
currInst :  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !764
LP->LV 1694:   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
LP->L 1694: Loop at depth 1 containing: %header.010<header><exiting>,%header.111.preheader,%header.111,%latch.013<latch>,%kcall.configok13,%latch.112
    Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

nestlevel: i
LP->LV 1694:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
LP->L 1694: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

nestlevel: i
LP->LV 1694:   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
LP->L 1694: Loop at depth 2 containing: %header.111<header><exiting>,%kcall.configok13,%latch.112<latch>

nestlevel: j
LP->LV 1694:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
LP->L 1694: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

nestlevel: j
SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define dso_local void @_Z6kerneliPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #3 !dbg !763 {
entry:
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp1 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  %agg.tmp5 = alloca %struct.dim3, align 4
  %agg.tmp7 = alloca %struct.dim3, align 4
  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
  %conv = sext i16 256 to i32, !dbg !774
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %conv, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %conv2 = trunc i32 %n to i16, !dbg !775
  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !776
  %conv3 = sext i16 %call to i32, !dbg !776
  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
  store i32 %conv3, i32* %dim3gep.01
  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
  store i32 1, i32* %dim3gep.12
  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
  store i32 1, i32* %dim3gep.23
  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !777
  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !777
  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !777
  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !777
  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !777
  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !777
  br label %header.0

header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !778

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !778

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %conv6 = sext i16 256 to i32, !dbg !779
  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
  store i32 %conv6, i32* %dim3gep.04
  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
  store i32 1, i32* %dim3gep.15
  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
  store i32 1, i32* %dim3gep.26
  %conv8 = trunc i32 %n to i16, !dbg !780
  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !781
  %conv10 = sext i16 %call9 to i32, !dbg !781
  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
  store i32 %conv10, i32* %dim3gep.07
  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
  store i32 1, i32* %dim3gep.18
  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
  store i32 1, i32* %dim3gep.29
  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !782
  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !782
  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !782
  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !782
  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !782
  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !782
  br label %header.010

header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !778

header.111.preheader:                             ; preds = %header.010
  br label %header.111

header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !778

latch.112:                                        ; preds = %kcall.configok13
  %indvar.next.116 = add i32 %indvar.114, 1
  br label %header.111

latch.013:                                        ; preds = %header.111
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
  br label %header.010

kcall.configok13:                                 ; preds = %header.111
  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
  br label %latch.112

kcall.end14:                                      ; preds = %header.010
  ret void, !dbg !783
}

SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
SUSAN: found argument 6346: double* %x1
CBackend: varname: x1
  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
SUSAN: found argument 6346: double* %x2
CBackend: varname: x2
  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
SUSAN: found argument 6346: double* %y_1
CBackend: varname: y_1
  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
SUSAN: found argument 6346: double* %y_2
CBackend: varname: y_2
  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
SUSAN: found argument 6346: double* %A
CBackend: varname: A
  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: phi related name: i
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: phi related name: j
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: phi related name: i
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: phi related name: j
=========================_Z6kerneliPdS_S_S_S_: IR NAMING BEFORE=====================
  %indvar.next.116 = add i32 %indvar.114, 1 -> j
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1 -> i
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvar.next.1 = add i32 %indvar.1, 1 -> j
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1 -> i
SUSAN: inst:  %conv3 = sext i16 %call to i32, !dbg !762
SUSAN: inst:  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
SUSAN: inst:  store i32 %conv3, i32* %dim3gep.01
SUSAN: inst:  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
SUSAN: inst:  store i32 1, i32* %dim3gep.12
SUSAN: inst:  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
SUSAN: inst:  store i32 1, i32* %dim3gep.23
SUSAN: inst:  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
SUSAN: inst:  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !763
SUSAN: inst:  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
SUSAN: inst:  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !763
SUSAN: inst:  br label %header.0
SUSAN: inst:  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !764
SUSAN: inst:  br label %header.111
SUSAN: inst:  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  %exitcond = icmp ne i32 %indvar.114, %conv10
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !764
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  %indvar.next.116 = add i32 %indvar.114, 1
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  br label %header.111
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
i:  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  br label %header.010
i:  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  br label %latch.112
j:  %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: inst:  ret void, !dbg !769
SUSAN: inst:  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %agg.tmp = alloca %struct.dim3, align 4
SUSAN: inst:  %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: inst:  %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: inst:  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
SUSAN: inst:  %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: inst:  %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: inst:  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
SUSAN: inst:  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
SUSAN: inst:  call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
SUSAN: inst:  %conv = sext i16 256 to i32, !dbg !760
SUSAN: inst:  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
SUSAN: inst:  store i32 %conv, i32* %dim3gep.0
SUSAN: inst:  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
SUSAN: inst:  store i32 1, i32* %dim3gep.1
SUSAN: inst:  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
SUSAN: inst:  store i32 1, i32* %dim3gep.2
SUSAN: inst:  %conv2 = trunc i32 %n to i16, !dbg !761
SUSAN: inst:  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: inst:  %exitcond22 = icmp ne i32 %indvar.0, 256
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !764
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br label %header.1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %exitcond21 = icmp ne i32 %indvar.1, %conv3
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !764
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %indvar.next.1 = add i32 %indvar.1, 1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br label %header.1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br label %header.0
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br label %latch.1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %conv6 = sext i16 256 to i32, !dbg !765
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 %conv6, i32* %dim3gep.04
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 1, i32* %dim3gep.15
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 1, i32* %dim3gep.26
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %conv8 = trunc i32 %n to i16, !dbg !766
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %conv10 = sext i16 %call9 to i32, !dbg !767
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 %conv10, i32* %dim3gep.07
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 1, i32* %dim3gep.18
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  store i32 1, i32* %dim3gep.29
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  br label %header.010
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: inst:  %exitcond20 = icmp ne i32 %indvar.017, 256
SUSAN: inst:  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
SUSAN: inst:  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
SUSAN: inst:  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: inst:  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
i:  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
j:  %indvar.next.1 = add i32 %indvar.1, 1
=========================_Z6kerneliPdS_S_S_S_: IR NAMING=====================
  %indvar.next.116 = add i32 %indvar.114, 1 -> j
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1 -> i
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvar.next.1 = add i32 %indvar.1, 1 -> j
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1 -> i
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp1
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
SUSAN: getting value name for:   %agg.tmp1.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp1.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp1.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp1_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp5
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp7
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp5.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp5.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp5.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp5_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
SUSAN: getting value name for:   %agg.tmp7.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp7.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp7.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: __FIXME__agg_2e_tmp7_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
YEBIN: WE ARE HERE FOR   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: declaring varName 5298: __FIXME__call
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
SUSAN: declaring 3252:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: inst at 5950:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: declaring   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: printing type at 5930: i32
YEBIN: WE ARE HERE FOR   %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
SUSAN: getting value name for:   %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763
SUSAN: declaring varName 5298: __FIXME__1
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
YEBIN: WE ARE HERE FOR   %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
SUSAN: getting value name for:   %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763
SUSAN: declaring varName 5298: __FIXME__2
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
YEBIN: WE ARE HERE FOR   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
SUSAN: declaring 3252:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: reconstructed variable counter increment for iv:i
SUSAN: inst at 5950:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: declaring   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: printing type at 5937: i32
YEBIN: WE ARE HERE FOR   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: declaring varName 5298: j
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
i
SUSAN: declaring 3252:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: reconstructed variable counter increment for iv:j
SUSAN: inst at 5950:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: declaring   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: printing type at 5937: i32
YEBIN: WE ARE HERE FOR   %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: getting value name for:   %indvar.next.1 = add i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add i32 %indvar.1, 1
original name : j
returning name: j
SUSAN: declaring varName 5298: j
YEBIN: WE ARE HERE FOR   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
SUSAN: getting value name for:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
original name : i
returning name: i
SUSAN: declaring varName 5298: i
YEBIN: WE ARE HERE FOR   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: declaring varName 5298: __FIXME__call9
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
i
j
SUSAN: declaring 3252:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: inst at 5950:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: declaring   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: printing type at 5930: i32
YEBIN: WE ARE HERE FOR   %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
SUSAN: getting value name for:   %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768
SUSAN: declaring varName 5298: __FIXME__3
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
__FIXME__call9
i
j
YEBIN: WE ARE HERE FOR   %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
SUSAN: getting value name for:   %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768
SUSAN: declaring varName 5298: __FIXME__4
SUSAN: declared locals:
__FIXME__agg_2e_tmp
__FIXME__agg_2e_tmp1
__FIXME__agg_2e_tmp1_2e_coerce
__FIXME__agg_2e_tmp5
__FIXME__agg_2e_tmp5_2e_coerce
__FIXME__agg_2e_tmp7
__FIXME__agg_2e_tmp7_2e_coerce
__FIXME__agg_2e_tmp_2e_coerce
__FIXME__call
__FIXME__call9
i
j
YEBIN: WE ARE HERE FOR   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: declaring varName 5298: i
YEBIN: WE ARE HERE FOR   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: declaring varName 5298: j
YEBIN: WE ARE HERE FOR   %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: getting value name for:   %indvar.next.116 = add i32 %indvar.114, 1
inst from IRNaming:   %indvar.next.116 = add i32 %indvar.114, 1
original name : j
returning name: j
SUSAN: declaring varName 5298: j
YEBIN: WE ARE HERE FOR   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
SUSAN: getting value name for:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
inst from IRNaming:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: am I here 6807??
Linear Region with entering block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
SUSAN: printing instruction   store i32 %conv, i32* %dim3gep.0 at 6678
CBEBackend: printing store Inst:   store i32 %conv, i32* %dim3gep.0
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595:   %conv = sext i16 256 to i32, !dbg !760
SUSAN: visiting cast:   %conv = sext i16 256 to i32, !dbg !760
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.1 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.1
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.2 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.2
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762 at 6678
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
CBackend: writeOperand 3595: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv2 = trunc i32 %n to i16, !dbg !761
SUSAN: visiting cast:   %conv2 = trunc i32 %n to i16, !dbg !761
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   store i32 %conv3, i32* %dim3gep.01 at 6678
CBEBackend: printing store Inst:   store i32 %conv3, i32* %dim3gep.01
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595:   %conv3 = sext i16 %call to i32, !dbg !762
SUSAN: visiting cast:   %conv3 = sext i16 %call to i32, !dbg !762
CBackend: writeOperand 3595:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.12 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.12
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.23 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.23
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !763 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
SUSAN: visiting cast:   %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !763
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !763
SUSAN: visiting cast:   %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !763
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !763 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
SUSAN: visiting cast:   %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !763
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp1.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp1.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !763
SUSAN: visiting cast:   %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !763
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp1 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp1 = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %header.0
Loop Region with entering block: header.0
SUSAN: condrelatedinst:  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: condrelatedinst:  %exitcond22 = icmp ne i32 %indvar.0, 256
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: declaring 3252:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: reconstructed variable counter increment for iv:i
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: declaring 3252:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
SUSAN: getting value name for:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: header.1.preheader
SUSAN: printing bb:header.1.preheader
CBEBackend: printing bb 7082 header.1.preheader
printing unconditional branch   br label %header.1
Loop Region with entering block: header.1
SUSAN: condrelatedinst:  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: condrelatedinst:  %exitcond21 = icmp ne i32 %indvar.1, %conv3
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: declaring 3252:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: reconstructed variable counter increment for iv:j
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: visiting cast:   %conv3 = sext i16 %call to i32, !dbg !762
CBackend: writeOperand 3595:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: getting value name for:   %indvar.next.1 = add i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add i32 %indvar.1, 1
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvar.next.1 = add i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add i32 %indvar.1, 1
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: kcall.configok
SUSAN: printing bb:kcall.configok
CBEBackend: printing bb 7082 kcall.configok
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: printing instruction   call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0) at 6678
CBackend: writeOperand 3595: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !963
  %add = add i32 %mul, %threadIdx.x, !dbg !964
  call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
  %cmp = icmp slt i32 %add, %n, !dbg !966
  br i1 %cmp, label %if.then, label %if.end, !dbg !968

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
  %0 = sext i32 %n to i64, !dbg !970
  br label %for.cond, !dbg !970

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !973
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !974
  br i1 %cmp3, label %for.body, label %for.end, !dbg !976

for.body:                                         ; preds = %for.cond
  %mul4 = mul nsw i32 %add, %n, !dbg !977
  %1 = sext i32 %mul4 to i64, !dbg !978
  %2 = add nsw i64 %1, %indvars.iv, !dbg !978
  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !979
  %3 = load double, double* %arrayidx, align 8, !dbg !979
  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !980
  %4 = load double, double* %arrayidx7, align 8, !dbg !980
  %mul8 = fmul contract double %3, %4, !dbg !981
  %idxprom9 = sext i32 %add to i64, !dbg !982
  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !982
  %5 = load double, double* %arrayidx10, align 8, !dbg !983
  %add11 = fadd contract double %5, %mul8, !dbg !983
  store double %add11, double* %arrayidx10, align 8, !dbg !983
  br label %for.inc, !dbg !982

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !984
  call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
  br label %for.cond, !dbg !985, !llvm.loop !986

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !988

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !989
}

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !963
  %add = add i32 %mul, %threadIdx.x, !dbg !964
  call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
  %cmp = icmp slt i32 %add, %n, !dbg !966
  br i1 %cmp, label %if.then, label %if.end, !dbg !968

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
  %0 = sext i32 %n to i64, !dbg !970
  br label %for.cond, !dbg !970

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !973
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !974
  br i1 %cmp3, label %for.body, label %for.end, !dbg !976

for.body:                                         ; preds = %for.cond
  %mul4 = mul nsw i32 %add, %n, !dbg !977
  %1 = sext i32 %mul4 to i64, !dbg !978
  %2 = add nsw i64 %1, %indvars.iv, !dbg !978
  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !979
  %3 = load double, double* %arrayidx, align 8, !dbg !979
  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !980
  %4 = load double, double* %arrayidx7, align 8, !dbg !980
  %mul8 = fmul contract double %3, %4, !dbg !981
  %idxprom9 = sext i32 %add to i64, !dbg !982
  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !982
  %5 = load double, double* %arrayidx10, align 8, !dbg !983
  %add11 = fadd contract double %5, %mul8, !dbg !983
  store double %add11, double* %arrayidx10, align 8, !dbg !983
  br label %for.inc, !dbg !982

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !984
  call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
  br label %for.cond, !dbg !985, !llvm.loop !986

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !988

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !989
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %y_1
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %y_2
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %A
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv = sext i16 256 to i32, !dbg !760
SUSAN: visiting cast:   %conv = sext i16 256 to i32, !dbg !760
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv3 = sext i16 %call to i32, !dbg !762
SUSAN: visiting cast:   %conv3 = sext i16 %call to i32, !dbg !762
CBackend: writeOperand 3595:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
SUSAN: getting value name for:   %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !762
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %latch.1
CBERegion: printing latchBB latch.1
CBERegion: I 316:   %indvar.next.1 = add i32 %indvar.1, 1
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBERegion: I 316:   br label %header.1
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBERegion: printing latchBB latch.0
CBERegion: I 316:   %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
CBERegion: I 316:   br label %header.0
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
Linear Region with entering block: kcall.end
SUSAN: printing bb:kcall.end
CBEBackend: printing bb 7082 kcall.end
SUSAN: printing instruction   store i32 %conv6, i32* %dim3gep.04 at 6678
CBEBackend: printing store Inst:   store i32 %conv6, i32* %dim3gep.04
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595:   %conv6 = sext i16 256 to i32, !dbg !765
SUSAN: visiting cast:   %conv6 = sext i16 256 to i32, !dbg !765
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.15 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.15
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.26 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.26
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767 at 6678
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
CBackend: writeOperand 3595: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv8 = trunc i32 %n to i16, !dbg !766
SUSAN: visiting cast:   %conv8 = trunc i32 %n to i16, !dbg !766
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   store i32 %conv10, i32* %dim3gep.07 at 6678
CBEBackend: printing store Inst:   store i32 %conv10, i32* %dim3gep.07
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595:   %conv10 = sext i16 %call9 to i32, !dbg !767
SUSAN: visiting cast:   %conv10 = sext i16 %call9 to i32, !dbg !767
CBackend: writeOperand 3595:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.18 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.18
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.29 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.29
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !768 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !768
SUSAN: visiting cast:   %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !768
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp5.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp5.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !768
SUSAN: visiting cast:   %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !768
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp5 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp5 = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !768 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !768
SUSAN: visiting cast:   %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !768
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp7.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp7.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !768
SUSAN: visiting cast:   %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !768
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp7 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp7 = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %header.010
Loop Region with entering block: header.010
SUSAN: condrelatedinst:  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: condrelatedinst:  %exitcond20 = icmp ne i32 %indvar.017, 256
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: declaring 3252:   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: reconstructed variable counter increment for iv:i
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: declaring 3252:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
SUSAN: getting value name for:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
inst from IRNaming:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
inst from IRNaming:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: header.111.preheader
SUSAN: printing bb:header.111.preheader
CBEBackend: printing bb 7082 header.111.preheader
printing unconditional branch   br label %header.111
Loop Region with entering block: header.111
SUSAN: condrelatedinst:  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: condrelatedinst:  %exitcond = icmp ne i32 %indvar.114, %conv10
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: declaring 3252:   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: reconstructed variable counter increment for iv:j
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: visiting cast:   %conv10 = sext i16 %call9 to i32, !dbg !767
CBackend: writeOperand 3595:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: getting value name for:   %indvar.next.116 = add i32 %indvar.114, 1
inst from IRNaming:   %indvar.next.116 = add i32 %indvar.114, 1
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvar.next.116 = add i32 %indvar.114, 1
inst from IRNaming:   %indvar.next.116 = add i32 %indvar.114, 1
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: kcall.configok13
SUSAN: printing bb:kcall.configok13
CBEBackend: printing bb 7082 kcall.configok13
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: printing instruction   call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0) at 6678
CBackend: writeOperand 3595: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !998
  %add = add i32 %mul, %threadIdx.x, !dbg !999
  call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
  %cmp = icmp slt i32 %add, %n, !dbg !1001
  br i1 %cmp, label %if.then, label %if.end, !dbg !1003

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
  %0 = sext i32 %n to i64, !dbg !1005
  %1 = sext i32 %n to i64, !dbg !1005
  %2 = sext i32 %add to i64, !dbg !1005
  br label %for.cond, !dbg !1005

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !1008
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !1009
  br i1 %cmp3, label %for.body, label %for.end, !dbg !1011

for.body:                                         ; preds = %for.cond
  %3 = mul nsw i64 %indvars.iv, %1, !dbg !1012
  %4 = add nsw i64 %3, %2, !dbg !1013
  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !1014
  %5 = load double, double* %arrayidx, align 8, !dbg !1014
  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !1015
  %6 = load double, double* %arrayidx7, align 8, !dbg !1015
  %mul8 = fmul contract double %5, %6, !dbg !1016
  %idxprom9 = sext i32 %add to i64, !dbg !1017
  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !1017
  %7 = load double, double* %arrayidx10, align 8, !dbg !1018
  %add11 = fadd contract double %7, %mul8, !dbg !1018
  store double %add11, double* %arrayidx10, align 8, !dbg !1018
  br label %for.inc, !dbg !1017

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1019
  call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
  br label %for.cond, !dbg !1020, !llvm.loop !1021

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !1023

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !1024
}

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !998
  %add = add i32 %mul, %threadIdx.x, !dbg !999
  call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
  %cmp = icmp slt i32 %add, %n, !dbg !1001
  br i1 %cmp, label %if.then, label %if.end, !dbg !1003

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
  %0 = sext i32 %n to i64, !dbg !1005
  %1 = sext i32 %n to i64, !dbg !1005
  %2 = sext i32 %add to i64, !dbg !1005
  br label %for.cond, !dbg !1005

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !1008
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !1009
  br i1 %cmp3, label %for.body, label %for.end, !dbg !1011

for.body:                                         ; preds = %for.cond
  %3 = mul nsw i64 %indvars.iv, %1, !dbg !1012
  %4 = add nsw i64 %3, %2, !dbg !1013
  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !1014
  %5 = load double, double* %arrayidx, align 8, !dbg !1014
  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !1015
  %6 = load double, double* %arrayidx7, align 8, !dbg !1015
  %mul8 = fmul contract double %5, %6, !dbg !1016
  %idxprom9 = sext i32 %add to i64, !dbg !1017
  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !1017
  %7 = load double, double* %arrayidx10, align 8, !dbg !1018
  %add11 = fadd contract double %7, %mul8, !dbg !1018
  store double %add11, double* %arrayidx10, align 8, !dbg !1018
  br label %for.inc, !dbg !1017

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1019
  call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
  br label %for.cond, !dbg !1020, !llvm.loop !1021

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !1023

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !1024
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %y_1
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %y_2
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: double* %A
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv6 = sext i16 256 to i32, !dbg !765
SUSAN: visiting cast:   %conv6 = sext i16 256 to i32, !dbg !765
CBackend: writeOperand 3595: i16 256
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv10 = sext i16 %call9 to i32, !dbg !767
SUSAN: visiting cast:   %conv10 = sext i16 %call9 to i32, !dbg !767
CBackend: writeOperand 3595:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
SUSAN: getting value name for:   %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !767
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found in IV2Name map   %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
name:  i
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found in IV2Name map   %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
name:  j
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %latch.112
CBERegion: printing latchBB latch.112
CBERegion: I 316:   %indvar.next.116 = add i32 %indvar.114, 1
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
CBERegion: I 316:   br label %header.111
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
SUSAN: found IV 784  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
CBERegion: printing latchBB latch.013
CBERegion: I 316:   %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
CBERegion: I 316:   br label %header.010
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
SUSAN: found IV 784  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
Linear Region with entering block: kcall.end14
SUSAN: printing bb:kcall.end14
CBEBackend: printing bb 7082 kcall.end14
CBackend: iterating function 1759: llvm.memcpy.p0i8.p0i8.i64
CBackend: iterating function 1759: main
CBackend: printing function 1770main
ANDREW: CBackend: runOnModule function: main
=========LOOP PROFILES=========
SUSAN: opnd0  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: opnd1i32 1
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %argc, metadata !751, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata i8** %argv, metadata !753, metadata !DIExpression()), !dbg !752
  %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !754
  %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
  %call = call i32 @atoi(i8* %0) #10, !dbg !755
  call void @llvm.dbg.value(metadata i32 %call, metadata !756, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata i32 15000, metadata !757, metadata !DIExpression()), !dbg !752
  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
  %1 = bitcast i8* %call1 to double*, !dbg !760
  call void @llvm.dbg.value(metadata double* %1, metadata !761, metadata !DIExpression()), !dbg !752
  %conv = sext i32 15000 to i64, !dbg !762
  %mul = mul i64 8, %conv, !dbg !763, !tulip.target.datasize !764
  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
  %2 = bitcast i8* %call2 to double*, !dbg !769
  call void @llvm.dbg.value(metadata double* %2, metadata !770, metadata !DIExpression()), !dbg !752
  %conv3 = sext i32 15000 to i64, !dbg !771
  %mul4 = mul i64 8, %conv3, !dbg !772, !tulip.target.datasize !773
  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
  %3 = bitcast i8* %call5 to double*, !dbg !778
  call void @llvm.dbg.value(metadata double* %3, metadata !779, metadata !DIExpression()), !dbg !752
  %conv6 = sext i32 15000 to i64, !dbg !780
  %mul7 = mul i64 8, %conv6, !dbg !781, !tulip.target.datasize !782
  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
  %4 = bitcast i8* %call8 to double*, !dbg !785
  call void @llvm.dbg.value(metadata double* %4, metadata !786, metadata !DIExpression()), !dbg !752
  %conv9 = sext i32 15000 to i64, !dbg !787
  %mul10 = mul i64 8, %conv9, !dbg !788, !tulip.target.datasize !789
  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
  %5 = bitcast i8* %call11 to double*, !dbg !792
  call void @llvm.dbg.value(metadata double* %5, metadata !793, metadata !DIExpression()), !dbg !752
  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
  %6 = bitcast double* %1 to i8*, !dbg !795
  %7 = bitcast double* %1 to i8*, !dbg !796
  %mul28 = mul nsw i32 15000, 15000, !dbg !797
  %conv29 = sext i32 %mul28 to i64, !dbg !798
  %mul30 = mul i64 %conv29, 8, !dbg !799
  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !802
  %8 = bitcast double* %2 to i8*, !dbg !803
  %9 = bitcast double* %2 to i8*, !dbg !804
  %conv44 = sext i32 15000 to i64, !dbg !805
  %mul45 = mul i64 %conv44, 8, !dbg !806
  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
  %cmp = icmp eq i32 %call, 1, !dbg !808
  br i1 %cmp, label %if.then, label %if.end, !dbg !810

SUSAN: BB:
if.then:                                          ; preds = %entry
  call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !811
  br label %if.end, !dbg !811

SUSAN: BB:
if.end:                                           ; preds = %if.then, %entry
  %10 = bitcast double* %1 to i8*, !dbg !812
  call void @free(i8* %10) #11, !dbg !813
  %11 = bitcast double* %2 to i8*, !dbg !814
  call void @free(i8* %11) #11, !dbg !815
  %12 = bitcast double* %3 to i8*, !dbg !816
  call void @free(i8* %12) #11, !dbg !817
  %13 = bitcast double* %4 to i8*, !dbg !818
  call void @free(i8* %13) #11, !dbg !819
  %14 = bitcast double* %5 to i8*, !dbg !820
  call void @free(i8* %14) #11, !dbg !821
  ret i32 0, !dbg !822

YEBIN: in Function main
YEBIN: creating CBE Region with entry to if.end
YEBIN: new topmost region
SUSAN: block is an if-else region! entry
ANDREW: entryBB name:entry
SUSAN: marking both branches
YEBIN: new region in ifelse main::entry
SUSAN: block is a linear region! if.then
CBERegion: including if.then in a linear region
SUSAN: currbb 562: if.end
CBERegion: nextEntryBB 121: if.end
=================SUSAN: END OF marking region : entry==================
SUSAN: nextRegionEntryBB if.end
YEBIN: in Function main
YEBIN: creating CBE Region with if.end to if.end
YEBIN: new topmost region
SUSAN: block is a linear region! if.end
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %argc, metadata !787, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i8** %argv, metadata !789, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %call, metadata !792, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 15000, metadata !793, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: found malloc 1403:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %1, metadata !797, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: found malloc 1403:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %2, metadata !806, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: found malloc 1403:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %3, metadata !815, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: found malloc 1403:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %4, metadata !822, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: found malloc 1403:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %5, metadata !829, metadata !DIExpression()), !dbg !788
SUSAN: CI at 1400:   call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
SUSAN: CI at 1400:   %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
SUSAN: CI at 1400:   call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !802
SUSAN: CI at 1400:   %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
SUSAN: CI at 1400:   call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !811
SUSAN: CI at 1400:   call void @free(i8* %10) #11, !dbg !813
SUSAN: CI at 1400:   call void @free(i8* %11) #11, !dbg !815
SUSAN: CI at 1400:   call void @free(i8* %12) #11, !dbg !817
SUSAN: CI at 1400:   call void @free(i8* %13) #11, !dbg !819
SUSAN: CI at 1400:   call void @free(i8* %14) #11, !dbg !821
========== IV MAP==========
currInst :  %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !754
currInst :  %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
currInst :  %call = call i32 @atoi(i8* %0) #10, !dbg !755
currInst :  %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
currInst :  %call = call i32 @atoi(i8* %0) #10, !dbg !755
currInst :  %1 = bitcast i8* %call1 to double*, !dbg !760
currInst :  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
currInst :  %conv = sext i32 15000 to i64, !dbg !762
currInst :  %mul = mul i64 8, %conv, !dbg !763, !tulip.target.datasize !764
currInst :  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
currInst :  %mul = mul i64 8, %conv, !dbg !763, !tulip.target.datasize !764
currInst :  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
currInst :  %2 = bitcast i8* %call2 to double*, !dbg !769
currInst :  %9 = bitcast double* %2 to i8*, !dbg !804
currInst :  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !802
currInst :  %conv3 = sext i32 15000 to i64, !dbg !771
currInst :  %mul4 = mul i64 8, %conv3, !dbg !772, !tulip.target.datasize !773
currInst :  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
currInst :  %mul4 = mul i64 8, %conv3, !dbg !772, !tulip.target.datasize !773
currInst :  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
currInst :  %3 = bitcast i8* %call5 to double*, !dbg !778
currInst :  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !802
currInst :  %conv6 = sext i32 15000 to i64, !dbg !780
currInst :  %mul7 = mul i64 8, %conv6, !dbg !781, !tulip.target.datasize !782
currInst :  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
currInst :  %mul7 = mul i64 8, %conv6, !dbg !781, !tulip.target.datasize !782
currInst :  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
currInst :  %4 = bitcast i8* %call8 to double*, !dbg !785
currInst :  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
currInst :  %conv9 = sext i32 15000 to i64, !dbg !787
currInst :  %mul10 = mul i64 8, %conv9, !dbg !788, !tulip.target.datasize !789
currInst :  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
currInst :  %mul10 = mul i64 8, %conv9, !dbg !788, !tulip.target.datasize !789
currInst :  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
currInst :  %5 = bitcast i8* %call11 to double*, !dbg !792
currInst :  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
currInst :  %6 = bitcast double* %1 to i8*, !dbg !795
currInst :  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
currInst :  %7 = bitcast double* %1 to i8*, !dbg !796
currInst :  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
currInst :  %mul28 = mul nsw i32 15000, 15000, !dbg !797
currInst :  %conv29 = sext i32 %mul28 to i64, !dbg !798
currInst :  %mul30 = mul i64 %conv29, 8, !dbg !799
currInst :  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
currInst :  %conv29 = sext i32 %mul28 to i64, !dbg !798
currInst :  %mul30 = mul i64 %conv29, 8, !dbg !799
currInst :  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
currInst :  %mul30 = mul i64 %conv29, 8, !dbg !799
currInst :  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
currInst :  %8 = bitcast double* %2 to i8*, !dbg !803
currInst :  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
currInst :  %9 = bitcast double* %2 to i8*, !dbg !804
currInst :  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
currInst :  %conv44 = sext i32 15000 to i64, !dbg !805
currInst :  %mul45 = mul i64 %conv44, 8, !dbg !806
currInst :  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
currInst :  %mul45 = mul i64 %conv44, 8, !dbg !806
currInst :  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
currInst :  %cmp = icmp eq i32 %call, 1, !dbg !808
currInst :  br i1 %cmp, label %if.then, label %if.end, !dbg !810
currInst :  %10 = bitcast double* %1 to i8*, !dbg !812
currInst :  call void @free(i8* %10) #11, !dbg !813
currInst :  %11 = bitcast double* %2 to i8*, !dbg !814
currInst :  call void @free(i8* %11) #11, !dbg !815
currInst :  %12 = bitcast double* %3 to i8*, !dbg !816
currInst :  call void @free(i8* %12) #11, !dbg !817
currInst :  %13 = bitcast double* %4 to i8*, !dbg !818
currInst :  call void @free(i8* %13) #11, !dbg !819
currInst :  %14 = bitcast double* %5 to i8*, !dbg !820
currInst :  call void @free(i8* %14) #11, !dbg !821
SUSAN: found double mallocs! 
malloc:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
castInst:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: found double mallocs! 
malloc:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
castInst:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: found double mallocs! 
malloc:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
castInst:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: found double mallocs! 
malloc:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
castInst:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: found double mallocs! 
malloc:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
castInst:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: getting value name for: 
; Function Attrs: noinline norecurse uwtable
define dso_local i32 @main(i32 %argc, i8** %argv) #5 !dbg !784 {
entry:
  call void @llvm.dbg.value(metadata i32 %argc, metadata !787, metadata !DIExpression()), !dbg !788
  call void @llvm.dbg.value(metadata i8** %argv, metadata !789, metadata !DIExpression()), !dbg !788
  %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !790
  %0 = load i8*, i8** %arrayidx, align 8, !dbg !790
  %call = call i32 @atoi(i8* %0) #10, !dbg !791
  call void @llvm.dbg.value(metadata i32 %call, metadata !792, metadata !DIExpression()), !dbg !788
  call void @llvm.dbg.value(metadata i32 15000, metadata !793, metadata !DIExpression()), !dbg !788
  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !794, !tulip.target.mapdata.to !795
  %1 = bitcast i8* %call1 to double*, !dbg !796
  call void @llvm.dbg.value(metadata double* %1, metadata !797, metadata !DIExpression()), !dbg !788
  %conv = sext i32 15000 to i64, !dbg !798
  %mul = mul i64 8, %conv, !dbg !799, !tulip.target.datasize !800
  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !801, !tulip.target.mapdata.to !802, !tulip.target.mapdata.from !804
  %2 = bitcast i8* %call2 to double*, !dbg !805
  call void @llvm.dbg.value(metadata double* %2, metadata !806, metadata !DIExpression()), !dbg !788
  %conv3 = sext i32 15000 to i64, !dbg !807
  %mul4 = mul i64 8, %conv3, !dbg !808, !tulip.target.datasize !809
  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !810, !tulip.target.mapdata.to !811, !tulip.target.mapdata.from !813
  %3 = bitcast i8* %call5 to double*, !dbg !814
  call void @llvm.dbg.value(metadata double* %3, metadata !815, metadata !DIExpression()), !dbg !788
  %conv6 = sext i32 15000 to i64, !dbg !816
  %mul7 = mul i64 8, %conv6, !dbg !817, !tulip.target.datasize !818
  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !819, !tulip.target.mapdata.to !820
  %4 = bitcast i8* %call8 to double*, !dbg !821
  call void @llvm.dbg.value(metadata double* %4, metadata !822, metadata !DIExpression()), !dbg !788
  %conv9 = sext i32 15000 to i64, !dbg !823
  %mul10 = mul i64 8, %conv9, !dbg !824, !tulip.target.datasize !825
  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !826, !tulip.target.mapdata.to !827
  %5 = bitcast i8* %call11 to double*, !dbg !828
  call void @llvm.dbg.value(metadata double* %5, metadata !829, metadata !DIExpression()), !dbg !788
  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !830
  %6 = bitcast double* %1 to i8*, !dbg !831
  %7 = bitcast double* %1 to i8*, !dbg !832
  %mul28 = mul nsw i32 15000, 15000, !dbg !833
  %conv29 = sext i32 %mul28 to i64, !dbg !834
  %mul30 = mul i64 %conv29, 8, !dbg !835
  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !836, !tulip.target.start.of.map !778
  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !837
  %8 = bitcast double* %2 to i8*, !dbg !838
  %9 = bitcast double* %2 to i8*, !dbg !839
  %conv44 = sext i32 15000 to i64, !dbg !840
  %mul45 = mul i64 %conv44, 8, !dbg !841
  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !842, !tulip.target.end.of.map !778
  %cmp = icmp eq i32 %call, 1, !dbg !843
  br i1 %cmp, label %if.then, label %if.end, !dbg !845

if.then:                                          ; preds = %entry
  call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !846
  br label %if.end, !dbg !846

if.end:                                           ; preds = %if.then, %entry
  %10 = bitcast double* %1 to i8*, !dbg !847
  call void @free(i8* %10) #11, !dbg !848
  %11 = bitcast double* %2 to i8*, !dbg !849
  call void @free(i8* %11) #11, !dbg !850
  %12 = bitcast double* %3 to i8*, !dbg !851
  call void @free(i8* %12) #11, !dbg !852
  %13 = bitcast double* %4 to i8*, !dbg !853
  call void @free(i8* %13) #11, !dbg !854
  %14 = bitcast double* %5 to i8*, !dbg !855
  call void @free(i8* %14) #11, !dbg !856
  ret i32 0, !dbg !857
}

SUSAN: found argument 6346: i32 %argc
CBackend: varname: argc
  call void @llvm.dbg.value(metadata i32 %argc, metadata !787, metadata !DIExpression()), !dbg !788
SUSAN: found argument 6346: i8** %argv
CBackend: varname: argv
  call void @llvm.dbg.value(metadata i8** %argv, metadata !789, metadata !DIExpression()), !dbg !788
=========================main: IR NAMING BEFORE=====================
i32 %argc -> argc
i8** %argv -> argv
  %call = call i32 @atoi(i8* %0) #10, !dbg !755 -> dump_code
  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759 -> A
  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768 -> x1
  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777 -> x2
  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784 -> y_1
  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791 -> y_2
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %argc, metadata !787, metadata !DIExpression()), !dbg !788
SUSAN: inst:  call void @llvm.dbg.value(metadata i8** %argv, metadata !789, metadata !DIExpression()), !dbg !788
SUSAN: inst:  %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !754
SUSAN: inst:  %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
SUSAN: inst:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %call, metadata !792, metadata !DIExpression()), !dbg !788
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 15000, metadata !793, metadata !DIExpression()), !dbg !788
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  %1 = bitcast i8* %call1 to double*, !dbg !760
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %1, metadata !797, metadata !DIExpression()), !dbg !788
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  %conv = sext i32 15000 to i64, !dbg !762
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  %mul = mul i64 8, %conv, !dbg !763, !tulip.target.datasize !764
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: inst:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: inst:  %2 = bitcast i8* %call2 to double*, !dbg !769
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %2, metadata !806, metadata !DIExpression()), !dbg !788
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: inst:  %conv3 = sext i32 15000 to i64, !dbg !771
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: inst:  %mul4 = mul i64 8, %conv3, !dbg !772, !tulip.target.datasize !773
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: inst:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: inst:  %3 = bitcast i8* %call5 to double*, !dbg !778
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %3, metadata !815, metadata !DIExpression()), !dbg !788
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: inst:  %conv6 = sext i32 15000 to i64, !dbg !780
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: inst:  %mul7 = mul i64 8, %conv6, !dbg !781, !tulip.target.datasize !782
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: inst:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: inst:  %4 = bitcast i8* %call8 to double*, !dbg !785
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %4, metadata !822, metadata !DIExpression()), !dbg !788
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: inst:  %conv9 = sext i32 15000 to i64, !dbg !787
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: inst:  %mul10 = mul i64 8, %conv9, !dbg !788, !tulip.target.datasize !789
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: inst:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %5 = bitcast i8* %call11 to double*, !dbg !792
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %5, metadata !829, metadata !DIExpression()), !dbg !788
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !794
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %6 = bitcast double* %1 to i8*, !dbg !795
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %7 = bitcast double* %1 to i8*, !dbg !796
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %mul28 = mul nsw i32 15000, 15000, !dbg !797
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %conv29 = sext i32 %mul28 to i64, !dbg !798
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %mul30 = mul i64 %conv29, 8, !dbg !799
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !802
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %8 = bitcast double* %2 to i8*, !dbg !803
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %9 = bitcast double* %2 to i8*, !dbg !804
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %conv44 = sext i32 15000 to i64, !dbg !805
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %mul45 = mul i64 %conv44, 8, !dbg !806
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %cmp = icmp eq i32 %call, 1, !dbg !808
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  br i1 %cmp, label %if.then, label %if.end, !dbg !810
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !811
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  br label %if.end, !dbg !811
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %10 = bitcast double* %1 to i8*, !dbg !812
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @free(i8* %10) #11, !dbg !813
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %11 = bitcast double* %2 to i8*, !dbg !814
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @free(i8* %11) #11, !dbg !815
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %12 = bitcast double* %3 to i8*, !dbg !816
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @free(i8* %12) #11, !dbg !817
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %13 = bitcast double* %4 to i8*, !dbg !818
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @free(i8* %13) #11, !dbg !819
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  %14 = bitcast double* %5 to i8*, !dbg !820
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  call void @free(i8* %14) #11, !dbg !821
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: inst:  ret i32 0, !dbg !822
A:  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
dump_code:  %call = call i32 @atoi(i8* %0) #10, !dbg !755
x1:  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
x2:  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
y_1:  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
y_2:  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
=========================main: IR NAMING=====================
i32 %argc -> argc
i8** %argv -> argv
  %call = call i32 @atoi(i8* %0) #10, !dbg !755 -> dump_code
  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759 -> A
  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768 -> x1
  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777 -> x2
  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784 -> y_1
  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791 -> y_2
YEBIN: WE ARE HERE FOR   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: getting value name for:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
inst from IRNaming:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
original name : dump_code
returning name: dump_code
SUSAN: declaring varName 5298: dump_code
SUSAN: declared locals:
SUSAN: declaring 3252:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: getting value name for:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
inst from IRNaming:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
original name : dump_code
returning name: dump_code
SUSAN: declaring with reconstructed name 3286: dump_code
SUSAN: inst at 5950:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: declaring   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: printing type at 5937: i32
YEBIN: WE ARE HERE FOR   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
SUSAN: declaring varName 5298: A
SUSAN: declared locals:
dump_code
SUSAN: declaring 3252:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
SUSAN: declaring with reconstructed name 3286: A
SUSAN: inst at 5950:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: declaring   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: printing type at 5937: i8*
YEBIN: WE ARE HERE FOR   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
SUSAN: declaring varName 5298: x1
SUSAN: declared locals:
A
dump_code
SUSAN: declaring 3252:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
SUSAN: declaring with reconstructed name 3286: x1
SUSAN: inst at 5950:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: declaring   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: printing type at 5937: i8*
YEBIN: WE ARE HERE FOR   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
SUSAN: declaring varName 5298: x2
SUSAN: declared locals:
A
dump_code
x1
SUSAN: declaring 3252:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
SUSAN: declaring with reconstructed name 3286: x2
SUSAN: inst at 5950:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: declaring   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: printing type at 5937: i8*
YEBIN: WE ARE HERE FOR   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
SUSAN: declaring varName 5298: y_1
SUSAN: declared locals:
A
dump_code
x1
x2
SUSAN: declaring 3252:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
SUSAN: declaring with reconstructed name 3286: y_1
SUSAN: inst at 5950:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: declaring   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: printing type at 5937: i8*
YEBIN: WE ARE HERE FOR   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
SUSAN: declaring varName 5298: y_2
SUSAN: declared locals:
A
dump_code
x1
x2
y_1
SUSAN: declaring 3252:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
SUSAN: declaring with reconstructed name 3286: y_2
SUSAN: inst at 5950:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: declaring   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: printing type at 5937: i8*
YEBIN: WE ARE HERE FOR   %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
SUSAN: getting value name for:   %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !800, !tulip.target.start.of.map !801
SUSAN: declaring varName 5298: __FIXME__call31
SUSAN: declared locals:
A
dump_code
x1
x2
y_1
y_2
YEBIN: WE ARE HERE FOR   %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
SUSAN: getting value name for:   %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !807, !tulip.target.end.of.map !801
SUSAN: declaring varName 5298: __FIXME__call46
SUSAN: declared locals:
A
dump_code
x1
x2
y_1
y_2
SUSAN: am I here 6807??
IfElse Region with entering block: main::entry
thenSubRegions : 
Linear Region with entering block: if.then
if.then
SUSAN: declaring 3252:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: getting value name for:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
inst from IRNaming:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
original name : dump_code
returning name: dump_code
SUSAN: declaring with reconstructed name 3286: dump_code
SUSAN: getting value name for:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
inst from IRNaming:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
original name : dump_code
returning name: dump_code
CBackend: writeOperand 3595: 
; Function Attrs: nounwind readonly
declare dso_local i32 @atoi(i8*) #6

SUSAN: getting value name for: 
; Function Attrs: nounwind readonly
declare dso_local i32 @atoi(i8*) #6

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
SUSAN: loadInst:   %0 = load i8*, i8** %arrayidx, align 8, !dbg !754
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !754
SUSAN: dereferenceTimes = 2
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !754
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:i8** %argv
SUSAN: writing ptr 9994: i8** %argv
SUSAN: getting value name for: i8** %argv
inst from IRNaming: i8** %argv
original name : argv
returning name: argv
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
SUSAN: declaring with reconstructed name 3286: A
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1800000000
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
SUSAN: declaring with reconstructed name 3286: x1
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %mul = mul i64 8, %conv, !dbg !763, !tulip.target.datasize !764
CBackend: writeOperand 3595: i64 8
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv = sext i32 15000 to i64, !dbg !762
SUSAN: visiting cast:   %conv = sext i32 15000 to i64, !dbg !762
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
SUSAN: declaring with reconstructed name 3286: x2
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %mul4 = mul i64 8, %conv3, !dbg !772, !tulip.target.datasize !773
CBackend: writeOperand 3595: i64 8
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv3 = sext i32 15000 to i64, !dbg !771
SUSAN: visiting cast:   %conv3 = sext i32 15000 to i64, !dbg !771
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
SUSAN: declaring with reconstructed name 3286: y_1
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %mul7 = mul i64 8, %conv6, !dbg !781, !tulip.target.datasize !782
CBackend: writeOperand 3595: i64 8
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv6 = sext i32 15000 to i64, !dbg !780
SUSAN: visiting cast:   %conv6 = sext i32 15000 to i64, !dbg !780
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
SUSAN: declaring with reconstructed name 3286: y_2
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %mul10 = mul i64 8, %conv9, !dbg !788, !tulip.target.datasize !789
CBackend: writeOperand 3595: i64 8
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv9 = sext i32 15000 to i64, !dbg !787
SUSAN: visiting cast:   %conv9 = sext i32 15000 to i64, !dbg !787
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: 
; Function Attrs: noinline nounwind uwtable
define internal void @_ZL10init_arrayiPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #2 !dbg !858 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
  %0 = sext i32 %n to i64, !dbg !867
  %1 = sext i32 %n to i64, !dbg !867
  br label %for.cond, !dbg !867

for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !869
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !870
  br i1 %cmp, label %for.body, label %for.end32, !dbg !872

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv2 to i32, !dbg !873
  %conv = sitofp i32 %2 to double, !dbg !873
  %conv1 = sitofp i32 %n to double, !dbg !875
  %div = fdiv double %conv, %conv1, !dbg !876
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !877
  store double %div, double* %arrayidx, align 8, !dbg !878
  %3 = trunc i64 %indvars.iv2 to i32, !dbg !879
  %conv2 = sitofp i32 %3 to double, !dbg !879
  %add = fadd contract double %conv2, 1.000000e+00, !dbg !880
  %conv3 = sitofp i32 %n to double, !dbg !881
  %div4 = fdiv double %add, %conv3, !dbg !882
  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !883
  store double %div4, double* %arrayidx6, align 8, !dbg !884
  %4 = trunc i64 %indvars.iv2 to i32, !dbg !885
  %conv7 = sitofp i32 %4 to double, !dbg !885
  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !886
  %conv9 = sitofp i32 %n to double, !dbg !887
  %div10 = fdiv double %add8, %conv9, !dbg !888
  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !889
  store double %div10, double* %arrayidx12, align 8, !dbg !890
  %5 = trunc i64 %indvars.iv2 to i32, !dbg !891
  %conv13 = sitofp i32 %5 to double, !dbg !891
  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !892
  %conv15 = sitofp i32 %n to double, !dbg !893
  %div16 = fdiv double %add14, %conv15, !dbg !894
  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !895
  store double %div16, double* %arrayidx18, align 8, !dbg !896
  call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
  %wide.trip.count = zext i32 %n to i64, !dbg !898
  br label %for.cond19, !dbg !901

for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !902
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !898
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !903

for.body21:                                       ; preds = %for.cond19
  %6 = trunc i64 %indvars.iv2 to i32, !dbg !904
  %conv22 = sitofp i32 %6 to double, !dbg !904
  %7 = trunc i64 %indvars.iv to i32, !dbg !905
  %conv23 = sitofp i32 %7 to double, !dbg !905
  %mul = fmul contract double %conv22, %conv23, !dbg !906
  %conv24 = sitofp i32 %n to double, !dbg !907
  %div25 = fdiv double %mul, %conv24, !dbg !908
  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !909
  %9 = add nsw i64 %8, %indvars.iv, !dbg !910
  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !911
  store double %div25, double* %arrayidx29, align 8, !dbg !912
  br label %for.inc, !dbg !911

for.inc:                                          ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !913
  call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond19, !dbg !914, !llvm.loop !915

for.end:                                          ; preds = %for.cond19
  br label %for.inc30, !dbg !917

for.inc30:                                        ; preds = %for.end
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !918
  call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond, !dbg !919, !llvm.loop !920

for.end32:                                        ; preds = %for.cond
  ret void, !dbg !922
}

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal void @_ZL10init_arrayiPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #2 !dbg !858 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
  %0 = sext i32 %n to i64, !dbg !867
  %1 = sext i32 %n to i64, !dbg !867
  br label %for.cond, !dbg !867

for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !869
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !870
  br i1 %cmp, label %for.body, label %for.end32, !dbg !872

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv2 to i32, !dbg !873
  %conv = sitofp i32 %2 to double, !dbg !873
  %conv1 = sitofp i32 %n to double, !dbg !875
  %div = fdiv double %conv, %conv1, !dbg !876
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !877
  store double %div, double* %arrayidx, align 8, !dbg !878
  %3 = trunc i64 %indvars.iv2 to i32, !dbg !879
  %conv2 = sitofp i32 %3 to double, !dbg !879
  %add = fadd contract double %conv2, 1.000000e+00, !dbg !880
  %conv3 = sitofp i32 %n to double, !dbg !881
  %div4 = fdiv double %add, %conv3, !dbg !882
  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !883
  store double %div4, double* %arrayidx6, align 8, !dbg !884
  %4 = trunc i64 %indvars.iv2 to i32, !dbg !885
  %conv7 = sitofp i32 %4 to double, !dbg !885
  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !886
  %conv9 = sitofp i32 %n to double, !dbg !887
  %div10 = fdiv double %add8, %conv9, !dbg !888
  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !889
  store double %div10, double* %arrayidx12, align 8, !dbg !890
  %5 = trunc i64 %indvars.iv2 to i32, !dbg !891
  %conv13 = sitofp i32 %5 to double, !dbg !891
  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !892
  %conv15 = sitofp i32 %n to double, !dbg !893
  %div16 = fdiv double %add14, %conv15, !dbg !894
  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !895
  store double %div16, double* %arrayidx18, align 8, !dbg !896
  call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
  %wide.trip.count = zext i32 %n to i64, !dbg !898
  br label %for.cond19, !dbg !901

for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !902
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !898
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !903

for.body21:                                       ; preds = %for.cond19
  %6 = trunc i64 %indvars.iv2 to i32, !dbg !904
  %conv22 = sitofp i32 %6 to double, !dbg !904
  %7 = trunc i64 %indvars.iv to i32, !dbg !905
  %conv23 = sitofp i32 %7 to double, !dbg !905
  %mul = fmul contract double %conv22, %conv23, !dbg !906
  %conv24 = sitofp i32 %n to double, !dbg !907
  %div25 = fdiv double %mul, %conv24, !dbg !908
  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !909
  %9 = add nsw i64 %8, %indvars.iv, !dbg !910
  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !911
  store double %div25, double* %arrayidx29, align 8, !dbg !912
  br label %for.inc, !dbg !911

for.inc:                                          ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !913
  call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond19, !dbg !914, !llvm.loop !915

for.end:                                          ; preds = %for.cond19
  br label %for.inc30, !dbg !917

for.inc30:                                        ; preds = %for.end
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !918
  call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond, !dbg !919, !llvm.loop !920

for.end32:                                        ; preds = %for.cond
  ret void, !dbg !922
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: visiting cast:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: visiting cast:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: visiting cast:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: visiting cast:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: 
; Function Attrs: noinline uwtable
define dso_local void @_Z6kerneliPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #3 !dbg !763 {
entry:
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp1 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  %agg.tmp5 = alloca %struct.dim3, align 4
  %agg.tmp7 = alloca %struct.dim3, align 4
  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
  %conv = sext i16 256 to i32, !dbg !774
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %conv, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %conv2 = trunc i32 %n to i16, !dbg !775
  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !776
  %conv3 = sext i16 %call to i32, !dbg !776
  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
  store i32 %conv3, i32* %dim3gep.01
  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
  store i32 1, i32* %dim3gep.12
  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
  store i32 1, i32* %dim3gep.23
  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !777
  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !777
  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !777
  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !777
  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !777
  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !777
  br label %header.0

header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !778

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !778

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %conv6 = sext i16 256 to i32, !dbg !779
  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
  store i32 %conv6, i32* %dim3gep.04
  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
  store i32 1, i32* %dim3gep.15
  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
  store i32 1, i32* %dim3gep.26
  %conv8 = trunc i32 %n to i16, !dbg !780
  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !781
  %conv10 = sext i16 %call9 to i32, !dbg !781
  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
  store i32 %conv10, i32* %dim3gep.07
  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
  store i32 1, i32* %dim3gep.18
  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
  store i32 1, i32* %dim3gep.29
  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !782
  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !782
  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !782
  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !782
  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !782
  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !782
  br label %header.010

header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !778

header.111.preheader:                             ; preds = %header.010
  br label %header.111

header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !778

latch.112:                                        ; preds = %kcall.configok13
  %indvar.next.116 = add i32 %indvar.114, 1
  br label %header.111

latch.013:                                        ; preds = %header.111
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
  br label %header.010

kcall.configok13:                                 ; preds = %header.111
  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
  br label %latch.112

kcall.end14:                                      ; preds = %header.010
  ret void, !dbg !783
}

SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define dso_local void @_Z6kerneliPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #3 !dbg !763 {
entry:
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp1 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  %agg.tmp5 = alloca %struct.dim3, align 4
  %agg.tmp7 = alloca %struct.dim3, align 4
  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
  %conv = sext i16 256 to i32, !dbg !774
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %conv, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %conv2 = trunc i32 %n to i16, !dbg !775
  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !776
  %conv3 = sext i16 %call to i32, !dbg !776
  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
  store i32 %conv3, i32* %dim3gep.01
  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
  store i32 1, i32* %dim3gep.12
  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
  store i32 1, i32* %dim3gep.23
  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !777
  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !777
  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !777
  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !777
  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !777
  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !777
  br label %header.0

header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !778

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !778

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %conv6 = sext i16 256 to i32, !dbg !779
  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
  store i32 %conv6, i32* %dim3gep.04
  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
  store i32 1, i32* %dim3gep.15
  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
  store i32 1, i32* %dim3gep.26
  %conv8 = trunc i32 %n to i16, !dbg !780
  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !781
  %conv10 = sext i16 %call9 to i32, !dbg !781
  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
  store i32 %conv10, i32* %dim3gep.07
  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
  store i32 1, i32* %dim3gep.18
  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
  store i32 1, i32* %dim3gep.29
  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !782
  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !782
  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !782
  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !782
  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !782
  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !782
  br label %header.010

header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !778

header.111.preheader:                             ; preds = %header.010
  br label %header.111

header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !778

latch.112:                                        ; preds = %kcall.configok13
  %indvar.next.116 = add i32 %indvar.114, 1
  br label %header.111

latch.013:                                        ; preds = %header.111
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
  br label %header.010

kcall.configok13:                                 ; preds = %header.111
  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
  br label %latch.112

kcall.end14:                                      ; preds = %header.010
  ret void, !dbg !783
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: visiting cast:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: visiting cast:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: visiting cast:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: visiting cast:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %cmp = icmp eq i32 %call, 1, !dbg !808
CBackend: writeOperand 3595:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
SUSAN: getting value name for:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
inst from IRNaming:   %call = call i32 @atoi(i8* %0) #10, !dbg !755
original name : dump_code
returning name: dump_code
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
Linear Region with entering block: if.then
SUSAN: printing bb:if.then
CBEBackend: printing bb 7082 if.then
SUSAN: printing instruction   call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !811 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: noinline uwtable
define internal void @_ZL11print_arrayiPdS_(i32 %n, double* %x1, double* %x2) #3 !dbg !923 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
  %0 = sext i32 %n to i64, !dbg !931
  br label %for.cond, !dbg !931

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !933
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !934
  br i1 %cmp, label %for.body, label %for.end, !dbg !936

for.body:                                         ; preds = %for.cond
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !937
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !939
  %2 = load double, double* %arrayidx, align 8, !dbg !939
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !940
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !941
  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !942
  %4 = load double, double* %arrayidx2, align 8, !dbg !942
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !943
  %5 = trunc i64 %indvars.iv to i32
  %rem.urem = urem i32 %5, 20
  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !944
  br i1 %cmp4, label %if.then, label %if.end, !dbg !946

if.then:                                          ; preds = %for.body
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !947
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !948
  br label %if.end, !dbg !948

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc, !dbg !949

for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !950
  call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
  br label %for.cond, !dbg !951, !llvm.loop !952

for.end:                                          ; preds = %for.cond
  ret void, !dbg !954
}

SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define internal void @_ZL11print_arrayiPdS_(i32 %n, double* %x1, double* %x2) #3 !dbg !923 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
  %0 = sext i32 %n to i64, !dbg !931
  br label %for.cond, !dbg !931

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !933
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !934
  br i1 %cmp, label %for.body, label %for.end, !dbg !936

for.body:                                         ; preds = %for.cond
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !937
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !939
  %2 = load double, double* %arrayidx, align 8, !dbg !939
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !940
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !941
  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !942
  %4 = load double, double* %arrayidx2, align 8, !dbg !942
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !943
  %5 = trunc i64 %indvars.iv to i32
  %rem.urem = urem i32 %5, 20
  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !944
  br i1 %cmp4, label %if.then, label %if.end, !dbg !946

if.then:                                          ; preds = %for.body
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !947
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !948
  br label %if.end, !dbg !948

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc, !dbg !949

for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !950
  call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
  br label %for.cond, !dbg !951, !llvm.loop !952

for.end:                                          ; preds = %for.cond
  ret void, !dbg !954
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 15000
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: visiting cast:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: visiting cast:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %if.end, !dbg !811
Linear Region with entering block: if.end
SUSAN: printing bb:if.end
CBEBackend: printing bb 7082 if.end
SUSAN: printing instruction   call void @free(i8* %10) #11, !dbg !813 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %10 = bitcast double* %1 to i8*, !dbg !812
SUSAN: visiting cast:   %10 = bitcast double* %1 to i8*, !dbg !812
SUSAN: printing cast from: double* to i8*
CBackend: writeOperand 3595:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to double*, !dbg !760
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !758, !tulip.target.mapdata.to !759
original name : A
returning name: A
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %11) #11, !dbg !815 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %11 = bitcast double* %2 to i8*, !dbg !814
SUSAN: visiting cast:   %11 = bitcast double* %2 to i8*, !dbg !814
SUSAN: printing cast from: double* to i8*
CBackend: writeOperand 3595:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: visiting cast:   %2 = bitcast i8* %call2 to double*, !dbg !769
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !765, !tulip.target.mapdata.to !766, !tulip.target.mapdata.from !768
original name : x1
returning name: x1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %12) #11, !dbg !817 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %12 = bitcast double* %3 to i8*, !dbg !816
SUSAN: visiting cast:   %12 = bitcast double* %3 to i8*, !dbg !816
SUSAN: printing cast from: double* to i8*
CBackend: writeOperand 3595:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: visiting cast:   %3 = bitcast i8* %call5 to double*, !dbg !778
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
SUSAN: getting value name for:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
inst from IRNaming:   %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !774, !tulip.target.mapdata.to !775, !tulip.target.mapdata.from !777
original name : x2
returning name: x2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %13) #11, !dbg !819 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %13 = bitcast double* %4 to i8*, !dbg !818
SUSAN: visiting cast:   %13 = bitcast double* %4 to i8*, !dbg !818
SUSAN: printing cast from: double* to i8*
CBackend: writeOperand 3595:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: visiting cast:   %4 = bitcast i8* %call8 to double*, !dbg !785
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
SUSAN: getting value name for:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
inst from IRNaming:   %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !783, !tulip.target.mapdata.to !784
original name : y_1
returning name: y_1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %14) #11, !dbg !821 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #7

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %14 = bitcast double* %5 to i8*, !dbg !820
SUSAN: visiting cast:   %14 = bitcast double* %5 to i8*, !dbg !820
SUSAN: printing cast from: double* to i8*
CBackend: writeOperand 3595:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: visiting cast:   %5 = bitcast i8* %call11 to double*, !dbg !792
SUSAN: printing cast from: i8* to double*
CBackend: writeOperand 3595:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
SUSAN: getting value name for:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
inst from IRNaming:   %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !790, !tulip.target.mapdata.to !791
original name : y_2
returning name: y_2
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: iterating function 1759: atoi
CBackend: iterating function 1759: malloc
CBackend: iterating function 1759: _ZL10init_arrayiPdS_S_S_S_
CBackend: printing function 1770_ZL10init_arrayiPdS_S_S_S_
ANDREW: CBackend: runOnModule function: _ZL10init_arrayiPdS_S_S_S_
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
none omp loop ub:   %0 = sext i32 %n to i64, !dbg !759
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
none omp loop ub:   %wide.trip.count = zext i32 %n to i64, !dbg !790
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

isomp: 0
Loop: Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

isomp: 0
SUSAN: opnd0  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: opnd1  %0 = sext i32 %n to i64, !dbg !759
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: opnd0  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: opnd1  %wide.trip.count = zext i32 %n to i64, !dbg !790
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !751, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x1, metadata !753, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x2, metadata !754, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_1, metadata !755, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_2, metadata !756, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %A, metadata !757, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata i32 0, metadata !758, metadata !DIExpression()), !dbg !752
  %0 = sext i32 %n to i64, !dbg !759
  %1 = sext i32 %n to i64, !dbg !759
  br label %for.cond, !dbg !759

SUSAN: BB:
for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !758, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
  br i1 %cmp, label %for.body, label %for.end32, !dbg !764

SUSAN: BB:
for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv2 to i32, !dbg !765
  %conv = sitofp i32 %2 to double, !dbg !765
  %conv1 = sitofp i32 %n to double, !dbg !767
  %div = fdiv double %conv, %conv1, !dbg !768
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !769
  store double %div, double* %arrayidx, align 8, !dbg !770
  %3 = trunc i64 %indvars.iv2 to i32, !dbg !771
  %conv2 = sitofp i32 %3 to double, !dbg !771
  %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
  %conv3 = sitofp i32 %n to double, !dbg !773
  %div4 = fdiv double %add, %conv3, !dbg !774
  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !775
  store double %div4, double* %arrayidx6, align 8, !dbg !776
  %4 = trunc i64 %indvars.iv2 to i32, !dbg !777
  %conv7 = sitofp i32 %4 to double, !dbg !777
  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
  %conv9 = sitofp i32 %n to double, !dbg !779
  %div10 = fdiv double %add8, %conv9, !dbg !780
  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !781
  store double %div10, double* %arrayidx12, align 8, !dbg !782
  %5 = trunc i64 %indvars.iv2 to i32, !dbg !783
  %conv13 = sitofp i32 %5 to double, !dbg !783
  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
  %conv15 = sitofp i32 %n to double, !dbg !785
  %div16 = fdiv double %add14, %conv15, !dbg !786
  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !787
  store double %div16, double* %arrayidx18, align 8, !dbg !788
  call void @llvm.dbg.value(metadata i32 0, metadata !789, metadata !DIExpression()), !dbg !752
  %wide.trip.count = zext i32 %n to i64, !dbg !790
  br label %for.cond19, !dbg !793

SUSAN: BB:
for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !789, metadata !DIExpression()), !dbg !752
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !795

SUSAN: BB:
for.body21:                                       ; preds = %for.cond19
  %6 = trunc i64 %indvars.iv2 to i32, !dbg !796
  %conv22 = sitofp i32 %6 to double, !dbg !796
  %7 = trunc i64 %indvars.iv to i32, !dbg !797
  %conv23 = sitofp i32 %7 to double, !dbg !797
  %mul = fmul contract double %conv22, %conv23, !dbg !798
  %conv24 = sitofp i32 %n to double, !dbg !799
  %div25 = fdiv double %mul, %conv24, !dbg !800
  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
  %9 = add nsw i64 %8, %indvars.iv, !dbg !802
  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
  store double %div25, double* %arrayidx29, align 8, !dbg !804
  br label %for.inc, !dbg !803

SUSAN: BB:
for.inc:                                          ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
  call void @llvm.dbg.value(metadata i32 undef, metadata !789, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !752
  br label %for.cond19, !dbg !806, !llvm.loop !807

SUSAN: BB:
for.end:                                          ; preds = %for.cond19
  br label %for.inc30, !dbg !809

SUSAN: BB:
for.inc30:                                        ; preds = %for.end
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
  call void @llvm.dbg.value(metadata i32 undef, metadata !758, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !752
  br label %for.cond, !dbg !811, !llvm.loop !812

SUSAN: BB:
for.end32:                                        ; preds = %for.cond
  ret void, !dbg !814

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

SUSAN exitBB: 
for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !758, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
  br i1 %cmp, label %for.body, label %for.end32, !dbg !764

SUSAN: trying to get exit for loop: Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

SUSAN exitBB: 
for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !789, metadata !DIExpression()), !dbg !752
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !795

YEBIN: in Function _ZL10init_arrayiPdS_S_S_S_
YEBIN: creating CBE Region with entry to for.end32
YEBIN: new topmost region
SUSAN: block is a linear region! entry
CBERegion: including entry in a linear region
SUSAN: nextRegionEntryBB for.cond
YEBIN: in Function _ZL10init_arrayiPdS_S_S_S_
YEBIN: creating CBE Region with for.cond to for.end32
YEBIN: new topmost region
CBackend: entryBB is a loop: for.cond
SUSAN: block is a loop region! for.cond

creating loop region for entryBB: for.cond
YEBIN For Loop _ZL10init_arrayiPdS_S_S_S_::for.cond
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
YEBIN CBERegion: startBB 393: _ZL10init_arrayiPdS_S_S_S_::for.body
YEBIN: new region in loop _ZL10init_arrayiPdS_S_S_S_::for.cond
CBackend: entryBB is a loop: for.body
but not a header!
SUSAN: block is a linear region! for.body
CBERegion: including for.body in a linear region
SUSAN: nextRegionEntryBB for.cond19for region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

YEBIN: new region in loop _ZL10init_arrayiPdS_S_S_S_::for.cond
CBackend: entryBB is a loop: for.cond19
SUSAN: block is a loop region! for.cond19

creating loop region for entryBB: for.cond19
YEBIN For Loop _ZL10init_arrayiPdS_S_S_S_::for.cond19
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
YEBIN CBERegion: startBB 393: _ZL10init_arrayiPdS_S_S_S_::for.body21
YEBIN: new region in loop _ZL10init_arrayiPdS_S_S_S_::for.cond19
CBackend: entryBB is a loop: for.body21
but not a header!
SUSAN: block is a linear region! for.body21
CBERegion: including for.body21 in a linear region
SUSAN: nextRegionEntryBB for.incfor region: Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

SUSAN: nextRegionEntryBB for.endfor region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

YEBIN: new region in loop _ZL10init_arrayiPdS_S_S_S_::for.cond
CBackend: entryBB is a loop: for.end
but not a header!
SUSAN: block is a linear region! for.end
CBERegion: including for.end in a linear region
SUSAN: nextRegionEntryBB for.inc30for region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

SUSAN: nextRegionEntryBB for.end32
YEBIN: in Function _ZL10init_arrayiPdS_S_S_S_
YEBIN: creating CBE Region with for.end32 to for.end32
YEBIN: new topmost region
SUSAN: block is a linear region! for.end32
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

SUSAN: found LP for L:Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

currInst :  %0 = sext i32 %n to i64, !dbg !759
currInst :  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
currInst :  br i1 %cmp, label %for.body, label %for.end32, !dbg !764
currInst :  %1 = sext i32 %n to i64, !dbg !759
currInst :  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
currInst :  %9 = add nsw i64 %8, %indvars.iv, !dbg !802
currInst :  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
currInst :  br i1 %cmp, label %for.body, label %for.end32, !dbg !764
currInst :  %2 = trunc i64 %indvars.iv2 to i32, !dbg !765
currInst :  %conv = sitofp i32 %2 to double, !dbg !765
currInst :  %div = fdiv double %conv, %conv1, !dbg !768
currInst :  store double %div, double* %arrayidx, align 8, !dbg !770
currInst :  %conv = sitofp i32 %2 to double, !dbg !765
currInst :  %div = fdiv double %conv, %conv1, !dbg !768
currInst :  store double %div, double* %arrayidx, align 8, !dbg !770
currInst :  %conv1 = sitofp i32 %n to double, !dbg !767
currInst :  %div = fdiv double %conv, %conv1, !dbg !768
currInst :  store double %div, double* %arrayidx, align 8, !dbg !770
currInst :  %div = fdiv double %conv, %conv1, !dbg !768
currInst :  store double %div, double* %arrayidx, align 8, !dbg !770
currInst :  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !769
currInst :  store double %div, double* %arrayidx, align 8, !dbg !770
currInst :  %3 = trunc i64 %indvars.iv2 to i32, !dbg !771
currInst :  %conv2 = sitofp i32 %3 to double, !dbg !771
currInst :  %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
currInst :  %div4 = fdiv double %add, %conv3, !dbg !774
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %conv2 = sitofp i32 %3 to double, !dbg !771
currInst :  %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
currInst :  %div4 = fdiv double %add, %conv3, !dbg !774
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
currInst :  %div4 = fdiv double %add, %conv3, !dbg !774
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %conv3 = sitofp i32 %n to double, !dbg !773
currInst :  %div4 = fdiv double %add, %conv3, !dbg !774
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %div4 = fdiv double %add, %conv3, !dbg !774
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !775
currInst :  store double %div4, double* %arrayidx6, align 8, !dbg !776
currInst :  %4 = trunc i64 %indvars.iv2 to i32, !dbg !777
currInst :  %conv7 = sitofp i32 %4 to double, !dbg !777
currInst :  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
currInst :  %div10 = fdiv double %add8, %conv9, !dbg !780
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %conv7 = sitofp i32 %4 to double, !dbg !777
currInst :  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
currInst :  %div10 = fdiv double %add8, %conv9, !dbg !780
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
currInst :  %div10 = fdiv double %add8, %conv9, !dbg !780
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %conv9 = sitofp i32 %n to double, !dbg !779
currInst :  %div10 = fdiv double %add8, %conv9, !dbg !780
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %div10 = fdiv double %add8, %conv9, !dbg !780
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !781
currInst :  store double %div10, double* %arrayidx12, align 8, !dbg !782
currInst :  %5 = trunc i64 %indvars.iv2 to i32, !dbg !783
currInst :  %conv13 = sitofp i32 %5 to double, !dbg !783
currInst :  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
currInst :  %div16 = fdiv double %add14, %conv15, !dbg !786
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %conv13 = sitofp i32 %5 to double, !dbg !783
currInst :  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
currInst :  %div16 = fdiv double %add14, %conv15, !dbg !786
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
currInst :  %div16 = fdiv double %add14, %conv15, !dbg !786
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %conv15 = sitofp i32 %n to double, !dbg !785
currInst :  %div16 = fdiv double %add14, %conv15, !dbg !786
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %div16 = fdiv double %add14, %conv15, !dbg !786
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !787
currInst :  store double %div16, double* %arrayidx18, align 8, !dbg !788
currInst :  %wide.trip.count = zext i32 %n to i64, !dbg !790
currInst :  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
currInst :  br i1 %exitcond, label %for.body21, label %for.end, !dbg !795
currInst :  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
currInst :  br i1 %exitcond, label %for.body21, label %for.end, !dbg !795
currInst :  %6 = trunc i64 %indvars.iv2 to i32, !dbg !796
currInst :  %conv22 = sitofp i32 %6 to double, !dbg !796
currInst :  %mul = fmul contract double %conv22, %conv23, !dbg !798
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %conv22 = sitofp i32 %6 to double, !dbg !796
currInst :  %mul = fmul contract double %conv22, %conv23, !dbg !798
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %7 = trunc i64 %indvars.iv to i32, !dbg !797
currInst :  %conv23 = sitofp i32 %7 to double, !dbg !797
currInst :  %mul = fmul contract double %conv22, %conv23, !dbg !798
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %conv23 = sitofp i32 %7 to double, !dbg !797
currInst :  %mul = fmul contract double %conv22, %conv23, !dbg !798
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %mul = fmul contract double %conv22, %conv23, !dbg !798
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %conv24 = sitofp i32 %n to double, !dbg !799
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %div25 = fdiv double %mul, %conv24, !dbg !800
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
currInst :  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
currInst :  %9 = add nsw i64 %8, %indvars.iv, !dbg !802
currInst :  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: add () to inst:   %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
currInst :  %9 = add nsw i64 %8, %indvars.iv, !dbg !802
currInst :  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: add () to inst:   %9 = add nsw i64 %8, %indvars.iv, !dbg !802
currInst :  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
currInst :  store double %div25, double* %arrayidx29, align 8, !dbg !804
LP->LV 1694:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
LP->L 1694: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.cond19,%for.end,%for.inc30<latch>,%for.body21,%for.inc
    Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

nestlevel: i
LP->LV 1694:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
LP->L 1694: Loop at depth 2 containing: %for.cond19<header><exiting>,%for.body21,%for.inc<latch>

nestlevel: j
SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal void @_ZL10init_arrayiPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #2 !dbg !858 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
  %0 = sext i32 %n to i64, !dbg !867
  %1 = sext i32 %n to i64, !dbg !867
  br label %for.cond, !dbg !867

for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !869
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !870
  br i1 %cmp, label %for.body, label %for.end32, !dbg !872

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv2 to i32, !dbg !873
  %conv = sitofp i32 %2 to double, !dbg !873
  %conv1 = sitofp i32 %n to double, !dbg !875
  %div = fdiv double %conv, %conv1, !dbg !876
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !877
  store double %div, double* %arrayidx, align 8, !dbg !878
  %3 = trunc i64 %indvars.iv2 to i32, !dbg !879
  %conv2 = sitofp i32 %3 to double, !dbg !879
  %add = fadd contract double %conv2, 1.000000e+00, !dbg !880
  %conv3 = sitofp i32 %n to double, !dbg !881
  %div4 = fdiv double %add, %conv3, !dbg !882
  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !883
  store double %div4, double* %arrayidx6, align 8, !dbg !884
  %4 = trunc i64 %indvars.iv2 to i32, !dbg !885
  %conv7 = sitofp i32 %4 to double, !dbg !885
  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !886
  %conv9 = sitofp i32 %n to double, !dbg !887
  %div10 = fdiv double %add8, %conv9, !dbg !888
  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !889
  store double %div10, double* %arrayidx12, align 8, !dbg !890
  %5 = trunc i64 %indvars.iv2 to i32, !dbg !891
  %conv13 = sitofp i32 %5 to double, !dbg !891
  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !892
  %conv15 = sitofp i32 %n to double, !dbg !893
  %div16 = fdiv double %add14, %conv15, !dbg !894
  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !895
  store double %div16, double* %arrayidx18, align 8, !dbg !896
  call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
  %wide.trip.count = zext i32 %n to i64, !dbg !898
  br label %for.cond19, !dbg !901

for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !902
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !898
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !903

for.body21:                                       ; preds = %for.cond19
  %6 = trunc i64 %indvars.iv2 to i32, !dbg !904
  %conv22 = sitofp i32 %6 to double, !dbg !904
  %7 = trunc i64 %indvars.iv to i32, !dbg !905
  %conv23 = sitofp i32 %7 to double, !dbg !905
  %mul = fmul contract double %conv22, %conv23, !dbg !906
  %conv24 = sitofp i32 %n to double, !dbg !907
  %div25 = fdiv double %mul, %conv24, !dbg !908
  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !909
  %9 = add nsw i64 %8, %indvars.iv, !dbg !910
  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !911
  store double %div25, double* %arrayidx29, align 8, !dbg !912
  br label %for.inc, !dbg !911

for.inc:                                          ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !913
  call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond19, !dbg !914, !llvm.loop !915

for.end:                                          ; preds = %for.cond19
  br label %for.inc30, !dbg !917

for.inc30:                                        ; preds = %for.end
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !918
  call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond, !dbg !919, !llvm.loop !920

for.end32:                                        ; preds = %for.cond
  ret void, !dbg !922
}

SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
SUSAN: found argument 6346: double* %x1
CBackend: varname: x1
  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
SUSAN: found argument 6346: double* %x2
CBackend: varname: x2
  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
SUSAN: found argument 6346: double* %y_1
CBackend: varname: y_1
  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
SUSAN: found argument 6346: double* %y_2
CBackend: varname: y_2
  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
SUSAN: found argument 6346: double* %A
CBackend: varname: A
  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: phi related name: i
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: phi related name: j
=========================_ZL10init_arrayiPdS_S_S_S_: IR NAMING BEFORE=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761 -> i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794 -> j
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805 -> j
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810 -> i
SUSAN: inst:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
SUSAN: inst:  %0 = sext i32 %n to i64, !dbg !759
SUSAN: inst:  %1 = sext i32 %n to i64, !dbg !759
SUSAN: inst:  br label %for.cond, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  br i1 %cmp, label %for.body, label %for.end32, !dbg !764
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %2 = trunc i64 %indvars.iv2 to i32, !dbg !765
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv = sitofp i32 %2 to double, !dbg !765
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv1 = sitofp i32 %n to double, !dbg !767
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %div = fdiv double %conv, %conv1, !dbg !768
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !769
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  store double %div, double* %arrayidx, align 8, !dbg !770
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %3 = trunc i64 %indvars.iv2 to i32, !dbg !771
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv2 = sitofp i32 %3 to double, !dbg !771
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv3 = sitofp i32 %n to double, !dbg !773
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %div4 = fdiv double %add, %conv3, !dbg !774
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !775
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  store double %div4, double* %arrayidx6, align 8, !dbg !776
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %4 = trunc i64 %indvars.iv2 to i32, !dbg !777
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv7 = sitofp i32 %4 to double, !dbg !777
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv9 = sitofp i32 %n to double, !dbg !779
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %div10 = fdiv double %add8, %conv9, !dbg !780
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !781
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  store double %div10, double* %arrayidx12, align 8, !dbg !782
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %5 = trunc i64 %indvars.iv2 to i32, !dbg !783
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv13 = sitofp i32 %5 to double, !dbg !783
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv15 = sitofp i32 %n to double, !dbg !785
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %div16 = fdiv double %add14, %conv15, !dbg !786
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !787
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  store double %div16, double* %arrayidx18, align 8, !dbg !788
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %wide.trip.count = zext i32 %n to i64, !dbg !790
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  br label %for.cond19, !dbg !793
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  br i1 %exitcond, label %for.body21, label %for.end, !dbg !795
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %6 = trunc i64 %indvars.iv2 to i32, !dbg !796
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv22 = sitofp i32 %6 to double, !dbg !796
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %7 = trunc i64 %indvars.iv to i32, !dbg !797
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv23 = sitofp i32 %7 to double, !dbg !797
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %mul = fmul contract double %conv22, %conv23, !dbg !798
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %conv24 = sitofp i32 %n to double, !dbg !799
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %div25 = fdiv double %mul, %conv24, !dbg !800
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %9 = add nsw i64 %8, %indvars.iv, !dbg !802
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  store double %div25, double* %arrayidx29, align 8, !dbg !804
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  br label %for.inc, !dbg !803
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: inst:  br label %for.cond19, !dbg !806, !llvm.loop !807
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: inst:  br label %for.inc30, !dbg !809
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
i:  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
i:  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  br label %for.cond, !dbg !811, !llvm.loop !812
i:  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: inst:  ret void, !dbg !814
i:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
=========================_ZL10init_arrayiPdS_S_S_S_: IR NAMING=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761 -> i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794 -> j
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805 -> j
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810 -> i
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
YEBIN: WE ARE HERE FOR   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
SUSAN: declaring 3252:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: inst at 5950:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: declaring   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: printing type at 5937: i64
YEBIN: WE ARE HERE FOR   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: declared locals:
i
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: inst at 5950:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: declaring   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: printing type at 5937: i64
YEBIN: WE ARE HERE FOR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
original name : j
returning name: j
SUSAN: declaring varName 5298: j
YEBIN: WE ARE HERE FOR   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
SUSAN: getting value name for:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
inst from IRNaming:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: am I here 6807??
Linear Region with entering block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
printing unconditional branch   br label %for.cond, !dbg !759
Loop Region with entering block: for.cond
SUSAN: condrelatedinst:  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: condrelatedinst:  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !762
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: declaring 3252:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: visiting cast:   %0 = sext i32 %n to i64, !dbg !759
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
SUSAN: getting value name for:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
inst from IRNaming:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
inst from IRNaming:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: for.body
SUSAN: printing bb:for.body
CBEBackend: printing bb 7082 for.body
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: printing instruction   store double %div, double* %arrayidx, align 8, !dbg !770 at 6678
CBEBackend: printing store Inst:   store double %div, double* %arrayidx, align 8, !dbg !770
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !769
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !769
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x1
SUSAN: writing ptr 9994: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %div = fdiv double %conv, %conv1, !dbg !768
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %conv = sitofp i32 %2 to double, !dbg !765
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv = sitofp i32 %2 to double, !dbg !765
CBackend: writeOperand 3595:   %2 = trunc i64 %indvars.iv2 to i32, !dbg !765
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %2 = trunc i64 %indvars.iv2 to i32, !dbg !765
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv1 = sitofp i32 %n to double, !dbg !767
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv1 = sitofp i32 %n to double, !dbg !767
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: printing instruction   store double %div4, double* %arrayidx6, align 8, !dbg !776 at 6678
CBEBackend: printing store Inst:   store double %div4, double* %arrayidx6, align 8, !dbg !776
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !775
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !775
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x2
SUSAN: writing ptr 9994: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %div4 = fdiv double %add, %conv3, !dbg !774
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %add = fadd contract double %conv2, 1.000000e+00, !dbg !772
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %conv2 = sitofp i32 %3 to double, !dbg !771
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv2 = sitofp i32 %3 to double, !dbg !771
CBackend: writeOperand 3595:   %3 = trunc i64 %indvars.iv2 to i32, !dbg !771
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %3 = trunc i64 %indvars.iv2 to i32, !dbg !771
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595: double 1.000000e+00
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv3 = sitofp i32 %n to double, !dbg !773
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv3 = sitofp i32 %n to double, !dbg !773
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: printing instruction   store double %div10, double* %arrayidx12, align 8, !dbg !782 at 6678
CBEBackend: printing store Inst:   store double %div10, double* %arrayidx12, align 8, !dbg !782
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !781
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !781
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %y_1
SUSAN: writing ptr 9994: double* %y_1
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %div10 = fdiv double %add8, %conv9, !dbg !780
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !778
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %conv7 = sitofp i32 %4 to double, !dbg !777
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv7 = sitofp i32 %4 to double, !dbg !777
CBackend: writeOperand 3595:   %4 = trunc i64 %indvars.iv2 to i32, !dbg !777
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %4 = trunc i64 %indvars.iv2 to i32, !dbg !777
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595: double 3.000000e+00
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv9 = sitofp i32 %n to double, !dbg !779
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv9 = sitofp i32 %n to double, !dbg !779
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: printing instruction   store double %div16, double* %arrayidx18, align 8, !dbg !788 at 6678
CBEBackend: printing store Inst:   store double %div16, double* %arrayidx18, align 8, !dbg !788
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !787
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !787
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %y_2
SUSAN: writing ptr 9994: double* %y_2
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %div16 = fdiv double %add14, %conv15, !dbg !786
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !784
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeOperand 3595:   %conv13 = sitofp i32 %5 to double, !dbg !783
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv13 = sitofp i32 %5 to double, !dbg !783
CBackend: writeOperand 3595:   %5 = trunc i64 %indvars.iv2 to i32, !dbg !783
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %5 = trunc i64 %indvars.iv2 to i32, !dbg !783
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595: double 4.000000e+00
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv15 = sitofp i32 %n to double, !dbg !785
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: visiting cast:   %conv15 = sitofp i32 %n to double, !dbg !785
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
printing unconditional branch   br label %for.cond19, !dbg !793
Loop Region with entering block: for.cond19
SUSAN: condrelatedinst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: condrelatedinst:  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !790
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: visiting cast:   %wide.trip.count = zext i32 %n to i64, !dbg !790
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: for.body21
SUSAN: printing bb:for.body21
CBEBackend: printing bb 7082 for.body21
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: printing instruction   store double %div25, double* %arrayidx29, align 8, !dbg !804 at 6678
CBEBackend: printing store Inst:   store double %div25, double* %arrayidx29, align 8, !dbg !804
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !803
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %A
SUSAN: writing ptr 9994: double* %A
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
CBackend: writeOperand 3595:   %9 = add nsw i64 %8, %indvars.iv, !dbg !802
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeOperand 3595:   %8 = mul nsw i64 %indvars.iv2, %1, !dbg !801
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = sext i32 %n to i64, !dbg !759
SUSAN: visiting cast:   %1 = sext i32 %n to i64, !dbg !759
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %div25 = fdiv double %mul, %conv24, !dbg !800
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeOperand 3595:   %mul = fmul contract double %conv22, %conv23, !dbg !798
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeOperand 3595:   %conv22 = sitofp i32 %6 to double, !dbg !796
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: visiting cast:   %conv22 = sitofp i32 %6 to double, !dbg !796
CBackend: writeOperand 3595:   %6 = trunc i64 %indvars.iv2 to i32, !dbg !796
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: visiting cast:   %6 = trunc i64 %indvars.iv2 to i32, !dbg !796
CBackend: writeOperand 3595:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: getting value name for:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
inst from IRNaming:   %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv23 = sitofp i32 %7 to double, !dbg !797
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: visiting cast:   %conv23 = sitofp i32 %7 to double, !dbg !797
CBackend: writeOperand 3595:   %7 = trunc i64 %indvars.iv to i32, !dbg !797
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: visiting cast:   %7 = trunc i64 %indvars.iv to i32, !dbg !797
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %conv24 = sitofp i32 %n to double, !dbg !799
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: visiting cast:   %conv24 = sitofp i32 %n to double, !dbg !799
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBackend: writeoperand here 3674? 
CBackend: here? 10462
printing unconditional branch   br label %for.inc, !dbg !803
CBERegion: printing latchBB for.inc
CBERegion: I 316:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !805
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
CBERegion: I 316:   br label %for.cond19, !dbg !806, !llvm.loop !807
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !794
Linear Region with entering block: for.end
SUSAN: printing bb:for.end
CBEBackend: printing bb 7082 for.end
printing unconditional branch   br label %for.inc30, !dbg !809
CBERegion: printing latchBB for.inc30
CBERegion: I 316:   %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !810
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
CBERegion: I 316:   br label %for.cond, !dbg !811, !llvm.loop !812
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
SUSAN: found IV 784  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !761
Linear Region with entering block: for.end32
SUSAN: printing bb:for.end32
CBEBackend: printing bb 7082 for.end32
CBackend: iterating function 1759: cudaMemcpy
CBackend: iterating function 1759: _ZL11print_arrayiPdS_
CBackend: printing function 1770_ZL11print_arrayiPdS_
ANDREW: CBackend: runOnModule function: _ZL11print_arrayiPdS_
SUSAN: added stderr to delete insts
SUSAN: added stderr to delete insts
SUSAN: added stderr to delete insts
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
none omp loop ub:   %0 = sext i32 %n to i64, !dbg !756
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%if.then,%if.end,%for.inc<latch>

isomp: 0
SUSAN: opnd0  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: opnd1  %0 = sext i32 %n to i64, !dbg !756
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: opnd0  %rem.urem = urem i32 %5, 20
SUSAN: opnd1i32 0
SUSAN: LP->ub:   %0 = sext i32 %n to i64, !dbg !756
SUSAN: upperbound:   %0 = sext i32 %n to i64, !dbg !756
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !751, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x1, metadata !753, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x2, metadata !754, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata i32 0, metadata !755, metadata !DIExpression()), !dbg !752
  %0 = sext i32 %n to i64, !dbg !756
  br label %for.cond, !dbg !756

SUSAN: BB:
for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !755, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
  br i1 %cmp, label %for.body, label %for.end, !dbg !761

SUSAN: BB:
for.body:                                         ; preds = %for.cond
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !762
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !764
  %2 = load double, double* %arrayidx, align 8, !dbg !764
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !766
  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !767
  %4 = load double, double* %arrayidx2, align 8, !dbg !767
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
  %5 = trunc i64 %indvars.iv to i32
  %rem.urem = urem i32 %5, 20
  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
  br i1 %cmp4, label %if.then, label %if.end, !dbg !771

SUSAN: BB:
if.then:                                          ; preds = %for.body
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !772
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !773
  br label %if.end, !dbg !773

SUSAN: BB:
if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc, !dbg !774

SUSAN: BB:
for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
  call void @llvm.dbg.value(metadata i32 undef, metadata !755, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !752
  br label %for.cond, !dbg !776, !llvm.loop !777

SUSAN: BB:
for.end:                                          ; preds = %for.cond
  ret void, !dbg !779

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%if.then,%if.end,%for.inc<latch>

SUSAN exitBB: 
for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !755, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
  br i1 %cmp, label %for.body, label %for.end, !dbg !761

YEBIN: in Function _ZL11print_arrayiPdS_
YEBIN: creating CBE Region with entry to for.end
YEBIN: new topmost region
SUSAN: block is a linear region! entry
CBERegion: including entry in a linear region
SUSAN: nextRegionEntryBB for.cond
YEBIN: in Function _ZL11print_arrayiPdS_
YEBIN: creating CBE Region with for.cond to for.end
YEBIN: new topmost region
CBackend: entryBB is a loop: for.cond
SUSAN: block is a loop region! for.cond

creating loop region for entryBB: for.cond
YEBIN For Loop _ZL11print_arrayiPdS_::for.cond
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
YEBIN CBERegion: startBB 393: _ZL11print_arrayiPdS_::for.body
YEBIN: new region in loop _ZL11print_arrayiPdS_::for.cond
CBackend: entryBB is a loop: for.body
but not a header!
SUSAN: block is an if-else region! for.body
ANDREW: entryBB name:for.body
SUSAN: marking only true branch
YEBIN: new region in ifelse _ZL11print_arrayiPdS_::for.body
CBackend: entryBB is a loop: if.then
but not a header!
SUSAN: block is a linear region! if.then
CBERegion: including if.then in a linear region
CBERegion: including if.end in a linear region
SUSAN: currbb 562: for.inc
=================SUSAN: END OF marking region : for.body==================
SUSAN: nextRegionEntryBB if.endfor region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%if.then,%if.end,%for.inc<latch>

SUSAN: nextRegionEntryBB for.end
YEBIN: in Function _ZL11print_arrayiPdS_
YEBIN: creating CBE Region with for.end to for.end
YEBIN: new topmost region
SUSAN: block is a linear region! for.end
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
SUSAN: CI at 1400:   %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
SUSAN: CI at 1400:   %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
SUSAN: CI at 1400:   %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !773
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%if.then,%if.end,%for.inc<latch>

currInst :  %0 = sext i32 %n to i64, !dbg !756
currInst :  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
currInst :  br i1 %cmp, label %for.body, label %for.end, !dbg !761
currInst :  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
currInst :  br i1 %cmp, label %for.body, label %for.end, !dbg !761
currInst :  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !762
currInst :  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
currInst :  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !764
currInst :  %2 = load double, double* %arrayidx, align 8, !dbg !764
currInst :  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
currInst :  %2 = load double, double* %arrayidx, align 8, !dbg !764
currInst :  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
currInst :  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !766
currInst :  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
currInst :  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !767
currInst :  %4 = load double, double* %arrayidx2, align 8, !dbg !767
currInst :  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
currInst :  %4 = load double, double* %arrayidx2, align 8, !dbg !767
currInst :  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
currInst :  %5 = trunc i64 %indvars.iv to i32
currInst :  %rem.urem = urem i32 %5, 20
currInst :  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
currInst :  br i1 %cmp4, label %if.then, label %if.end, !dbg !771
currInst :  %rem.urem = urem i32 %5, 20
currInst :  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
currInst :  br i1 %cmp4, label %if.then, label %if.end, !dbg !771
currInst :  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
currInst :  br i1 %cmp4, label %if.then, label %if.end, !dbg !771
currInst :  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !772
currInst :  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !773
LP->LV 1694:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
LP->L 1694: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%if.then,%if.end,%for.inc<latch>

nestlevel: i
SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define internal void @_ZL11print_arrayiPdS_(i32 %n, double* %x1, double* %x2) #3 !dbg !923 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
  %0 = sext i32 %n to i64, !dbg !931
  br label %for.cond, !dbg !931

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !933
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !934
  br i1 %cmp, label %for.body, label %for.end, !dbg !936

for.body:                                         ; preds = %for.cond
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !937
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !939
  %2 = load double, double* %arrayidx, align 8, !dbg !939
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !940
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !941
  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !942
  %4 = load double, double* %arrayidx2, align 8, !dbg !942
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !943
  %5 = trunc i64 %indvars.iv to i32
  %rem.urem = urem i32 %5, 20
  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !944
  br i1 %cmp4, label %if.then, label %if.end, !dbg !946

if.then:                                          ; preds = %for.body
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !947
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !948
  br label %if.end, !dbg !948

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc, !dbg !949

for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !950
  call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
  br label %for.cond, !dbg !951, !llvm.loop !952

for.end:                                          ; preds = %for.cond
  ret void, !dbg !954
}

SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
SUSAN: found argument 6346: double* %x1
CBackend: varname: x1
  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
SUSAN: found argument 6346: double* %x2
CBackend: varname: x2
  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: phi related name: i
=========================_ZL11print_arrayiPdS_: IR NAMING BEFORE=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775 -> i
SUSAN: inst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
SUSAN: inst:  %0 = sext i32 %n to i64, !dbg !756
SUSAN: inst:  br label %for.cond, !dbg !756
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  br i1 %cmp, label %for.body, label %for.end, !dbg !761
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !762
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !764
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %2 = load double, double* %arrayidx, align 8, !dbg !764
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !765
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !766
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !767
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %4 = load double, double* %arrayidx2, align 8, !dbg !767
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !768
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %5 = trunc i64 %indvars.iv to i32
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %rem.urem = urem i32 %5, 20
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  br i1 %cmp4, label %if.then, label %if.end, !dbg !771
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !772
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !773
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  br label %if.end, !dbg !773
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  br label %for.inc, !dbg !774
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: inst:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: inst:  br label %for.cond, !dbg !776, !llvm.loop !777
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: inst:  ret void, !dbg !779
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
=========================_ZL11print_arrayiPdS_: IR NAMING=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775 -> i
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
YEBIN: WE ARE HERE FOR   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: inst at 5950:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: declaring   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: printing type at 5937: i64
YEBIN: WE ARE HERE FOR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: am I here 6807??
Linear Region with entering block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
printing unconditional branch   br label %for.cond, !dbg !756
Loop Region with entering block: for.cond
SUSAN: condrelatedinst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: condrelatedinst:  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !759
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: visiting cast:   %0 = sext i32 %n to i64, !dbg !756
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
IfElse Region with entering block: _ZL11print_arrayiPdS_::for.body
thenSubRegions : 
Linear Region with entering block: if.then
if.then
if.end
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeOperand 3595: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

SUSAN: getting value name for: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

CBackend: writeoperand here 3674? 
YEBIN: FPRINTF
CBackend: writeOperand 3595:   %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !762
CBackend: writeOperand 3595: i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0)
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975 @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %2 = load double, double* %arrayidx, align 8, !dbg !764
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: loadInst:   %2 = load double, double* %arrayidx, align 8, !dbg !764
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !764
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !764
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x1
SUSAN: writing ptr 9994: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeOperand 3595: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

SUSAN: getting value name for: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

CBackend: writeoperand here 3674? 
YEBIN: FPRINTF
CBackend: writeOperand 3595:   %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !766
CBackend: writeOperand 3595: i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0)
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975 @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %4 = load double, double* %arrayidx2, align 8, !dbg !767
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: loadInst:   %4 = load double, double* %arrayidx2, align 8, !dbg !767
SUSAN: GEPINST:   %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !767
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !767
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x2
SUSAN: writing ptr 9994: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !769
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeOperand 3595:   %rem.urem = urem i32 %5, 20
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeOperand 3595:   %5 = trunc i64 %indvars.iv to i32
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: visiting cast:   %5 = trunc i64 %indvars.iv to i32
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 20
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBackend: writeoperand here 3674? 
Linear Region with entering block: if.then
SUSAN: printing bb:if.then
CBEBackend: printing bb 7082 if.then
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: printing instruction   %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !773 at 6678
CBackend: writeOperand 3595: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

SUSAN: getting value name for: 
declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #8

CBackend: writeoperand here 3674? 
YEBIN: FPRINTF
CBackend: writeOperand 3595:   %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !772
CBackend: writeOperand 3595: i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975 @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
SUSAN: getting value name for: @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %if.end, !dbg !773
SUSAN: printing bb:if.end
CBEBackend: printing bb 7082 if.end
printing unconditional branch   br label %for.inc, !dbg !774
CBERegion: printing latchBB for.inc
CBERegion: I 316:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !775
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
CBERegion: I 316:   br label %for.cond, !dbg !776, !llvm.loop !777
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !758
Linear Region with entering block: for.end
SUSAN: printing bb:for.end
CBEBackend: printing bb 7082 for.end
CBackend: iterating function 1759: free
CBackend: iterating function 1759: fprintf
CBackend: iterating function 1759: cudaMalloc
CBackend: iterating function 1759: kernel_x1
CBackend: printing function 1770kernel_x1
ANDREW: CBackend: runOnModule function: kernel_x1
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
none omp loop ub:   %0 = sext i32 %n to i64, !dbg !765
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

isomp: 0
SUSAN: opnd0  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: opnd1i32 %n
SUSAN: LP->ub:   %0 = sext i32 %n to i64, !dbg !765
SUSAN: upperbound:   %0 = sext i32 %n to i64, !dbg !765
SUSAN: opnd0  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: opnd1  %0 = sext i32 %n to i64, !dbg !765
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !748, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x1, metadata !753, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x2, metadata !754, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_1, metadata !755, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_2, metadata !756, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %A, metadata !757, metadata !DIExpression()), !dbg !752
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
  %add = add i32 %mul, %threadIdx.x, !dbg !759
  call void @llvm.dbg.value(metadata i32 %add, metadata !760, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i32 %add, %n, !dbg !761
  br i1 %cmp, label %if.then, label %if.end, !dbg !763

SUSAN: BB:
if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !764, metadata !DIExpression()), !dbg !752
  %0 = sext i32 %n to i64, !dbg !765
  br label %for.cond, !dbg !765

SUSAN: BB:
for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !764, metadata !DIExpression()), !dbg !752
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
  br i1 %cmp3, label %for.body, label %for.end, !dbg !771

SUSAN: BB:
for.body:                                         ; preds = %for.cond
  %mul4 = mul nsw i32 %add, %n, !dbg !772
  %1 = sext i32 %mul4 to i64, !dbg !773
  %2 = add nsw i64 %1, %indvars.iv, !dbg !773
  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
  %3 = load double, double* %arrayidx, align 8, !dbg !774
  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !775
  %4 = load double, double* %arrayidx7, align 8, !dbg !775
  %mul8 = fmul contract double %3, %4, !dbg !776
  %idxprom9 = sext i32 %add to i64, !dbg !777
  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
  %5 = load double, double* %arrayidx10, align 8, !dbg !778
  %add11 = fadd contract double %5, %mul8, !dbg !778
  store double %add11, double* %arrayidx10, align 8, !dbg !778
  br label %for.inc, !dbg !777

SUSAN: BB:
for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
  call void @llvm.dbg.value(metadata i32 undef, metadata !764, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !752
  br label %for.cond, !dbg !780, !llvm.loop !781

SUSAN: BB:
for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !783

SUSAN: BB:
if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !784

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN exitBB: 
for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !764, metadata !DIExpression()), !dbg !752
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
  br i1 %cmp3, label %for.body, label %for.end, !dbg !771

YEBIN: in Function kernel_x1
YEBIN: creating CBE Region with entry to if.end
YEBIN: new topmost region
SUSAN: block is an if-else region! entry
ANDREW: entryBB name:entry
SUSAN: marking only true branch
YEBIN: new region in ifelse kernel_x1::entry
SUSAN: block is a linear region! if.then
CBERegion: including if.then in a linear region
SUSAN: currbb 562: for.cond
YEBIN: new region in ifelse kernel_x1::entry
CBackend: entryBB is a loop: for.cond
SUSAN: block is a loop region! for.cond

creating loop region for entryBB: for.cond
YEBIN For Loop kernel_x1::for.cond
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
YEBIN CBERegion: startBB 393: kernel_x1::for.body
YEBIN: new region in loop kernel_x1::for.cond
CBackend: entryBB is a loop: for.body
but not a header!
SUSAN: block is a linear region! for.body
CBERegion: including for.body in a linear region
SUSAN: nextRegionEntryBB for.incfor region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN: currbb 562: for.end
YEBIN: new region in ifelse kernel_x1::entry
SUSAN: block is a linear region! for.end
CBERegion: including for.end in a linear region
SUSAN: currbb 562: if.end
=================SUSAN: END OF marking region : entry==================
SUSAN: nextRegionEntryBB if.end
YEBIN: in Function kernel_x1
YEBIN: creating CBE Region with if.end to if.end
YEBIN: new topmost region
SUSAN: block is a linear region! if.end
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

currInst :  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
currInst :  %add = add i32 %mul, %threadIdx.x, !dbg !759
currInst :  %cmp = icmp slt i32 %add, %n, !dbg !761
currInst :  br i1 %cmp, label %if.then, label %if.end, !dbg !763
currInst :  %0 = sext i32 %n to i64, !dbg !765
currInst :  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
currInst :  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
currInst :  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
currInst :  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
currInst :  %mul4 = mul nsw i32 %add, %n, !dbg !772
currInst :  %1 = sext i32 %mul4 to i64, !dbg !773
currInst :  %2 = add nsw i64 %1, %indvars.iv, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: add () to inst:   %mul4 = mul nsw i32 %add, %n, !dbg !772
currInst :  %1 = sext i32 %mul4 to i64, !dbg !773
currInst :  %2 = add nsw i64 %1, %indvars.iv, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
currInst :  %3 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %2 = add nsw i64 %1, %indvars.iv, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: add () to inst:   %2 = add nsw i64 %1, %indvars.iv, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
currInst :  %3 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %3 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !775
currInst :  %4 = load double, double* %arrayidx7, align 8, !dbg !775
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %4 = load double, double* %arrayidx7, align 8, !dbg !775
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %mul8 = fmul contract double %3, %4, !dbg !776
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %idxprom9 = sext i32 %add to i64, !dbg !777
currInst :  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %5 = load double, double* %arrayidx10, align 8, !dbg !778
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %add11 = fadd contract double %5, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
LP->LV 1694:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
LP->L 1694: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

nestlevel: i
SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !963
  %add = add i32 %mul, %threadIdx.x, !dbg !964
  call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
  %cmp = icmp slt i32 %add, %n, !dbg !966
  br i1 %cmp, label %if.then, label %if.end, !dbg !968

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
  %0 = sext i32 %n to i64, !dbg !970
  br label %for.cond, !dbg !970

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !973
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !974
  br i1 %cmp3, label %for.body, label %for.end, !dbg !976

for.body:                                         ; preds = %for.cond
  %mul4 = mul nsw i32 %add, %n, !dbg !977
  %1 = sext i32 %mul4 to i64, !dbg !978
  %2 = add nsw i64 %1, %indvars.iv, !dbg !978
  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !979
  %3 = load double, double* %arrayidx, align 8, !dbg !979
  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !980
  %4 = load double, double* %arrayidx7, align 8, !dbg !980
  %mul8 = fmul contract double %3, %4, !dbg !981
  %idxprom9 = sext i32 %add to i64, !dbg !982
  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !982
  %5 = load double, double* %arrayidx10, align 8, !dbg !983
  %add11 = fadd contract double %5, %mul8, !dbg !983
  store double %add11, double* %arrayidx10, align 8, !dbg !983
  br label %for.inc, !dbg !982

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !984
  call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
  br label %for.cond, !dbg !985, !llvm.loop !986

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !988

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !989
}

SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
SUSAN: found argument 6346: double* %x1
CBackend: varname: x1
  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
SUSAN: found argument 6346: double* %x2
CBackend: varname: x2
  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
SUSAN: found argument 6346: double* %y_1
CBackend: varname: y_1
  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
SUSAN: found argument 6346: double* %y_2
CBackend: varname: y_2
  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
SUSAN: found argument 6346: double* %A
CBackend: varname: A
  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: phi related name: j
=========================kernel_x1: IR NAMING BEFORE=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768 -> j
  %add = add i32 %mul, %threadIdx.x, !dbg !759 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779 -> j
SUSAN: inst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
SUSAN: inst:  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
SUSAN: inst:  %add = add i32 %mul, %threadIdx.x, !dbg !759
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %cmp = icmp slt i32 %add, %n, !dbg !761
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  br i1 %cmp, label %if.then, label %if.end, !dbg !763
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %0 = sext i32 %n to i64, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  br label %for.cond, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %mul4 = mul nsw i32 %add, %n, !dbg !772
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %1 = sext i32 %mul4 to i64, !dbg !773
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %2 = add nsw i64 %1, %indvars.iv, !dbg !773
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %3 = load double, double* %arrayidx, align 8, !dbg !774
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !775
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %4 = load double, double* %arrayidx7, align 8, !dbg !775
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %mul8 = fmul contract double %3, %4, !dbg !776
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %idxprom9 = sext i32 %add to i64, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %5 = load double, double* %arrayidx10, align 8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %add11 = fadd contract double %5, %mul8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  store double %add11, double* %arrayidx10, align 8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  br label %for.inc, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  br label %for.cond, !dbg !780, !llvm.loop !781
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  br label %if.end, !dbg !783
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  ret void, !dbg !784
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
=========================kernel_x1: IR NAMING=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768 -> j
  %add = add i32 %mul, %threadIdx.x, !dbg !759 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779 -> j
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
SUSAN: getting value name for: i32 %gridDim.x
SUSAN: getting value name for: i32 %gridDim.y
SUSAN: getting value name for: i32 %gridDim.z
SUSAN: getting value name for: i32 %blockDim.x
SUSAN: getting value name for: i32 %blockDim.y
SUSAN: getting value name for: i32 %blockDim.z
SUSAN: getting value name for: i32 %blockIdx.x
SUSAN: getting value name for: i32 %blockIdx.y
SUSAN: getting value name for: i32 %blockIdx.z
SUSAN: getting value name for: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.y
SUSAN: getting value name for: i32 %threadIdx.z
YEBIN: WE ARE HERE FOR   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
SUSAN: declaring 3252:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: inst at 5950:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: declaring   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: printing type at 5930: i64
YEBIN: WE ARE HERE FOR   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: declared locals:
i
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: inst at 5950:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: declaring   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: printing type at 5937: i64
YEBIN: WE ARE HERE FOR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: am I here 6807??
IfElse Region with entering block: kernel_x1::entry
thenSubRegions : 
Linear Region with entering block: if.then
if.then
Loop Region with entering block: for.cond
Linear Region with entering block: for.body
for.body
Linear Region with entering block: for.end
for.end
SUSAN: declaring 3252:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeOperand 3595:   %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
CBackend: writeOperand 3595: i32 %blockDim.x
SUSAN: getting value name for: i32 %blockDim.x
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %blockIdx.x
SUSAN: getting value name for: i32 %blockIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %cmp = icmp slt i32 %add, %n, !dbg !761
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
Linear Region with entering block: if.then
SUSAN: printing bb:if.then
CBEBackend: printing bb 7082 if.then
printing unconditional branch   br label %for.cond, !dbg !765
Loop Region with entering block: for.cond
SUSAN: condrelatedinst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: condrelatedinst:  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: visiting cast:   %0 = sext i32 %n to i64, !dbg !765
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: for.body
SUSAN: printing bb:for.body
CBEBackend: printing bb 7082 for.body
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: printing instruction   store double %add11, double* %arrayidx10, align 8, !dbg !778 at 6678
CBEBackend: printing store Inst:   store double %add11, double* %arrayidx10, align 8, !dbg !778
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x1
SUSAN: writing ptr 9994: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeOperand 3595:   %idxprom9 = sext i32 %add to i64, !dbg !777
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: visiting cast:   %idxprom9 = sext i32 %add to i64, !dbg !777
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %add11 = fadd contract double %5, %mul8, !dbg !778
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %5 = load double, double* %arrayidx10, align 8, !dbg !778
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %5 = load double, double* %arrayidx10, align 8, !dbg !778
SUSAN: GEPINST:   %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !777
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x1
SUSAN: writing ptr 9994: double* %x1
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
CBackend: writeOperand 3595:   %idxprom9 = sext i32 %add to i64, !dbg !777
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: visiting cast:   %idxprom9 = sext i32 %add to i64, !dbg !777
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %mul8 = fmul contract double %3, %4, !dbg !776
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %3 = load double, double* %arrayidx, align 8, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %3 = load double, double* %arrayidx, align 8, !dbg !774
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !774
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %A
SUSAN: writing ptr 9994: double* %A
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
CBackend: writeOperand 3595:   %2 = add nsw i64 %1, %indvars.iv, !dbg !773
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %1 = sext i32 %mul4 to i64, !dbg !773
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: visiting cast:   %1 = sext i32 %mul4 to i64, !dbg !773
CBackend: writeOperand 3595:   %mul4 = mul nsw i32 %add, %n, !dbg !772
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %4 = load double, double* %arrayidx7, align 8, !dbg !775
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %4 = load double, double* %arrayidx7, align 8, !dbg !775
SUSAN: GEPINST:   %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !775
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !775
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %y_1
SUSAN: writing ptr 9994: double* %y_1
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: here? 10462
printing unconditional branch   br label %for.inc, !dbg !777
CBERegion: printing latchBB for.inc
CBERegion: I 316:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBERegion: I 316:   br label %for.cond, !dbg !780, !llvm.loop !781
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
Linear Region with entering block: for.end
SUSAN: printing bb:for.end
CBEBackend: printing bb 7082 for.end
printing unconditional branch   br label %if.end, !dbg !783
Linear Region with entering block: if.end
SUSAN: printing bb:if.end
CBEBackend: printing bb 7082 if.end
CBackend: iterating function 1759: kernel_x2
CBackend: printing function 1770kernel_x2
ANDREW: CBackend: runOnModule function: kernel_x2
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
none omp loop ub:   %0 = sext i32 %n to i64, !dbg !765
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

isomp: 0
SUSAN: opnd0  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: opnd1i32 %n
SUSAN: LP->ub:   %0 = sext i32 %n to i64, !dbg !765
SUSAN: upperbound:   %0 = sext i32 %n to i64, !dbg !765
SUSAN: opnd0  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: opnd1  %0 = sext i32 %n to i64, !dbg !765
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !748, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x1, metadata !753, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %x2, metadata !754, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_1, metadata !755, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %y_2, metadata !756, metadata !DIExpression()), !dbg !752
  call void @llvm.dbg.value(metadata double* %A, metadata !757, metadata !DIExpression()), !dbg !752
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
  %add = add i32 %mul, %threadIdx.x, !dbg !759
  call void @llvm.dbg.value(metadata i32 %add, metadata !760, metadata !DIExpression()), !dbg !752
  %cmp = icmp slt i32 %add, %n, !dbg !761
  br i1 %cmp, label %if.then, label %if.end, !dbg !763

SUSAN: BB:
if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !764, metadata !DIExpression()), !dbg !752
  %0 = sext i32 %n to i64, !dbg !765
  %1 = sext i32 %n to i64, !dbg !765
  %2 = sext i32 %add to i64, !dbg !765
  br label %for.cond, !dbg !765

SUSAN: BB:
for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !764, metadata !DIExpression()), !dbg !752
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
  br i1 %cmp3, label %for.body, label %for.end, !dbg !771

SUSAN: BB:
for.body:                                         ; preds = %for.cond
  %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
  %4 = add nsw i64 %3, %2, !dbg !773
  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
  %5 = load double, double* %arrayidx, align 8, !dbg !774
  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !775
  %6 = load double, double* %arrayidx7, align 8, !dbg !775
  %mul8 = fmul contract double %5, %6, !dbg !776
  %idxprom9 = sext i32 %add to i64, !dbg !777
  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
  %7 = load double, double* %arrayidx10, align 8, !dbg !778
  %add11 = fadd contract double %7, %mul8, !dbg !778
  store double %add11, double* %arrayidx10, align 8, !dbg !778
  br label %for.inc, !dbg !777

SUSAN: BB:
for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
  call void @llvm.dbg.value(metadata i32 undef, metadata !764, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !752
  br label %for.cond, !dbg !780, !llvm.loop !781

SUSAN: BB:
for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !783

SUSAN: BB:
if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !784

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN exitBB: 
for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !764, metadata !DIExpression()), !dbg !752
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
  br i1 %cmp3, label %for.body, label %for.end, !dbg !771

YEBIN: in Function kernel_x2
YEBIN: creating CBE Region with entry to if.end
YEBIN: new topmost region
SUSAN: block is an if-else region! entry
ANDREW: entryBB name:entry
SUSAN: marking only true branch
YEBIN: new region in ifelse kernel_x2::entry
SUSAN: block is a linear region! if.then
CBERegion: including if.then in a linear region
SUSAN: currbb 562: for.cond
YEBIN: new region in ifelse kernel_x2::entry
CBackend: entryBB is a loop: for.cond
SUSAN: block is a loop region! for.cond

creating loop region for entryBB: for.cond
YEBIN For Loop kernel_x2::for.cond
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
YEBIN CBERegion: startBB 393: kernel_x2::for.body
YEBIN: new region in loop kernel_x2::for.cond
CBackend: entryBB is a loop: for.body
but not a header!
SUSAN: block is a linear region! for.body
CBERegion: including for.body in a linear region
SUSAN: nextRegionEntryBB for.incfor region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN: currbb 562: for.end
YEBIN: new region in ifelse kernel_x2::entry
SUSAN: block is a linear region! for.end
CBERegion: including for.end in a linear region
SUSAN: currbb 562: if.end
=================SUSAN: END OF marking region : entry==================
SUSAN: nextRegionEntryBB if.end
YEBIN: in Function kernel_x2
YEBIN: creating CBE Region with if.end to if.end
YEBIN: new topmost region
SUSAN: block is a linear region! if.end
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

currInst :  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
currInst :  %add = add i32 %mul, %threadIdx.x, !dbg !759
currInst :  %cmp = icmp slt i32 %add, %n, !dbg !761
currInst :  br i1 %cmp, label %if.then, label %if.end, !dbg !763
currInst :  %0 = sext i32 %n to i64, !dbg !765
currInst :  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
currInst :  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
currInst :  %1 = sext i32 %n to i64, !dbg !765
currInst :  %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
currInst :  %4 = add nsw i64 %3, %2, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
currInst :  %5 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %2 = sext i32 %add to i64, !dbg !765
currInst :  %4 = add nsw i64 %3, %2, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
currInst :  %5 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
currInst :  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
currInst :  %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
currInst :  %4 = add nsw i64 %3, %2, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: add () to inst:   %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
currInst :  %4 = add nsw i64 %3, %2, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: add () to inst:   %4 = add nsw i64 %3, %2, !dbg !773
currInst :  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
currInst :  %5 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %5 = load double, double* %arrayidx, align 8, !dbg !774
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !775
currInst :  %6 = load double, double* %arrayidx7, align 8, !dbg !775
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %6 = load double, double* %arrayidx7, align 8, !dbg !775
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %mul8 = fmul contract double %5, %6, !dbg !776
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %idxprom9 = sext i32 %add to i64, !dbg !777
currInst :  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %7 = load double, double* %arrayidx10, align 8, !dbg !778
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
currInst :  %add11 = fadd contract double %7, %mul8, !dbg !778
currInst :  store double %add11, double* %arrayidx10, align 8, !dbg !778
LP->LV 1694:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
LP->L 1694: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

nestlevel: i
SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !998
  %add = add i32 %mul, %threadIdx.x, !dbg !999
  call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
  %cmp = icmp slt i32 %add, %n, !dbg !1001
  br i1 %cmp, label %if.then, label %if.end, !dbg !1003

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
  %0 = sext i32 %n to i64, !dbg !1005
  %1 = sext i32 %n to i64, !dbg !1005
  %2 = sext i32 %add to i64, !dbg !1005
  br label %for.cond, !dbg !1005

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !1008
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !1009
  br i1 %cmp3, label %for.body, label %for.end, !dbg !1011

for.body:                                         ; preds = %for.cond
  %3 = mul nsw i64 %indvars.iv, %1, !dbg !1012
  %4 = add nsw i64 %3, %2, !dbg !1013
  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !1014
  %5 = load double, double* %arrayidx, align 8, !dbg !1014
  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !1015
  %6 = load double, double* %arrayidx7, align 8, !dbg !1015
  %mul8 = fmul contract double %5, %6, !dbg !1016
  %idxprom9 = sext i32 %add to i64, !dbg !1017
  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !1017
  %7 = load double, double* %arrayidx10, align 8, !dbg !1018
  %add11 = fadd contract double %7, %mul8, !dbg !1018
  store double %add11, double* %arrayidx10, align 8, !dbg !1018
  br label %for.inc, !dbg !1017

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1019
  call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
  br label %for.cond, !dbg !1020, !llvm.loop !1021

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !1023

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !1024
}

SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
SUSAN: found argument 6346: double* %x1
CBackend: varname: x1
  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
SUSAN: found argument 6346: double* %x2
CBackend: varname: x2
  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
SUSAN: found argument 6346: double* %y_1
CBackend: varname: y_1
  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
SUSAN: found argument 6346: double* %y_2
CBackend: varname: y_2
  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
SUSAN: found argument 6346: double* %A
CBackend: varname: A
  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: phi related name: j
=========================kernel_x2: IR NAMING BEFORE=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768 -> j
  %add = add i32 %mul, %threadIdx.x, !dbg !759 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779 -> j
SUSAN: inst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  br i1 %cmp3, label %for.body, label %for.end, !dbg !771
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %4 = add nsw i64 %3, %2, !dbg !773
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %5 = load double, double* %arrayidx, align 8, !dbg !774
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !775
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %6 = load double, double* %arrayidx7, align 8, !dbg !775
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %mul8 = fmul contract double %5, %6, !dbg !776
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %idxprom9 = sext i32 %add to i64, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %7 = load double, double* %arrayidx10, align 8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  br label %for.inc, !dbg !777
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
SUSAN: inst:  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
SUSAN: inst:  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
SUSAN: inst:  %add = add i32 %mul, %threadIdx.x, !dbg !759
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %cmp = icmp slt i32 %add, %n, !dbg !761
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  br i1 %cmp, label %if.then, label %if.end, !dbg !763
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %0 = sext i32 %n to i64, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %1 = sext i32 %n to i64, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %2 = sext i32 %add to i64, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  br label %for.cond, !dbg !765
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: inst:  %add11 = fadd contract double %7, %mul8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  store double %add11, double* %arrayidx10, align 8, !dbg !778
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  br label %for.cond, !dbg !780, !llvm.loop !781
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: inst:  br label %if.end, !dbg !783
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: inst:  ret void, !dbg !784
i:  %add = add i32 %mul, %threadIdx.x, !dbg !759
j:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
=========================kernel_x2: IR NAMING=====================
i32 %n -> n
double* %x1 -> x1
double* %x2 -> x2
double* %y_1 -> y_1
double* %y_2 -> y_2
double* %A -> A
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768 -> j
  %add = add i32 %mul, %threadIdx.x, !dbg !759 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779 -> j
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: double* %x1
inst from IRNaming: double* %x1
original name : x1
returning name: x1
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
SUSAN: getting value name for: double* %y_1
inst from IRNaming: double* %y_1
original name : y_1
returning name: y_1
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
SUSAN: getting value name for: i32 %gridDim.x
SUSAN: getting value name for: i32 %gridDim.y
SUSAN: getting value name for: i32 %gridDim.z
SUSAN: getting value name for: i32 %blockDim.x
SUSAN: getting value name for: i32 %blockDim.y
SUSAN: getting value name for: i32 %blockDim.z
SUSAN: getting value name for: i32 %blockIdx.x
SUSAN: getting value name for: i32 %blockIdx.y
SUSAN: getting value name for: i32 %blockIdx.z
SUSAN: getting value name for: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.y
SUSAN: getting value name for: i32 %threadIdx.z
YEBIN: WE ARE HERE FOR   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
SUSAN: declaring 3252:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: inst at 5950:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: declaring   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: printing type at 5930: i64
YEBIN: WE ARE HERE FOR   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: declared locals:
i
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: inst at 5950:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: declaring   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: printing type at 5937: i64
YEBIN: WE ARE HERE FOR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: am I here 6807??
IfElse Region with entering block: kernel_x2::entry
thenSubRegions : 
Linear Region with entering block: if.then
if.then
Loop Region with entering block: for.cond
Linear Region with entering block: for.body
for.body
Linear Region with entering block: for.end
for.end
SUSAN: declaring 3252:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeOperand 3595:   %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !758
CBackend: writeOperand 3595: i32 %blockDim.x
SUSAN: getting value name for: i32 %blockDim.x
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %blockIdx.x
SUSAN: getting value name for: i32 %blockIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %cmp = icmp slt i32 %add, %n, !dbg !761
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
Linear Region with entering block: if.then
SUSAN: printing bb:if.then
CBEBackend: printing bb 7082 if.then
printing unconditional branch   br label %for.cond, !dbg !765
Loop Region with entering block: for.cond
SUSAN: condrelatedinst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: condrelatedinst:  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !769
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: visiting cast:   %0 = sext i32 %n to i64, !dbg !765
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
SUSAN: declaring 3252:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entering block: for.body
SUSAN: printing bb:for.body
CBEBackend: printing bb 7082 for.body
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: printing instruction   store double %add11, double* %arrayidx10, align 8, !dbg !778 at 6678
CBEBackend: printing store Inst:   store double %add11, double* %arrayidx10, align 8, !dbg !778
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x2
SUSAN: writing ptr 9994: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeOperand 3595:   %idxprom9 = sext i32 %add to i64, !dbg !777
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: visiting cast:   %idxprom9 = sext i32 %add to i64, !dbg !777
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %add11 = fadd contract double %7, %mul8, !dbg !778
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %7 = load double, double* %arrayidx10, align 8, !dbg !778
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %7 = load double, double* %arrayidx10, align 8, !dbg !778
SUSAN: GEPINST:   %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !777
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %x2
SUSAN: writing ptr 9994: double* %x2
SUSAN: getting value name for: double* %x2
inst from IRNaming: double* %x2
original name : x2
returning name: x2
CBackend: writeOperand 3595:   %idxprom9 = sext i32 %add to i64, !dbg !777
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: visiting cast:   %idxprom9 = sext i32 %add to i64, !dbg !777
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %mul8 = fmul contract double %5, %6, !dbg !776
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %5 = load double, double* %arrayidx, align 8, !dbg !774
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %5 = load double, double* %arrayidx, align 8, !dbg !774
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !774
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %A
SUSAN: writing ptr 9994: double* %A
SUSAN: getting value name for: double* %A
inst from IRNaming: double* %A
original name : A
returning name: A
CBackend: writeOperand 3595:   %4 = add nsw i64 %3, %2, !dbg !773
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %3 = mul nsw i64 %indvars.iv, %1, !dbg !772
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = sext i32 %n to i64, !dbg !765
SUSAN: visiting cast:   %1 = sext i32 %n to i64, !dbg !765
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %2 = sext i32 %add to i64, !dbg !765
SUSAN: visiting cast:   %2 = sext i32 %add to i64, !dbg !765
CBackend: writeOperand 3595:   %add = add i32 %mul, %threadIdx.x, !dbg !759
SUSAN: getting value name for:   %add = add i32 %mul, %threadIdx.x, !dbg !759
inst from IRNaming:   %add = add i32 %mul, %threadIdx.x, !dbg !759
original name : i
returning name: i
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: am I here 8049?
CBackend: writeOperand 3595:   %6 = load double, double* %arrayidx7, align 8, !dbg !775
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: loadInst:   %6 = load double, double* %arrayidx7, align 8, !dbg !775
SUSAN: GEPINST:   %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !775
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !775
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:double* %y_2
SUSAN: writing ptr 9994: double* %y_2
SUSAN: getting value name for: double* %y_2
inst from IRNaming: double* %y_2
original name : y_2
returning name: y_2
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
original name : j
returning name: j
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBackend: writeoperand here 3674? 
CBackend: here? 10462
printing unconditional branch   br label %for.inc, !dbg !777
CBERegion: printing latchBB for.inc
CBERegion: I 316:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !779
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
CBERegion: I 316:   br label %for.cond, !dbg !780, !llvm.loop !781
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !768
Linear Region with entering block: for.end
SUSAN: printing bb:for.end
CBEBackend: printing bb 7082 for.end
printing unconditional branch   br label %if.end, !dbg !783
Linear Region with entering block: if.end
SUSAN: printing bb:if.end
CBEBackend: printing bb 7082 if.end
CBackend: iterating function 1759: llvm.dbg.value
CBackend: iterating function 1759: memcpy
TOTAL VARIABLES: 51
RECONSTRUCTED VARIABLES: 41
YEBIN: struct._IO_marker is Empty
YEBIN: struct._IO_codecvt is Empty
YEBIN: struct._IO_wide_data is Empty
SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define dso_local signext i16 @_Z10num_blocksss(i16 signext %num, i16 signext %factor) #2 !dbg !748 {
entry:
  call void @llvm.dbg.value(metadata i16 %num, metadata !752, metadata !DIExpression()), !dbg !753
  call void @llvm.dbg.value(metadata i16 %factor, metadata !754, metadata !DIExpression()), !dbg !753
  %conv = sext i16 %num to i32, !dbg !755
  %conv1 = sext i16 %factor to i32, !dbg !756
  %add = add nsw i32 %conv, %conv1, !dbg !757
  %sub = sub nsw i32 %add, 1, !dbg !758
  %conv2 = sext i16 %factor to i32, !dbg !759
  %div = sdiv i32 %sub, %conv2, !dbg !760
  %conv3 = trunc i32 %div to i16, !dbg !761
  ret i16 %conv3, !dbg !762
}

SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define dso_local void @_Z6kerneliPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #3 !dbg !763 {
entry:
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp1 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp1.coerce = alloca { i64, i32 }, align 4
  %agg.tmp5 = alloca %struct.dim3, align 4
  %agg.tmp7 = alloca %struct.dim3, align 4
  %agg.tmp5.coerce = alloca { i64, i32 }, align 4
  %agg.tmp7.coerce = alloca { i64, i32 }, align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !766, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x1, metadata !768, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %x2, metadata !769, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_1, metadata !770, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %y_2, metadata !771, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata double* %A, metadata !772, metadata !DIExpression()), !dbg !767
  call void @llvm.dbg.value(metadata i16 256, metadata !773, metadata !DIExpression()), !dbg !767
  %conv = sext i16 256 to i32, !dbg !774
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %conv, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %conv2 = trunc i32 %n to i16, !dbg !775
  %call = call signext i16 @_Z10num_blocksss(i16 signext %conv2, i16 signext 256), !dbg !776
  %conv3 = sext i16 %call to i32, !dbg !776
  %dim3gep.01 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 0
  store i32 %conv3, i32* %dim3gep.01
  %dim3gep.12 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 1
  store i32 1, i32* %dim3gep.12
  %dim3gep.23 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp1, i32 0, i32 2
  store i32 1, i32* %dim3gep.23
  %0 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !777
  %1 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !777
  %2 = call i8* @memcpy(i8* %0, i8* %1, i64 12), !dbg !777
  %3 = bitcast { i64, i32 }* %agg.tmp1.coerce to i8*, !dbg !777
  %4 = bitcast %struct.dim3* %agg.tmp1 to i8*, !dbg !777
  %5 = call i8* @memcpy(i8* %3, i8* %4, i64 12), !dbg !777
  br label %header.0

header.0:                                         ; preds = %latch.0, %entry
  %indvar.0 = phi i32 [ 0, %entry ], [ %indvar.next.0, %latch.0 ]
  %exitcond22 = icmp ne i32 %indvar.0, 256
  br i1 %exitcond22, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !778

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond21 = icmp ne i32 %indvar.1, %conv3
  br i1 %exitcond21, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !778

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add nuw nsw i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv, i32 1, i32 1, i32 %conv3, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %conv6 = sext i16 256 to i32, !dbg !779
  %dim3gep.04 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 0
  store i32 %conv6, i32* %dim3gep.04
  %dim3gep.15 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 1
  store i32 1, i32* %dim3gep.15
  %dim3gep.26 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp5, i32 0, i32 2
  store i32 1, i32* %dim3gep.26
  %conv8 = trunc i32 %n to i16, !dbg !780
  %call9 = call signext i16 @_Z10num_blocksss(i16 signext %conv8, i16 signext 256), !dbg !781
  %conv10 = sext i16 %call9 to i32, !dbg !781
  %dim3gep.07 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 0
  store i32 %conv10, i32* %dim3gep.07
  %dim3gep.18 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 1
  store i32 1, i32* %dim3gep.18
  %dim3gep.29 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp7, i32 0, i32 2
  store i32 1, i32* %dim3gep.29
  %6 = bitcast { i64, i32 }* %agg.tmp5.coerce to i8*, !dbg !782
  %7 = bitcast %struct.dim3* %agg.tmp5 to i8*, !dbg !782
  %8 = call i8* @memcpy(i8* %6, i8* %7, i64 12), !dbg !782
  %9 = bitcast { i64, i32 }* %agg.tmp7.coerce to i8*, !dbg !782
  %10 = bitcast %struct.dim3* %agg.tmp7 to i8*, !dbg !782
  %11 = call i8* @memcpy(i8* %9, i8* %10, i64 12), !dbg !782
  br label %header.010

header.010:                                       ; preds = %latch.013, %kcall.end
  %indvar.017 = phi i32 [ 0, %kcall.end ], [ %indvar.next.019, %latch.013 ]
  %exitcond20 = icmp ne i32 %indvar.017, 256
  br i1 %exitcond20, label %header.111.preheader, label %kcall.end14, !tulip.doall.loop.grid !778

header.111.preheader:                             ; preds = %header.010
  br label %header.111

header.111:                                       ; preds = %header.111.preheader, %latch.112
  %indvar.114 = phi i32 [ %indvar.next.116, %latch.112 ], [ 0, %header.111.preheader ]
  %exitcond = icmp ne i32 %indvar.114, %conv10
  br i1 %exitcond, label %kcall.configok13, label %latch.013, !tulip.doall.loop.block !778

latch.112:                                        ; preds = %kcall.configok13
  %indvar.next.116 = add i32 %indvar.114, 1
  br label %header.111

latch.013:                                        ; preds = %header.111
  %indvar.next.019 = add nuw nsw i32 %indvar.017, 1
  br label %header.010

kcall.configok13:                                 ; preds = %header.111
  call void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %conv6, i32 1, i32 1, i32 %conv10, i32 1, i32 1, i32 %indvar.017, i32 0, i32 0, i32 %indvar.114, i32 0, i32 0)
  br label %latch.112

kcall.end14:                                      ; preds = %header.010
  ret void, !dbg !783
}

SUSAN: getting value name for: 
; Function Attrs: noinline norecurse uwtable
define dso_local i32 @main(i32 %argc, i8** %argv) #5 !dbg !784 {
entry:
  call void @llvm.dbg.value(metadata i32 %argc, metadata !787, metadata !DIExpression()), !dbg !788
  call void @llvm.dbg.value(metadata i8** %argv, metadata !789, metadata !DIExpression()), !dbg !788
  %arrayidx = getelementptr inbounds i8*, i8** %argv, i64 1, !dbg !790
  %0 = load i8*, i8** %arrayidx, align 8, !dbg !790
  %call = call i32 @atoi(i8* %0) #10, !dbg !791
  call void @llvm.dbg.value(metadata i32 %call, metadata !792, metadata !DIExpression()), !dbg !788
  call void @llvm.dbg.value(metadata i32 15000, metadata !793, metadata !DIExpression()), !dbg !788
  %call1 = call noalias i8* @malloc(i64 1800000000) #11, !dbg !794, !tulip.target.mapdata.to !795
  %1 = bitcast i8* %call1 to double*, !dbg !796
  call void @llvm.dbg.value(metadata double* %1, metadata !797, metadata !DIExpression()), !dbg !788
  %conv = sext i32 15000 to i64, !dbg !798
  %mul = mul i64 8, %conv, !dbg !799, !tulip.target.datasize !800
  %call2 = call noalias i8* @malloc(i64 %mul) #11, !dbg !801, !tulip.target.mapdata.to !802, !tulip.target.mapdata.from !804
  %2 = bitcast i8* %call2 to double*, !dbg !805
  call void @llvm.dbg.value(metadata double* %2, metadata !806, metadata !DIExpression()), !dbg !788
  %conv3 = sext i32 15000 to i64, !dbg !807
  %mul4 = mul i64 8, %conv3, !dbg !808, !tulip.target.datasize !809
  %call5 = call noalias i8* @malloc(i64 %mul4) #11, !dbg !810, !tulip.target.mapdata.to !811, !tulip.target.mapdata.from !813
  %3 = bitcast i8* %call5 to double*, !dbg !814
  call void @llvm.dbg.value(metadata double* %3, metadata !815, metadata !DIExpression()), !dbg !788
  %conv6 = sext i32 15000 to i64, !dbg !816
  %mul7 = mul i64 8, %conv6, !dbg !817, !tulip.target.datasize !818
  %call8 = call noalias i8* @malloc(i64 %mul7) #11, !dbg !819, !tulip.target.mapdata.to !820
  %4 = bitcast i8* %call8 to double*, !dbg !821
  call void @llvm.dbg.value(metadata double* %4, metadata !822, metadata !DIExpression()), !dbg !788
  %conv9 = sext i32 15000 to i64, !dbg !823
  %mul10 = mul i64 8, %conv9, !dbg !824, !tulip.target.datasize !825
  %call11 = call noalias i8* @malloc(i64 %mul10) #11, !dbg !826, !tulip.target.mapdata.to !827
  %5 = bitcast i8* %call11 to double*, !dbg !828
  call void @llvm.dbg.value(metadata double* %5, metadata !829, metadata !DIExpression()), !dbg !788
  call void @_ZL10init_arrayiPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !830
  %6 = bitcast double* %1 to i8*, !dbg !831
  %7 = bitcast double* %1 to i8*, !dbg !832
  %mul28 = mul nsw i32 15000, 15000, !dbg !833
  %conv29 = sext i32 %mul28 to i64, !dbg !834
  %mul30 = mul i64 %conv29, 8, !dbg !835
  %call31 = call i32 @cudaMemcpy(i8* %6, i8* %7, i64 %mul30, i32 1), !dbg !836, !tulip.target.start.of.map !778
  call void @_Z6kerneliPdS_S_S_S_(i32 15000, double* %2, double* %3, double* %4, double* %5, double* %1), !dbg !837
  %8 = bitcast double* %2 to i8*, !dbg !838
  %9 = bitcast double* %2 to i8*, !dbg !839
  %conv44 = sext i32 15000 to i64, !dbg !840
  %mul45 = mul i64 %conv44, 8, !dbg !841
  %call46 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 %mul45, i32 2), !dbg !842, !tulip.target.end.of.map !778
  %cmp = icmp eq i32 %call, 1, !dbg !843
  br i1 %cmp, label %if.then, label %if.end, !dbg !845

if.then:                                          ; preds = %entry
  call void @_ZL11print_arrayiPdS_(i32 15000, double* %2, double* %3), !dbg !846
  br label %if.end, !dbg !846

if.end:                                           ; preds = %if.then, %entry
  %10 = bitcast double* %1 to i8*, !dbg !847
  call void @free(i8* %10) #11, !dbg !848
  %11 = bitcast double* %2 to i8*, !dbg !849
  call void @free(i8* %11) #11, !dbg !850
  %12 = bitcast double* %3 to i8*, !dbg !851
  call void @free(i8* %12) #11, !dbg !852
  %13 = bitcast double* %4 to i8*, !dbg !853
  call void @free(i8* %13) #11, !dbg !854
  %14 = bitcast double* %5 to i8*, !dbg !855
  call void @free(i8* %14) #11, !dbg !856
  ret i32 0, !dbg !857
}

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal void @_ZL10init_arrayiPdS_S_S_S_(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A) #2 !dbg !858 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !859, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x1, metadata !861, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %x2, metadata !862, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_1, metadata !863, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %y_2, metadata !864, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata double* %A, metadata !865, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.value(metadata i32 0, metadata !866, metadata !DIExpression()), !dbg !860
  %0 = sext i32 %n to i64, !dbg !867
  %1 = sext i32 %n to i64, !dbg !867
  br label %for.cond, !dbg !867

for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc30 ], [ 0, %entry ], !dbg !869
  call void @llvm.dbg.value(metadata i64 %indvars.iv2, metadata !866, metadata !DIExpression()), !dbg !860
  %cmp = icmp slt i64 %indvars.iv2, %0, !dbg !870
  br i1 %cmp, label %for.body, label %for.end32, !dbg !872

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv2 to i32, !dbg !873
  %conv = sitofp i32 %2 to double, !dbg !873
  %conv1 = sitofp i32 %n to double, !dbg !875
  %div = fdiv double %conv, %conv1, !dbg !876
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv2, !dbg !877
  store double %div, double* %arrayidx, align 8, !dbg !878
  %3 = trunc i64 %indvars.iv2 to i32, !dbg !879
  %conv2 = sitofp i32 %3 to double, !dbg !879
  %add = fadd contract double %conv2, 1.000000e+00, !dbg !880
  %conv3 = sitofp i32 %n to double, !dbg !881
  %div4 = fdiv double %add, %conv3, !dbg !882
  %arrayidx6 = getelementptr inbounds double, double* %x2, i64 %indvars.iv2, !dbg !883
  store double %div4, double* %arrayidx6, align 8, !dbg !884
  %4 = trunc i64 %indvars.iv2 to i32, !dbg !885
  %conv7 = sitofp i32 %4 to double, !dbg !885
  %add8 = fadd contract double %conv7, 3.000000e+00, !dbg !886
  %conv9 = sitofp i32 %n to double, !dbg !887
  %div10 = fdiv double %add8, %conv9, !dbg !888
  %arrayidx12 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv2, !dbg !889
  store double %div10, double* %arrayidx12, align 8, !dbg !890
  %5 = trunc i64 %indvars.iv2 to i32, !dbg !891
  %conv13 = sitofp i32 %5 to double, !dbg !891
  %add14 = fadd contract double %conv13, 4.000000e+00, !dbg !892
  %conv15 = sitofp i32 %n to double, !dbg !893
  %div16 = fdiv double %add14, %conv15, !dbg !894
  %arrayidx18 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv2, !dbg !895
  store double %div16, double* %arrayidx18, align 8, !dbg !896
  call void @llvm.dbg.value(metadata i32 0, metadata !897, metadata !DIExpression()), !dbg !860
  %wide.trip.count = zext i32 %n to i64, !dbg !898
  br label %for.cond19, !dbg !901

for.cond19:                                       ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ], !dbg !902
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !897, metadata !DIExpression()), !dbg !860
  %exitcond = icmp ne i64 %indvars.iv, %wide.trip.count, !dbg !898
  br i1 %exitcond, label %for.body21, label %for.end, !dbg !903

for.body21:                                       ; preds = %for.cond19
  %6 = trunc i64 %indvars.iv2 to i32, !dbg !904
  %conv22 = sitofp i32 %6 to double, !dbg !904
  %7 = trunc i64 %indvars.iv to i32, !dbg !905
  %conv23 = sitofp i32 %7 to double, !dbg !905
  %mul = fmul contract double %conv22, %conv23, !dbg !906
  %conv24 = sitofp i32 %n to double, !dbg !907
  %div25 = fdiv double %mul, %conv24, !dbg !908
  %8 = mul nsw i64 %indvars.iv2, %1, !dbg !909
  %9 = add nsw i64 %8, %indvars.iv, !dbg !910
  %arrayidx29 = getelementptr inbounds double, double* %A, i64 %9, !dbg !911
  store double %div25, double* %arrayidx29, align 8, !dbg !912
  br label %for.inc, !dbg !911

for.inc:                                          ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !913
  call void @llvm.dbg.value(metadata i32 undef, metadata !897, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond19, !dbg !914, !llvm.loop !915

for.end:                                          ; preds = %for.cond19
  br label %for.inc30, !dbg !917

for.inc30:                                        ; preds = %for.end
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1, !dbg !918
  call void @llvm.dbg.value(metadata i32 undef, metadata !866, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !860
  br label %for.cond, !dbg !919, !llvm.loop !920

for.end32:                                        ; preds = %for.cond
  ret void, !dbg !922
}

SUSAN: getting value name for: 
; Function Attrs: noinline uwtable
define internal void @_ZL11print_arrayiPdS_(i32 %n, double* %x1, double* %x2) #3 !dbg !923 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !926, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x1, metadata !928, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata double* %x2, metadata !929, metadata !DIExpression()), !dbg !927
  call void @llvm.dbg.value(metadata i32 0, metadata !930, metadata !DIExpression()), !dbg !927
  %0 = sext i32 %n to i64, !dbg !931
  br label %for.cond, !dbg !931

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ], !dbg !933
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !930, metadata !DIExpression()), !dbg !927
  %cmp = icmp slt i64 %indvars.iv, %0, !dbg !934
  br i1 %cmp, label %for.body, label %for.end, !dbg !936

for.body:                                         ; preds = %for.cond
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !937
  %arrayidx = getelementptr inbounds double, double* %x1, i64 %indvars.iv, !dbg !939
  %2 = load double, double* %arrayidx, align 8, !dbg !939
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %2), !dbg !940
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !941
  %arrayidx2 = getelementptr inbounds double, double* %x2, i64 %indvars.iv, !dbg !942
  %4 = load double, double* %arrayidx2, align 8, !dbg !942
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), double %4), !dbg !943
  %5 = trunc i64 %indvars.iv to i32
  %rem.urem = urem i32 %5, 20
  %cmp4 = icmp eq i32 %rem.urem, 0, !dbg !944
  br i1 %cmp4, label %if.then, label %if.end, !dbg !946

if.then:                                          ; preds = %for.body
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !dbg !947
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.1, i64 0, i64 0)), !dbg !948
  br label %if.end, !dbg !948

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc, !dbg !949

for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !950
  call void @llvm.dbg.value(metadata i32 undef, metadata !930, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !927
  br label %for.cond, !dbg !951, !llvm.loop !952

for.end:                                          ; preds = %for.cond
  ret void, !dbg !954
}

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x1(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !955, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x1, metadata !958, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %x2, metadata !959, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_1, metadata !960, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %y_2, metadata !961, metadata !DIExpression()), !dbg !957
  call void @llvm.dbg.value(metadata double* %A, metadata !962, metadata !DIExpression()), !dbg !957
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !963
  %add = add i32 %mul, %threadIdx.x, !dbg !964
  call void @llvm.dbg.value(metadata i32 %add, metadata !965, metadata !DIExpression()), !dbg !957
  %cmp = icmp slt i32 %add, %n, !dbg !966
  br i1 %cmp, label %if.then, label %if.end, !dbg !968

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !969, metadata !DIExpression()), !dbg !957
  %0 = sext i32 %n to i64, !dbg !970
  br label %for.cond, !dbg !970

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !973
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !969, metadata !DIExpression()), !dbg !957
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !974
  br i1 %cmp3, label %for.body, label %for.end, !dbg !976

for.body:                                         ; preds = %for.cond
  %mul4 = mul nsw i32 %add, %n, !dbg !977
  %1 = sext i32 %mul4 to i64, !dbg !978
  %2 = add nsw i64 %1, %indvars.iv, !dbg !978
  %arrayidx = getelementptr inbounds double, double* %A, i64 %2, !dbg !979
  %3 = load double, double* %arrayidx, align 8, !dbg !979
  %arrayidx7 = getelementptr inbounds double, double* %y_1, i64 %indvars.iv, !dbg !980
  %4 = load double, double* %arrayidx7, align 8, !dbg !980
  %mul8 = fmul contract double %3, %4, !dbg !981
  %idxprom9 = sext i32 %add to i64, !dbg !982
  %arrayidx10 = getelementptr inbounds double, double* %x1, i64 %idxprom9, !dbg !982
  %5 = load double, double* %arrayidx10, align 8, !dbg !983
  %add11 = fadd contract double %5, %mul8, !dbg !983
  store double %add11, double* %arrayidx10, align 8, !dbg !983
  br label %for.inc, !dbg !982

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !984
  call void @llvm.dbg.value(metadata i32 undef, metadata !969, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !957
  br label %for.cond, !dbg !985, !llvm.loop !986

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !988

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !989
}

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @kernel_x2(i32 %n, double* %x1, double* %x2, double* %y_1, double* %y_2, double* %A, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #9 {
entry:
  call void @llvm.dbg.value(metadata i32 %n, metadata !990, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x1, metadata !993, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %x2, metadata !994, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_1, metadata !995, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %y_2, metadata !996, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.value(metadata double* %A, metadata !997, metadata !DIExpression()), !dbg !992
  %mul = mul i32 %blockDim.x, %blockIdx.x, !dbg !998
  %add = add i32 %mul, %threadIdx.x, !dbg !999
  call void @llvm.dbg.value(metadata i32 %add, metadata !1000, metadata !DIExpression()), !dbg !992
  %cmp = icmp slt i32 %add, %n, !dbg !1001
  br i1 %cmp, label %if.then, label %if.end, !dbg !1003

if.then:                                          ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !1004, metadata !DIExpression()), !dbg !992
  %0 = sext i32 %n to i64, !dbg !1005
  %1 = sext i32 %n to i64, !dbg !1005
  %2 = sext i32 %add to i64, !dbg !1005
  br label %for.cond, !dbg !1005

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ], !dbg !1008
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1004, metadata !DIExpression()), !dbg !992
  %cmp3 = icmp slt i64 %indvars.iv, %0, !dbg !1009
  br i1 %cmp3, label %for.body, label %for.end, !dbg !1011

for.body:                                         ; preds = %for.cond
  %3 = mul nsw i64 %indvars.iv, %1, !dbg !1012
  %4 = add nsw i64 %3, %2, !dbg !1013
  %arrayidx = getelementptr inbounds double, double* %A, i64 %4, !dbg !1014
  %5 = load double, double* %arrayidx, align 8, !dbg !1014
  %arrayidx7 = getelementptr inbounds double, double* %y_2, i64 %indvars.iv, !dbg !1015
  %6 = load double, double* %arrayidx7, align 8, !dbg !1015
  %mul8 = fmul contract double %5, %6, !dbg !1016
  %idxprom9 = sext i32 %add to i64, !dbg !1017
  %arrayidx10 = getelementptr inbounds double, double* %x2, i64 %idxprom9, !dbg !1017
  %7 = load double, double* %arrayidx10, align 8, !dbg !1018
  %add11 = fadd contract double %7, %mul8, !dbg !1018
  store double %add11, double* %arrayidx10, align 8, !dbg !1018
  br label %for.inc, !dbg !1017

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1019
  call void @llvm.dbg.value(metadata i32 undef, metadata !1004, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !992
  br label %for.cond, !dbg !1020, !llvm.loop !1021

for.end:                                          ; preds = %for.cond
  br label %if.end, !dbg !1023

if.end:                                           ; preds = %for.end, %entry
  ret void, !dbg !1024
}

SUSAN: currGlob: @stderr = external dso_local global %struct._IO_FILE*, align 8
SUSAN: currGlob: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [7 x i8] c"%0.2lf\00", align 1
CBackend: writeOperand 3595: [7 x i8] c"%0.2lf\00"
CBackend: writeoperand here 3674? 
SUSAN: currGlob: @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
SUSAN: getting value name for: @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
SUSAN: getting value name for: @.str.1 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
CBackend: writeOperand 3595: [2 x i8] c"\0A\00"
CBackend: writeoperand here 3674? 
