{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize the temporary array tmp across all ni*nj elements, preparing for later matrix operations"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num/factor): the number of blocks of size 'factor' needed to cover 'num' items"
    },
    {
      "id": "unknown_FUNCTION_kernel_A_mul_B",
      "original": "// INSERT COMMENT FUNCTION: kernel_A_mul_B",
      "replacement": "// GPU-style kernel: each thread computes one (i,j) dot product over k for A*B and writes the result into tmp, with bounds checks"
    },
    {
      "id": "unknown_FUNCTION_kernel_D_plus_tmp_mul_C",
      "original": "// INSERT COMMENT FUNCTION: kernel_D_plus_tmp_mul_C",
      "replacement": "// GPU-style kernel: each thread updates one D(i,l) element as beta*D(i,l) plus the dot product of tmp(i,*) and C(*,l), with bounds checks"
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Host driver that configures grid/block dimensions and launches the compute kernels to perform the matrix multiply-and-accumulate"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print all elements of matrix D (size ni by nl) to stderr for verification"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over i in [0, ni) and j in [0, nj) to set each element of tmp to zero"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over i in [0, ni) and j in [0, nj) to set each element of tmp to zero"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over i in [0, ni) and j in [0, nj) to set each element of tmp to zero"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over i in [0, ni) and j in [0, nj) to set each element of tmp to zero"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Nested loops over i in [0, ni) and j in [0, nj) to set each element of tmp to zero"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// Parallelize over the 2D grid of blocks (x and y dimensions), assigning work for each block index pair"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// Parallelize over the 2D grid of blocks (x and y dimensions), assigning work for each block index pair"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Traverse D by rows (i) and columns (j) and print each value using the specified format"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line arguments: dump flag and matrix dimensions ni, nj, nk, and nl"
    },
    {
      "id": "unknown_IFELSE_kernel_A_mul_B::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_A_mul_B::entry",
      "replacement": "// Compute output indices from thread/block IDs; if within [0,ni)\u00d7[0,nj), initialize and accumulate the A*B dot product over k"
    },
    {
      "id": "unknown_IFELSE_kernel_D_plus_tmp_mul_C::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_D_plus_tmp_mul_C::entry",
      "replacement": "// Compute indices (i,l) from thread/block IDs; if valid, start with beta*D(i,l) and accumulate contributions of tmp*C over j"
    }
  ]
}