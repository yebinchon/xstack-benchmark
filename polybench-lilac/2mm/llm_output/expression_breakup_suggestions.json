{
  "function_name": "init_array",
  "breakups": [
    {
      "line_number": 168,
      "original_expression": "A[(i * ni + j)] = (((double)(i) * (double)(j)) / (double)(ni));",
      "breakup_steps": [
        {
          "temp_var": "a_idx",
          "expression": "i * ni + j",
          "description": "Compute linearized index into A"
        },
        {
          "temp_var": "a_num",
          "expression": "((double)i) * ((double)j)",
          "description": "Compute numerator as product in double precision"
        },
        {
          "temp_var": "a_den",
          "expression": "(double)ni",
          "description": "Convert denominator to double"
        },
        {
          "temp_var": "a_val",
          "expression": "a_num / a_den",
          "description": "Compute final value to store in A"
        }
      ],
      "final_expression": "A[a_idx] = a_val;"
    },
    {
      "line_number": 174,
      "original_expression": "B[(i * nk + j)] = (((double)(i) * (double)((j + INIT_B_J_OFFSET))) / (double)(nj));",
      "breakup_steps": [
        {
          "temp_var": "b_idx",
          "expression": "i * nk + j",
          "description": "Compute linearized index into B"
        },
        {
          "temp_var": "b_j_offset",
          "expression": "j + INIT_B_J_OFFSET",
          "description": "Apply B's j offset before casting"
        },
        {
          "temp_var": "b_num",
          "expression": "((double)i) * ((double)b_j_offset)",
          "description": "Compute numerator as product in double precision"
        },
        {
          "temp_var": "b_den",
          "expression": "(double)nj",
          "description": "Convert denominator to double"
        },
        {
          "temp_var": "b_val",
          "expression": "b_num / b_den",
          "description": "Compute final value to store in B"
        }
      ],
      "final_expression": "B[b_idx] = b_val;"
    },
    {
      "line_number": 180,
      "original_expression": "C[(i * nl + j)] = (((double)(i) * (double)((j + INIT_C_J_OFFSET))) / (double)(nl));",
      "breakup_steps": [
        {
          "temp_var": "c_idx",
          "expression": "i * nl + j",
          "description": "Compute linearized index into C"
        },
        {
          "temp_var": "c_j_offset",
          "expression": "j + INIT_C_J_OFFSET",
          "description": "Apply C's j offset before casting"
        },
        {
          "temp_var": "c_num",
          "expression": "((double)i) * ((double)c_j_offset)",
          "description": "Compute numerator as product in double precision"
        },
        {
          "temp_var": "c_den",
          "expression": "(double)nl",
          "description": "Convert denominator to double"
        },
        {
          "temp_var": "c_val",
          "expression": "c_num / c_den",
          "description": "Compute final value to store in C"
        }
      ],
      "final_expression": "C[c_idx] = c_val;"
    },
    {
      "line_number": 186,
      "original_expression": "D[(i * ni + j)] = (((double)(i) * (double)((j + INIT_D_J_OFFSET))) / (double)(nk));",
      "breakup_steps": [
        {
          "temp_var": "d_idx",
          "expression": "i * ni + j",
          "description": "Compute linearized index into D"
        },
        {
          "temp_var": "d_j_offset",
          "expression": "j + INIT_D_J_OFFSET",
          "description": "Apply D's j offset before casting"
        },
        {
          "temp_var": "d_num",
          "expression": "((double)i) * ((double)d_j_offset)",
          "description": "Compute numerator as product in double precision"
        },
        {
          "temp_var": "d_den",
          "expression": "(double)nk",
          "description": "Convert denominator to double"
        },
        {
          "temp_var": "d_val",
          "expression": "d_num / d_den",
          "description": "Compute final value to store in D"
        }
      ],
      "final_expression": "D[d_idx] = d_val;"
    }
  ]
}