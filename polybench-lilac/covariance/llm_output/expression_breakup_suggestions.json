{
  "function_name": "kernel_cov",
  "breakups": [
    {
      "line_number": 198,
      "original_expression": "cov[(i * m + j)] = (cov[(i * m + j)] + (data[(k * m + i)] * data[(k * m + j)]));",
      "breakup_steps": [
        {
          "temp_var": "idx_ij",
          "expression": "i * m + j",
          "description": "Compute flattened index for element (i, j) in cov"
        },
        {
          "temp_var": "row_k",
          "expression": "k * m",
          "description": "Compute base index for row k in data"
        },
        {
          "temp_var": "data_ki",
          "expression": "data[row_k + i]",
          "description": "Load data element at (k, i)"
        },
        {
          "temp_var": "data_kj",
          "expression": "data[row_k + j]",
          "description": "Load data element at (k, j)"
        },
        {
          "temp_var": "prod_ik_jk",
          "expression": "data_ki * data_kj",
          "description": "Multiply the two data elements"
        },
        {
          "temp_var": "updated_cov",
          "expression": "cov[idx_ij] + prod_ik_jk",
          "description": "Accumulate product into current covariance entry"
        }
      ],
      "final_expression": "cov[idx_ij] = updated_cov;"
    },
    {
      "line_number": 200,
      "original_expression": "cov[(i * m + j)] = (cov[(i * m + j)] / ((double)(n) - COV_BESSEL_CORRECTION));",
      "breakup_steps": [
        {
          "temp_var": "idx_ij",
          "expression": "i * m + j",
          "description": "Compute flattened index for element (i, j) in cov"
        },
        {
          "temp_var": "denom",
          "expression": "(double)n - COV_BESSEL_CORRECTION",
          "description": "Compute denominator once for clarity"
        },
        {
          "temp_var": "scaled_cov",
          "expression": "cov[idx_ij] / denom",
          "description": "Apply scaling to covariance entry"
        }
      ],
      "final_expression": "cov[idx_ij] = scaled_cov;"
    },
    {
      "line_number": 201,
      "original_expression": "cov[(j * m + i)] = cov[(i * m + j)];",
      "breakup_steps": [
        {
          "temp_var": "idx_ij",
          "expression": "i * m + j",
          "description": "Index for (i, j)"
        },
        {
          "temp_var": "idx_ji",
          "expression": "j * m + i",
          "description": "Index for (j, i) to enforce symmetry"
        },
        {
          "temp_var": "cov_ij",
          "expression": "cov[idx_ij]",
          "description": "Load the computed covariance value"
        }
      ],
      "final_expression": "cov[idx_ji] = cov_ij;"
    }
  ]
}