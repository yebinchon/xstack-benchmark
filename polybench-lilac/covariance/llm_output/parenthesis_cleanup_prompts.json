{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 91 potential parentheses to evaluate:\n\nLine 181: // INSERT COMMENT FUNCTION: kernel_mean\n  Potential parentheses to evaluate: (uint8_t*)\nLine 369: \n  Potential parentheses to evaluate: (noinline), (noinline), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[1]), (argv[2]), (argv[3]), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (j), (double), (n), (double), (uint32_t num, uint32_t factor), (m, 256), (uint8_t*), (&mean_grid_packed_alias), (uint8_t*), (&mean_grid_dim), (uint8_t*), (&mean_block_packed), (uint8_t*), (&mean_block_dim), (2), (m, n, data, cov, mean, num_blocks_m_256, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0), (n, block.x), (m, block.y), (uint8_t*), (&reduce_block_dim), (uint8_t*), (&block), (uint8_t*), (&reduce_grid_dim), (uint8_t*), (&grid), (uint8_t*), (&reduce_block_packed), (uint8_t*), (&reduce_block_dim), (uint8_t*), (&reduce_grid_packed), (uint8_t*), (&reduce_grid_dim), (2), (m, n, data, cov, mean, 8, 32, 1, num_blocks_n_blockx, num_blocks_m_blocky, 1, i, j, 0, k, l, 0), (uint8_t*), (&cov_block_dim), (uint8_t*), (&block), (uint8_t*), (&cov_grid_dim), (uint8_t*), (&grid), (uint8_t*), (&cov_block_packed), (uint8_t*), (&cov_block_dim), (uint8_t*), (&cov_grid_packed), (uint8_t*), (&cov_grid_dim), (2), (m, n, data, cov, mean, 8, 32, 1, num_blocks_mminus1_blockx, num_blocks_mminus1_blocky, 1, i, j, 0, k, l, 0), (print_fmt_double), (int), (int), (print_fmt_newline), (print_fmt_newline)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct IOFile;\nstruct dim3_t;\nstruct dim3_packed_t;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array_1_t {\n  uint8_t array[1];\n};\nstruct uint8_array_20_t {\n  uint8_t array[20];\n};\nstruct IOFile {\n  uint32_t io_file_flags;\n  uint8_t* io_file_buf_base;\n  uint8_t* io_file_buf_ptr;\n  uint8_t* io_file_buf_end;\n  uint8_t* io_file_buf1;\n  uint8_t* io_file_buf2;\n  uint8_t* io_file_buf3;\n  uint8_t* io_file_buf4;\n  uint8_t* io_file_buf5;\n  uint8_t* io_file_buf6;\n  uint8_t* io_file_buf7;\n  uint8_t* io_file_buf8;\n  void* io_file_cookie;\n  struct IOFile* io_file_prev;\n  uint32_t io_file_mode;\n  uint32_t io_file_line_no;\n  uint64_t io_file_offset;\n  uint16_t io_file_wide_data;\n  uint8_t io_file_ungetc;\n  uint8_t io_file_small_buf[1];\n  uint8_t* io_file_name;\n  uint64_t io_file_lock;\n  void* io_file_lock2;\n  void* io_file_reserved;\n  struct IOFile* io_file_next;\n  uint8_t* io_file_buf_alloc;\n  uint64_t io_file_cookie2;\n  uint32_t io_file_pad;\n  uint8_t io_file_gap[20];\n};\nstruct dim3_t {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct dim3_packed_t {\n  uint64_t dim3_packed_field0;\n  uint32_t dim3_packed_field1;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, uint32_t, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_mean(uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_reduce(uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_cov(uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t print_fmt_double[8] = { \"%0.2lf \" };\nuint8_t print_fmt_newline[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t n;\n  int32_t m;\n  uint8_t* data;\n  uint8_t* mean;\n  uint8_t* cov;\n  int32_t unused_var28;\n  int32_t unused_var39;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[1]);\n  n = atoi(argv[2]);\n  m = atoi(argv[3]);\n  data = malloc(n * m * 8);\n  mean = malloc(m * 8);\n  cov = malloc(m * m * 8);\n  init_array(m, n, ((double*)data));\n;\n  kernel(m, n, ((double*)data), ((double*)cov), ((double*)mean));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(m, ((double*)cov));\n  }\nfree(((uint8_t*)((double*)data)));\nfree(((uint8_t*)((double*)cov)));\nfree(((uint8_t*)((double*)mean)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t m, uint32_t n, double* data) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\nfor(int64_t j = 0; j < m;   j = j + 1){\n  data[(i * m + j)] = (((double)(i) * (double)(j)) / 1000);\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_mean\nvoid kernel_mean(uint32_t m, uint32_t n, double* data, double* cov, double* mean, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t j;\n  int64_t i;\n\n// INSERT COMMENT IFELSE: kernel_mean::entry\n  j = blockDim_x * blockIdx_x + threadIdx_x;\n  if (j < m) { // IFELSE MARKER: entry IF\n  mean[j] = 0;\nfor(int64_t i = 0; i < n;   i = i + 1){\n  mean[j] = (mean[j] + data[(i * m + j)]);\n}\n  mean[j] = (mean[j] / (double)(n));\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_reduce\nvoid kernel_reduce(uint32_t m, uint32_t n, double* data, double* cov, double* mean, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_reduce::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < n) { // IFELSE MARKER: entry IF\n  if (j < m) { // IFELSE MARKER: land.lhs.true IF\n  data[(i * m + j)] = (data[(i * m + j)] - mean[j]);\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_cov\nvoid kernel_cov(uint32_t m, uint32_t n, double* data, double* cov, double* mean, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n  int64_t k;\n\n// INSERT COMMENT IFELSE: kernel_cov::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y + i;\n  if (i < m) { // IFELSE MARKER: entry IF\n  if (j < m) { // IFELSE MARKER: land.lhs.true IF\n  cov[(i * m + j)] = 0;\nfor(int64_t k = 0; k < n;   k = k + 1){\n  __auto_type tmp1 = i * m + j;\n  __auto_type tmp2 = k * m + i;\n  __auto_type tmp3 = k * m + j;\n  __auto_type tmp4 = data[tmp2];\n  __auto_type tmp5 = data[tmp3];\n  __auto_type tmp6 = tmp4 * tmp5;\n  __auto_type tmp7 = cov[tmp1] + tmp6;\n  __auto_type tmp8 = cov[tmp1] = tmp7;\n  cov[(i * m + j)] = tmp6;\n}\n  __auto_type tmp9 = i * m + j;\n  __auto_type tmp10 = (double)n - 1;\n  __auto_type tmp11 = cov[tmp9] / tmp10;\n  __auto_type tmp12 = cov[tmp9] = tmp11;\n  cov[(i * m + j)] = tmp10;\n  __auto_type tmp13 = j * m + i;\n  __auto_type tmp14 = i * m + j;\n  __auto_type tmp15 = cov[tmp13] = cov[tmp14];\n  cov[(j * m + i)] = cov[tmp14];\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t m, uint32_t n, double* data, double* cov, double* mean) {\n  struct dim3_t mean_grid_dim;    /* Address-exposed local */\n  struct dim3_t mean_block_dim;    /* Address-exposed local */\n  struct dim3_packed_t mean_grid_packed_alias;    /* Address-exposed local */\n  struct dim3_packed_t mean_block_packed;    /* Address-exposed local */\n  struct dim3_t block;    /* Address-exposed local */\n  struct dim3_t grid;    /* Address-exposed local */\n  struct dim3_t reduce_block_dim;    /* Address-exposed local */\n  struct dim3_t reduce_grid_dim;    /* Address-exposed local */\n  struct dim3_packed_t reduce_block_packed;    /* Address-exposed local */\n  struct dim3_packed_t reduce_grid_packed;    /* Address-exposed local */\n  struct dim3_t cov_block_dim;    /* Address-exposed local */\n  struct dim3_t cov_grid_dim;    /* Address-exposed local */\n  struct dim3_packed_t cov_block_packed;    /* Address-exposed local */\n  struct dim3_packed_t cov_grid_packed;    /* Address-exposed local */\n  int32_t num_blocks_m_256;\n  uint8_t* tmp_u8_ptr1;\n  uint8_t* tmp_u8_ptr2;\n  uint32_t i;\n  uint32_t j;\n  int32_t num_blocks_n_blockx;\n  int32_t num_blocks_m_blocky;\n  uint8_t* tmp_u8_ptr3;\n  uint8_t* tmp_u8_ptr4;\n  uint8_t* tmp_u8_ptr5;\n  uint8_t* tmp_u8_ptr6;\n  uint32_t k;\n  uint32_t l;\n  int32_t num_blocks_mminus1_blockx;\n  int32_t num_blocks_mminus1_blocky;\n  uint8_t* tmp_u8_ptr7;\n  uint8_t* tmp_u8_ptr8;\n  uint8_t* tmp_u8_ptr9;\n  uint8_t* tmp_u8_ptr10;\n\n  num_blocks_m_256 = num_blocks(m, 256);\n  mean_grid_dim.x = num_blocks_m_256;\n  mean_grid_dim.y = 1;\n  mean_grid_dim.z = 1;\n  mean_block_dim.x = 256;\n  mean_block_dim.y = 1;\n  mean_block_dim.z = 1;\n  memcpy(((uint8_t*)(&mean_grid_packed_alias)), ((uint8_t*)(&mean_grid_dim)), 12);\n  memcpy(((uint8_t*)(&mean_block_packed)), ((uint8_t*)(&mean_block_dim)), 12);\n// INSERT COMMENT LOOP: kernel::header.016\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_m_256;   i = i + 1){\nfor(int32_t j = 0; j < 256;   j = j + 1){\nkernel_mean(m, n, data, cov, mean, num_blocks_m_256, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  num_blocks_n_blockx = num_blocks(n, block.x);\n  num_blocks_m_blocky = num_blocks(m, block.y);\n  grid.x = num_blocks_n_blockx;\n  grid.y = num_blocks_m_blocky;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&reduce_block_dim)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&reduce_grid_dim)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&reduce_block_packed)), ((uint8_t*)(&reduce_block_dim)), 12);\n  memcpy(((uint8_t*)(&reduce_grid_packed)), ((uint8_t*)(&reduce_grid_dim)), 12);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < 8;   i = i + 1){\nfor(int32_t j = 0; j < 32;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_n_blockx;   k = k + 1){\nfor(int32_t l = 0; l < num_blocks_m_blocky;   l = l + 1){\nkernel_reduce(m, n, data, cov, mean, 8, 32, 1, num_blocks_n_blockx, num_blocks_m_blocky, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  block.x = 8;\n  block.y = 32;\n  block.z = 1;\n  num_blocks_mminus1_blockx = num_blocks((m - 1), block.x);\n  num_blocks_mminus1_blocky = num_blocks((m - 1), block.y);\n  grid.x = num_blocks_mminus1_blockx;\n  grid.y = num_blocks_mminus1_blocky;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&cov_block_dim)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&cov_grid_dim)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&cov_block_packed)), ((uint8_t*)(&cov_block_dim)), 12);\n  memcpy(((uint8_t*)(&cov_grid_packed)), ((uint8_t*)(&cov_grid_dim)), 12);\n// INSERT COMMENT LOOP: kernel::header.026\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < 8;   i = i + 1){\nfor(int32_t j = 0; j < 32;   j = j + 1){\nfor(int32_t k = 0; k < num_blocks_mminus1_blockx;   k = k + 1){\nfor(int32_t l = 0; l < num_blocks_mminus1_blocky;   l = l + 1){\nkernel_cov(m, n, data, cov, mean, 8, 32, 1, num_blocks_mminus1_blockx, num_blocks_mminus1_blocky, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t m, double* cov) {\n  int64_t i;\n  uint64_t j;\n  int32_t tmp_int32;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < m;   i = i + 1){\nfor(int64_t j = 0; j < m;   j = j + 1){\n  fprintf(stderr, (print_fmt_double), cov[(i * m + j)]);\n  if ((int)(i * m + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (print_fmt_newline));\n  }\n}\n}\n  fprintf(stderr, (print_fmt_newline));\n}\n\n```"
}