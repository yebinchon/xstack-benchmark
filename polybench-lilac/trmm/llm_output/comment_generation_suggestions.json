{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize scalar alpha and populate matrices A (m x m) and B (m x n) with deterministic values based on indices to prepare data for the computation."
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return the number of blocks needed to cover 'num' items with block size 'factor' using ceiling division."
    },
    {
      "id": "unknown_FUNCTION_kernel_contract",
      "original": "// INSERT COMMENT FUNCTION: kernel_contract",
      "replacement": "// GPU-style kernel: each thread maps to a global column j and updates B(:,j) by accumulating A[k,i] * B[k,j] for k from i to m-1, performing a contraction over k for each row i."
    },
    {
      "id": "unknown_FUNCTION_kernel_alpha",
      "original": "// INSERT COMMENT FUNCTION: kernel_alpha",
      "replacement": "// GPU-style kernel: compute global (i,j) from block/thread indices and, if in bounds, scale the single B[i,j] element by the scalar alpha."
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Host wrapper that configures grid/block dimensions and launches/emulates the two GPU kernels (alpha scaling and contraction), using OpenMP to parallelize on the CPU."
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the matrix B with m rows and n columns to stderr in row-major order using the predefined format string for verification/debugging."
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over all i (0..n-1) and j (0..m-1) positions to compute a linear index and initialize corresponding entries of A and B."
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < blocks_m_blockx;   i = i + 1){\nfor(int32_t j = 0; j < blocks_n_blocky;   j = j + 1){",
      "replacement": "// Parallel over 2D block-grid coordinates: iterate all block indices in the x/y dimensions (collapsed) to emulate launching work for each block."
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < blocks_m_blockx;   i = i + 1){\nfor(int32_t j = 0; j < blocks_n_blocky;   j = j + 1){",
      "replacement": "// Parallel over 2D block-grid coordinates: iterate all block indices in the x/y dimensions (collapsed) to emulate launching work for each block."
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Loop over rows i and columns j to print each element B[i*n + j] in row-major order to stderr using the format string."
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line arguments for dump_code, n and m, then allocate memory for arrays A and B (space for n*m doubles each) without additional validation."
    },
    {
      "id": "unknown_IFELSE_kernel_contract::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_contract::entry",
      "replacement": "// Compute the global column index j for this thread; if j is within [0,n) perform nested loops over i and k to accumulate contributions A[k,i]*B[k,j] into B[i,j] (k from i to m-1)."
    },
    {
      "id": "unknown_IFELSE_kernel_alpha::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_alpha::entry",
      "replacement": "// Compute global indices (i,j) from block/thread coordinates; if both indices are within bounds, multiply the element B[i*n + j] by alpha."
    }
  ]
}