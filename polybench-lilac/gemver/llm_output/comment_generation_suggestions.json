{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize problem-size-n arrays (matrix/vector inputs) with deterministic values for subsequent linear-algebra kernels"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num / factor): the number of blocks required to cover 'num' items with block size 'factor'"
    },
    {
      "id": "unknown_FUNCTION_kernel_A",
      "original": "// INSERT COMMENT FUNCTION: kernel_A",
      "replacement": "// CUDA-style kernel that applies a rank-2 update A[i,j] += u1[i]*v1[j] + u2[i]*v2[j] using 2D thread/block indices with bounds checks"
    },
    {
      "id": "unknown_FUNCTION_kernel_x",
      "original": "// INSERT COMMENT FUNCTION: kernel_x",
      "replacement": "// CUDA-style kernel that computes x[i] += beta * sum_j A[j*n + i] * y[j] (i.e., x = x + beta * A^T y) for in-range i"
    },
    {
      "id": "unknown_FUNCTION_kernel_y",
      "original": "// INSERT COMMENT FUNCTION: kernel_y",
      "replacement": "// CUDA-style kernel that performs an element-wise vector add: x[i] += z[i] for threads with valid i"
    },
    {
      "id": "unknown_FUNCTION_kernel_w",
      "original": "// INSERT COMMENT FUNCTION: kernel_w",
      "replacement": "// CUDA-style kernel that computes w[i] += alpha * sum_j A[i*n + j] * x[j] (i.e., w = w + alpha * A x) for valid i"
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Host driver that configures grid/block dimensions and launches the compute kernels in sequence"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the n-element vector w to stderr using a fixed format and periodic line breaks for readability"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate i over [0, n) to seed inputs: set u1[i] = i and u2[i] = ((i+1)/n)/INIT_U2_DIVISOR for reproducible values"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block indices (i) and 256 thread slots (j) to emulate a 1D GPU launch along x"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block indices (i) and 256 thread slots (j) to emulate a 1D GPU launch along x"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block indices (i) and 256 thread slots (j) to emulate a 1D GPU launch along x"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block indices (i) and 256 thread slots (j) to emulate a 1D GPU launch along x"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Walk over w[0..n-1], printing each value and inserting a newline every 20 elements"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse problem size and dump flag from argv, then allocate memory for A, u1, v1 (and subsequent arrays)"
    },
    {
      "id": "unknown_IFELSE_kernel_A::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_A::entry",
      "replacement": "// Compute (i,j) from block/thread indices; if i,j are within [0,n), update A[i,j] by u1[i]*v1[j] + u2[i]*v2[j]"
    },
    {
      "id": "unknown_IFELSE_kernel_x::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_x::entry",
      "replacement": "// Compute global index i; if i < n, accumulate x[i] by beta times the dot product of column i of A with y (A^T y)"
    },
    {
      "id": "unknown_IFELSE_kernel_y::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_y::entry",
      "replacement": "// Compute global index i; if i < n, add z[i] to x[i], then return"
    },
    {
      "id": "unknown_IFELSE_kernel_w::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_w::entry",
      "replacement": "// Compute global index i; if i < n, accumulate w[i] by alpha times the dot product of row i of A with x (A x)"
    }
  ]
}