{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 124 potential parentheses to evaluate:\n\nLine 404: \n  Potential parentheses to evaluate: (noinline), (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (int32_t a, int32_t b), (uint32_t a, uint32_t b), (argv[2]), (argv[1]), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (n, A_dbl, u1_dbl, v1_dbl, u2_dbl, v2_dbl, w_dbl, x_dbl, y_dbl, z_dbl), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (n, 43532, 12313, A_dbl2, u1_dbl2, v1_dbl2, u2_dbl2, v2_dbl2, w_dbl2, x_dbl2, y_dbl2, z_dbl2), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (i), (double), (double), (double), (double), (double), (double), (i), (double), (j), (double), (n), (uint32_t num, uint32_t factor), (n, block.dim3_x), (n, block.dim3_y), (uint8_t*), (&grid_tmp), (uint8_t*), (&grid), (uint8_t*), (&block_tmp4), (uint8_t*), (&block), (uint8_t*), (&grid_tmp_coerce), (uint8_t*), (&grid_tmp), (uint8_t*), (&block_tmp4_coerce), (uint8_t*), (&block_tmp4), (2), (n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, grid_blocks_x, grid_blocks_y, 1, 8, 32, 1, i, j, 0, k, l, 0), (n, 256), (uint8_t*), (&grid_tmp6_coerce), (uint8_t*), (&grid_tmp6), (uint8_t*), (&block_tmp8_coerce), (uint8_t*), (&block_tmp8), (2), (n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_x, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0), (n, 256), (uint8_t*), (&grid_tmp13_coerce), (uint8_t*), (&grid_tmp13), (uint8_t*), (&block_tmp15_coerce), (uint8_t*), (&block_tmp15), (2), (n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_y, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0), (n, 256), (uint8_t*), (&grid_tmp20_coerce), (uint8_t*), (&grid_tmp20), (uint8_t*), (&block_tmp22_coerce), (uint8_t*), (&block_tmp22), (2), (n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_w, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0), (double_format_str), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct IOFile;\nstruct Dim3;\nstruct Dim3Coerce;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array_1 {\n  uint8_t array[1];\n};\nstruct uint8_array_20 {\n  uint8_t array[20];\n};\nstruct IOFile {\n  uint32_t flags;\n  uint8_t* read_ptr;\n  uint8_t* read_end;\n  uint8_t* write_base;\n  uint8_t* write_ptr;\n  uint8_t* buf_base;\n  uint8_t* buf_end;\n  uint8_t* save_base;\n  uint8_t* save_end;\n  uint8_t* marker;\n  uint8_t* tmpbuf;\n  uint8_t* linebuf;\n  void* cookie;\n  struct IOFile* chain;\n  uint32_t fileno;\n  uint32_t mode;\n  uint64_t offset;\n  uint16_t short_flags;\n  uint8_t eof_char;\n  uint8_t tinybuf[1];\n  uint8_t* buffer;\n  uint64_t data_offset;\n  void* vtable;\n  void* codec;\n  struct IOFile* next;\n  uint8_t* curbuf;\n  uint64_t cookie2;\n  uint32_t linebuf_size;\n  uint8_t reserved[20];\n};\nstruct Dim3 {\n  uint32_t dim3_x;\n  uint32_t dim3_y;\n  uint32_t dim3_z;\n};\nstruct Dim3Coerce {\n  uint64_t dim3coerce_field0;\n  uint32_t dim3coerce_field1;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, double*, double*, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_A(uint32_t, double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_x(uint32_t, double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_y(uint32_t, double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_w(uint32_t, double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t double_format_str[8] = { \"%0.2lf \" };\nuint8_t newline_str[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_urem_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t n;\n  int32_t dump_code;\n  uint8_t* A;\n  uint8_t* u1;\n  uint8_t* v1;\n  uint8_t* u2;\n  uint8_t* v2;\n  uint8_t* w;\n  uint8_t* x;\n  uint8_t* y;\n  uint8_t* z;\n  int32_t call62_result;\n  int32_t call89_result;\n\n// INSERT COMMENT IFELSE: main::entry\n  n = atoi(argv[2]);\n  dump_code = atoi(argv[1]);\n  A = malloc(n * n * 8);\n  u1 = malloc(n * 8);\n  v1 = malloc(n * 8);\n  u2 = malloc(n * 8);\n  v2 = malloc(n * 8);\n  w = malloc(n * 8);\n  x = malloc(n * 8);\n  y = malloc(n * 8);\n  z = malloc(n * 8);\n  __auto_type A_dbl = (double*)A;\n  __auto_type u1_dbl = (double*)u1;\n  __auto_type v1_dbl = (double*)v1;\n  __auto_type u2_dbl = (double*)u2;\n  __auto_type v2_dbl = (double*)v2;\n  __auto_type w_dbl = (double*)w;\n  __auto_type x_dbl = (double*)x;\n  __auto_type y_dbl = (double*)y;\n  __auto_type z_dbl = (double*)z;\n  init_array(n, A_dbl, u1_dbl, v1_dbl, u2_dbl, v2_dbl, w_dbl, x_dbl, y_dbl, z_dbl);\n;\n  __auto_type A_dbl2 = (double*)A;\n  __auto_type u1_dbl2 = (double*)u1;\n  __auto_type v1_dbl2 = (double*)v1;\n  __auto_type u2_dbl2 = (double*)u2;\n  __auto_type v2_dbl2 = (double*)v2;\n  __auto_type w_dbl2 = (double*)w;\n  __auto_type x_dbl2 = (double*)x;\n  __auto_type y_dbl2 = (double*)y;\n  __auto_type z_dbl2 = (double*)z;\n  kernel(n, 43532, 12313, A_dbl2, u1_dbl2, v1_dbl2, u2_dbl2, v2_dbl2, w_dbl2, x_dbl2, y_dbl2, z_dbl2);\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(n, ((double*)w));\n  }\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)u1)));\nfree(((uint8_t*)((double*)v1)));\nfree(((uint8_t*)((double*)u2)));\nfree(((uint8_t*)((double*)v2)));\nfree(((uint8_t*)((double*)w)));\nfree(((uint8_t*)((double*)x)));\nfree(((uint8_t*)((double*)y)));\nfree(((uint8_t*)((double*)z)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t n, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z) {\n  int64_t i;\n  uint64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  u1[i] = (double)(i);\n  u2[i] = ((double)((i + 1) / n) / 2);\n  v1[i] = ((double)((i + 1) / n) / 4);\n  v2[i] = ((double)((i + 1) / n) / 6);\n  y[i] = ((double)((i + 1) / n) / 8);\n  z[i] = ((double)((i + 1) / n) / 9);\n  x[i] = 0;\n  w[i] = 0;\nfor(int64_t j = 0; j < n;   j = j + 1){\n  A[(i * n + j)] = (((double)(i) * (double)(j)) / (double)(n));\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_A\nvoid kernel_A(uint32_t n, double alpha, double beta, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_A::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < n) { // IFELSE MARKER: entry IF\n  if (j < n) { // IFELSE MARKER: land.lhs.true IF\n  A[(i * n + j)] = (A[(i * n + j)] + ((u1[i] * v1[j]) + (u2[i] * v2[j])));\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_x\nvoid kernel_x(uint32_t n, double alpha, double beta, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_x::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\nfor(int64_t j = 0; j < n;   j = j + 1){\n  x[i] = (x[i] + ((beta * A[(j * n + i)]) * y[j]));\n}\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_y\nvoid kernel_y(uint32_t n, double alpha, double beta, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n\n// INSERT COMMENT IFELSE: kernel_y::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\n  x[i] = (x[i] + z[i]);\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel_w\nvoid kernel_w(uint32_t n, double alpha, double beta, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT IFELSE: kernel_w::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  if (i < n) { // IFELSE MARKER: entry IF\nfor(int64_t j = 0; j < n;   j = j + 1){\n  w[i] = (w[i] + ((alpha * A[(i * n + j)]) * x[j]));\n}\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t n, double alpha, double beta, double* A, double* u1, double* v1, double* u2, double* v2, double* w, double* x, double* y, double* z) {\n  struct Dim3 block;    /* Address-exposed local */\n  struct Dim3 grid;    /* Address-exposed local */\n  struct Dim3 grid_tmp;    /* Address-exposed local */\n  struct Dim3 block_tmp4;    /* Address-exposed local */\n  struct Dim3Coerce grid_tmp_coerce;    /* Address-exposed local */\n  struct Dim3Coerce block_tmp4_coerce;    /* Address-exposed local */\n  struct Dim3 grid_tmp6;    /* Address-exposed local */\n  struct Dim3 block_tmp8;    /* Address-exposed local */\n  struct Dim3Coerce grid_tmp6_coerce;    /* Address-exposed local */\n  struct Dim3Coerce block_tmp8_coerce;    /* Address-exposed local */\n  struct Dim3 grid_tmp13;    /* Address-exposed local */\n  struct Dim3 block_tmp15;    /* Address-exposed local */\n  struct Dim3Coerce grid_tmp13_coerce;    /* Address-exposed local */\n  struct Dim3Coerce block_tmp15_coerce;    /* Address-exposed local */\n  struct Dim3 grid_tmp20;    /* Address-exposed local */\n  struct Dim3 block_tmp22;    /* Address-exposed local */\n  struct Dim3Coerce grid_tmp20_coerce;    /* Address-exposed local */\n  struct Dim3Coerce block_tmp22_coerce;    /* Address-exposed local */\n  int32_t grid_blocks_x;\n  int32_t grid_blocks_y;\n  uint8_t* byte_ptr1;\n  uint8_t* byte_ptr2;\n  uint8_t* byte_ptr3;\n  uint8_t* byte_ptr4;\n  uint32_t i;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  int32_t blocks_for_x;\n  uint8_t* byte_ptr5;\n  uint8_t* byte_ptr6;\n  int32_t blocks_for_y;\n  uint8_t* byte_ptr7;\n  uint8_t* byte_ptr8;\n  int32_t blocks_for_w;\n  uint8_t* byte_ptr9;\n  uint8_t* byte_ptr10;\n\n  block.dim3_x = 8;\n  block.dim3_y = 32;\n  block.dim3_z = 1;\n  grid_blocks_x = num_blocks(n, block.dim3_x);\n  grid_blocks_y = num_blocks(n, block.dim3_y);\n  grid.dim3_x = grid_blocks_x;\n  grid.dim3_y = grid_blocks_y;\n  grid.dim3_z = 1;\n  memcpy(((uint8_t*)(&grid_tmp)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&block_tmp4)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&grid_tmp_coerce)), ((uint8_t*)(&grid_tmp)), 12);\n  memcpy(((uint8_t*)(&block_tmp4_coerce)), ((uint8_t*)(&block_tmp4)), 12);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < grid_blocks_x;   i = i + 1){\nfor(int32_t j = 0; j < grid_blocks_y;   j = j + 1){\nfor(int32_t k = 0; k < 8;   k = k + 1){\nfor(int32_t l = 0; l < 32;   l = l + 1){\nkernel_A(n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, grid_blocks_x, grid_blocks_y, 1, 8, 32, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  blocks_for_x = num_blocks(n, 256);\n  grid_tmp6.dim3_x = blocks_for_x;\n  grid_tmp6.dim3_y = 1;\n  grid_tmp6.dim3_z = 1;\n  block_tmp8.dim3_x = 256;\n  block_tmp8.dim3_y = 1;\n  block_tmp8.dim3_z = 1;\n  memcpy(((uint8_t*)(&grid_tmp6_coerce)), ((uint8_t*)(&grid_tmp6)), 12);\n  memcpy(((uint8_t*)(&block_tmp8_coerce)), ((uint8_t*)(&block_tmp8)), 12);\n// INSERT COMMENT LOOP: kernel::header.022\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < blocks_for_x;   i = i + 1){\nfor(int32_t j = 0; j < 256;   j = j + 1){\nkernel_x(n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_x, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  blocks_for_y = num_blocks(n, 256);\n  grid_tmp13.dim3_x = blocks_for_y;\n  grid_tmp13.dim3_y = 1;\n  grid_tmp13.dim3_z = 1;\n  block_tmp15.dim3_x = 256;\n  block_tmp15.dim3_y = 1;\n  block_tmp15.dim3_z = 1;\n  memcpy(((uint8_t*)(&grid_tmp13_coerce)), ((uint8_t*)(&grid_tmp13)), 12);\n  memcpy(((uint8_t*)(&block_tmp15_coerce)), ((uint8_t*)(&block_tmp15)), 12);\n// INSERT COMMENT LOOP: kernel::header.032\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < blocks_for_y;   i = i + 1){\nfor(int32_t j = 0; j < 256;   j = j + 1){\nkernel_y(n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_y, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  blocks_for_w = num_blocks(n, 256);\n  grid_tmp20.dim3_x = blocks_for_w;\n  grid_tmp20.dim3_y = 1;\n  grid_tmp20.dim3_z = 1;\n  block_tmp22.dim3_x = 256;\n  block_tmp22.dim3_y = 1;\n  block_tmp22.dim3_z = 1;\n  memcpy(((uint8_t*)(&grid_tmp20_coerce)), ((uint8_t*)(&grid_tmp20)), 12);\n  memcpy(((uint8_t*)(&block_tmp22_coerce)), ((uint8_t*)(&block_tmp22)), 12);\n// INSERT COMMENT LOOP: kernel::header.042\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < blocks_for_w;   i = i + 1){\nfor(int32_t j = 0; j < 256;   j = j + 1){\nkernel_w(n, alpha, beta, A, u1, v1, u2, v2, w, x, y, z, blocks_for_w, 1, 1, 256, 1, 1, i, 0, 0, j, 0, 0);\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t n, double* w) {\n  int64_t i;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < n;   i = i + 1){\n  fprintf(stderr, (double_format_str), w[i]);\n  if (i % 20 == 0) { // IFELSE MARKER: for.body IF\n  fprintf(stderr, (newline_str));\n  }\n}\n  return;\n}\n\n```"
}