{
  "replacements": [
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return the number of blocks required to cover 'num' items with 'factor' items per block (ceiling division)."
    },
    {
      "id": "unknown_FUNCTION_kernel_q",
      "original": "// INSERT COMMENT FUNCTION: kernel_q",
      "replacement": "// Compute q = A^T * r: each logical thread computes the dot product of column i of A with vector r and stores it in q[i]."
    },
    {
      "id": "unknown_FUNCTION_kernel_s",
      "original": "// INSERT COMMENT FUNCTION: kernel_s",
      "replacement": "// Compute s = A * p: each logical thread computes the dot product of row j of A with vector p and stores it in s[j]."
    },
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize matrix A and vectors r and p with deterministic values for reproducible input (r uses i*pi; A and p are filled based on indices)."
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Set up grid/block parameters and run the parallel kernel computations (simulating CUDA kernels on the CPU using OpenMP) to produce s and q from A, p, and r."
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the contents of the output array(s) in a human-readable format, breaking lines for readability (e.g., 20 values per line)."
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over rows i (0..nx-1): initialize r[i] and then enter the inner loop to initialize the corresponding row of A (and related p entries)."
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Iterate over rows i (0..nx-1): initialize r[i] and then enter the inner loop to initialize the corresponding row of A (and related p entries)."
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// Parallel nested loop over block index (0..blocks_m-1) and thread index (0..255): simulate CUDA's thread/block execution model by mapping each (i,j) to a logical thread."
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// Parallel nested loop over block index (0..blocks_m-1) and thread index (0..255): simulate CUDA's thread/block execution model by mapping each (i,j) to a logical thread."
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Iterate over elements of the output array and print each value; insert a line break periodically (every 20 elements) for formatted output."
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Iterate over elements of the output array and print each value; insert a line break periodically (every 20 elements) for formatted output."
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line arguments to get dump_code, m, and n, then allocate memory for the matrix A (m*n doubles) and vector s (n doubles)."
    },
    {
      "id": "unknown_IFELSE_kernel_q::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_q::entry",
      "replacement": "// Compute the global column index i for this thread; if i < n, initialize q[i] and compute the dot product of column i of A with r to produce q[i]."
    },
    {
      "id": "unknown_IFELSE_kernel_s::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_s::entry",
      "replacement": "// Compute the global row index j for this thread; if j < m, initialize s[j] and compute the dot product of row j of A with p to produce s[j]."
    }
  ]
}