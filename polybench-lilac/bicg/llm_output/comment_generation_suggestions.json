{
  "replacements": [
    {
      "id": "init_array_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize input arrays: fill r[0..nx-1], p[0..ny-1], and the nx\u00d7ny matrix A with deterministic values for benchmarking"
    },
    {
      "id": "kernel_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Configure CUDA-like grid/block dimensions and drive the BiCG computation using OpenMP-parallel loops"
    },
    {
      "id": "print_array_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Pretty-print the result vectors s (length ny) and q (length nx) with fixed formatting and periodic line breaks"
    },
    {
      "id": "num_blocks_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num / factor) to determine how many blocks are needed for a given block size"
    },
    {
      "id": "kernel_q_FUNCTION_kernel_q",
      "original": "// INSERT COMMENT FUNCTION: kernel_q",
      "replacement": "// Per-thread worker that computes one element of q as a dot product across the m dimension for index i"
    },
    {
      "id": "kernel_s_FUNCTION_kernel_s",
      "original": "// INSERT COMMENT FUNCTION: kernel_s",
      "replacement": "// Per-thread worker that computes one element of s as a dot product across the n dimension for index j"
    },
    {
      "id": "init_array_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Loop over rows i (0..nx-1): set r[i] and initialize the i-th row of matrix A"
    },
    {
      "id": "init_array_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// For the current row i, iterate columns j (0..ny-1) to assign A[i, j] values (and any per-column init)"
    },
    {
      "id": "kernel_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel iteration over CUDA-style blocks (i) and threads (j), covering all logical threads"
    },
    {
      "id": "kernel_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// For each block i, sweep 256 thread slots j to execute per-thread work within the block"
    },
    {
      "id": "print_array_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Iterate over q, printing each value and inserting a newline after every 20 elements for readability"
    },
    {
      "id": "print_array_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Walk through q and emit formatted output, breaking lines at a 20-value cadence"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse CLI arguments (dump flag, m, n) and allocate host buffers A and s sized to m\u00d7n and n, respectively"
    },
    {
      "id": "kernel_q_IFELSE_kernel_q::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_q::entry",
      "replacement": "// If global thread index i is within n, zero accumulators and compute q[i] via a dot product over m"
    },
    {
      "id": "kernel_s_IFELSE_kernel_s::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_s::entry",
      "replacement": "// If global thread index j is within m, zero accumulators and compute s[j] via a dot product over n"
    }
  ]
}