{
  "replacements": [
    {
      "id": "unknown_FUNCTION_init_array",
      "original": "// INSERT COMMENT FUNCTION: init_array",
      "replacement": "// Initialize problem-sized arrays using the provided dimensions, populating inputs and clearing outputs for subsequent kernels"
    },
    {
      "id": "unknown_FUNCTION_num_blocks",
      "original": "// INSERT COMMENT FUNCTION: num_blocks",
      "replacement": "// Return ceil(num/factor): the number of blocks of size 'factor' required to cover 'num' items"
    },
    {
      "id": "unknown_FUNCTION_kernel_A_mul_B",
      "original": "// INSERT COMMENT FUNCTION: kernel_A_mul_B",
      "replacement": "// CUDA-like 2D kernel that computes C[i,j] as the dot product of row i of A and column j of B using grid/block indices"
    },
    {
      "id": "unknown_FUNCTION_kernel",
      "original": "// INSERT COMMENT FUNCTION: kernel",
      "replacement": "// Configure launch geometry and orchestrate matrix-multiply sub-kernels, using OpenMP to emulate a GPU-style 2D block grid"
    },
    {
      "id": "unknown_FUNCTION_print_array",
      "original": "// INSERT COMMENT FUNCTION: print_array",
      "replacement": "// Print the ni-by-nl result matrix G to stderr using a fixed floating-point format for verification"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_init_array",
      "original": "// INSERT COMMENT LOOP: init_array",
      "replacement": "// Traverse all ni*nl entries of G and set them to 0 (zero-initialize the output matrix)"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block coordinates; collapse(2) flattens the loops to distribute blocks across threads"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block coordinates; collapse(2) flattens the loops to distribute blocks across threads"
    },
    {
      "id": "unknown_LOOP_kernel",
      "original": "// INSERT COMMENT LOOP: kernel",
      "replacement": "// OpenMP-parallel 2D iteration over block coordinates; collapse(2) flattens the loops to distribute blocks across threads"
    },
    {
      "id": "unknown_LOOP_print_array",
      "original": "// INSERT COMMENT LOOP: print_array",
      "replacement": "// Walk the ni-by-nl grid and print each G element in row-major order using the specified format"
    },
    {
      "id": "unknown_IFELSE_main::entry",
      "original": "// INSERT COMMENT IFELSE: main::entry",
      "replacement": "// Parse command-line arguments to set the dump flag and problem dimensions ni, nj, nk, and nl"
    },
    {
      "id": "unknown_IFELSE_kernel_A_mul_B::entry",
      "original": "// INSERT COMMENT IFELSE: kernel_A_mul_B::entry",
      "replacement": "// Compute (i,j) from block/thread IDs; if within bounds, accumulate the dot product over k for C[i,j], preventing out-of-bounds access"
    }
  ]
}