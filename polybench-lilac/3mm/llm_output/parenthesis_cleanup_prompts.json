{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 126 potential parentheses to evaluate:\n\nLine 87: uint8_t newline_str[NEWLINE_BUFSZ] = { \"\\n\" };\n  Potential parentheses to evaluate: (x)\nLine 90: /* LLVM Intrinsic Builtin Function Bodies */\n  Potential parentheses to evaluate: (x), (x)\nLine 93: return r;\n  Potential parentheses to evaluate: (X)\nLine 312: #pragma omp parallel for collapse(2)\n  Potential parentheses to evaluate: (uint32_t, uint32_t)\nLine 351: // INSERT COMMENT LOOP: kernel::header.030\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 380: \n  Potential parentheses to evaluate: (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[ARG_IDX_DUMP_CODE]), (argv[ARG_IDX_NI]), (argv[ARG_IDX_NJ]), (argv[ARG_IDX_NK]), (argv[ARG_IDX_NL]), (argv[ARG_IDX_NM]), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (uint32_t num, uint32_t factor), (ni, block.x), (nj, block.y), (uint8_t*), (&grid_tmp1), (uint8_t*), (&grid), (uint8_t*), (&block_tmp1), (uint8_t*), (&block), (uint8_t*), (&grid_tmp1_packed), (uint8_t*), (&grid_tmp1), (uint8_t*), (&block_tmp1_packed), (uint8_t*), (&block_tmp1), (2), (ni, nj, nk, E, A, B, grid_x_blocks_1, grid_y_blocks_1, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0), (nj, block.x), (nl, block.y), (uint8_t*), (&grid_tmp2), (uint8_t*), (&grid), (uint8_t*), (&block_tmp2), (uint8_t*), (&block), (uint8_t*), (&grid_tmp2_packed), (uint8_t*), (&grid_tmp2), (uint8_t*), (&block_tmp2_packed), (uint8_t*), (&block_tmp2), (2), (nj, nl, nm, F, C, D, grid_x_blocks_2, grid_y_blocks_2, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0), (ni, block.x), (nl, block.y), (uint8_t*), (&grid_tmp3), (uint8_t*), (&grid), (uint8_t*), (&block_tmp3), (uint8_t*), (&block), (uint8_t*), (&grid_tmp3_packed), (uint8_t*), (&grid_tmp3), (uint8_t*), (&block_tmp3_packed), (uint8_t*), (&block_tmp3), (2), (ni, nl, nj, G, E, F, grid_x_blocks_3, grid_y_blocks_3, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0), (double_format_str), (int), (int), (newline_str), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n/* Magic number constants */\n#define FORMAT_SPEC_BUFSZ 8\n#define NEWLINE_BUFSZ 2\n#define ARG_IDX_DUMP_CODE 1\n#define ARG_IDX_NI 2\n#define ARG_IDX_NJ 3\n#define ARG_IDX_NK 4\n#define ARG_IDX_NL 5\n#define ARG_IDX_NM 6\n#define BYTES_PER_DOUBLE 8\n#define DUMP_CODE_ENABLED 1\n#define INIT_B_J_OFFSET 1\n#define INIT_C_J_OFFSET 3\n#define INIT_D_J_OFFSET 2\n#define TOTAL_THREADS_PER_BLOCK 256\n#define BLOCK_DIM_Y 32\n#define BLOCK_DIM_X 8\n#define DIM3_STRUCT_BYTES 12\n#define GRID_DIM_Z 1\n#define BLOCK_DIM_Z 1\n#define PRINT_ELEMS_PER_LINE 20\n\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct Dim3;\nstruct Dim3Packed;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array1 {\n  uint8_t array[1];\n};\nstruct uint8_array20 {\n  uint8_t array[20];\n};\nstruct Dim3 {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct Dim3Packed {\n  uint64_t __FIXME__l_unnamed_1_field0;\n  uint32_t __FIXME__l_unnamed_1_field1;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nvoid kernel_A_mul_B(uint32_t, uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t double_format_str[FORMAT_SPEC_BUFSZ] = { \"%0.2lf \" };\nuint8_t newline_str[NEWLINE_BUFSZ] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_udiv_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t ni;\n  int32_t nj;\n  int32_t nk;\n  int32_t nl;\n  int32_t nm;\n  uint8_t* A;\n  uint8_t* B;\n  uint8_t* C;\n  uint8_t* D;\n  uint8_t* E;\n  uint8_t* F;\n  uint8_t* G;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[ARG_IDX_DUMP_CODE]);\n  ni = atoi(argv[ARG_IDX_NI]);\n  nj = atoi(argv[ARG_IDX_NJ]);\n  nk = atoi(argv[ARG_IDX_NK]);\n  nl = atoi(argv[ARG_IDX_NL]);\n  nm = atoi(argv[ARG_IDX_NM]);\n  A = malloc(ni * nk * BYTES_PER_DOUBLE);\n  B = malloc(nk * nj * BYTES_PER_DOUBLE);\n  C = malloc(nj * nm * BYTES_PER_DOUBLE);\n  D = malloc(nm * nl * BYTES_PER_DOUBLE);\n  E = malloc(ni * nj * BYTES_PER_DOUBLE);\n  F = malloc(nj * nl * BYTES_PER_DOUBLE);\n  G = malloc(ni * nl * BYTES_PER_DOUBLE);\n  init_array(ni, nj, nk, nl, nm, ((double*)A), ((double*)B), ((double*)C), ((double*)D), ((double*)E), ((double*)F), ((double*)G));\n;\n  kernel(ni, nj, nk, nl, nm, ((double*)E), ((double*)A), ((double*)B), ((double*)F), ((double*)C), ((double*)D), ((double*)G));\n;\n  if (dump_code == DUMP_CODE_ENABLED) { // IFELSE MARKER: entry IF\nprint_array(ni, nl, ((double*)G));\n  }\nfree(((uint8_t*)((double*)E)));\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)B)));\nfree(((uint8_t*)((double*)F)));\nfree(((uint8_t*)((double*)C)));\nfree(((uint8_t*)((double*)D)));\nfree(((uint8_t*)((double*)G)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t ni, uint32_t nj, uint32_t nk, uint32_t nl, uint32_t nm, double* A, double* B, double* C, double* D, double* E, double* F, double* G) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nk;   j = j + 1){\n  int indexA = i * ni + j;\n  double di_a = (double)i;\n  double dj_a = (double)j;\n  double dni = (double)ni;\n  double prod_a = di_a * dj_a;\n  double valA = prod_a / dni;\n  A[(i * ni + j)] = valA;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond10\nfor(int64_t i = 0; i < nk;   i = i + 1){\nfor(int64_t j = 0; j < nj;   j = j + 1){\n  int indexB = i * nk + j;\n  int j_offset_B = j + INIT_B_J_OFFSET;\n  double di_b = (double)i;\n  double dj_b = (double)j_offset_B;\n  double dnj = (double)nj;\n  double prod_b = di_b * dj_b;\n  double valB = prod_b / dnj;\n  B[(i * nk + j)] = valB;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond32\nfor(int64_t i = 0; i < nj;   i = i + 1){\nfor(int64_t j = 0; j < nm;   j = j + 1){\n  int indexC = i * nj + j;\n  int j_offset_C = j + INIT_C_J_OFFSET;\n  double di_c = (double)i;\n  double dj_c = (double)j_offset_C;\n  double dnl = (double)nl;\n  double prod_c = di_c * dj_c;\n  double valC = prod_c / dnl;\n  C[(i * nj + j)] = valC;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond54\nfor(int64_t i = 0; i < nm;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  int indexD = i * nm + j;\n  int j_offset_D = j + INIT_D_J_OFFSET;\n  double di_d = (double)i;\n  double dj_d = (double)j_offset_D;\n  double dnk = (double)nk;\n  double prod_d = di_d * dj_d;\n  double valD = prod_d / dnk;\n  D[(i * nm + j)] = valD;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond76\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nj;   j = j + 1){\n  E[(i * ni + j)] = 0;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond92\nfor(int64_t i = 0; i < nj;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  F[(i * nj + j)] = 0;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond108\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  G[(i * ni + j)] = 0;\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_A_mul_B\nvoid kernel_A_mul_B(uint32_t ni, uint32_t nj, uint32_t nk, double* C, double* A, double* B, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n  int64_t k;\n  double dot;\n\n// INSERT COMMENT IFELSE: kernel_A_mul_B::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < ni && j < nj) {\ndot = 0;\nfor(int64_t k = 0; k < nk;   k = k + 1){\ndot = (dot + (A[(i * nk + k)] * B[(k * nj + j)]));\n}\nC[(i * nj + j)] = dot;\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t ni, uint32_t nj, uint32_t nk, uint32_t nl, uint32_t nm, double* E, double* A, double* B, double* F, double* C, double* D, double* G) {\n  struct Dim3 block;    /* Address-exposed local */\n  struct Dim3 grid;    /* Address-exposed local */\n  struct Dim3 grid_tmp1;    /* Address-exposed local */\n  struct Dim3 block_tmp1;    /* Address-exposed local */\n  struct Dim3Packed grid_tmp1_packed;    /* Address-exposed local */\n  struct Dim3Packed block_tmp1_packed;    /* Address-exposed local */\n  struct Dim3 grid_tmp2;    /* Address-exposed local */\n  struct Dim3 block_tmp2;    /* Address-exposed local */\n  struct Dim3Packed grid_tmp2_packed;    /* Address-exposed local */\n  struct Dim3Packed block_tmp2_packed;    /* Address-exposed local */\n  struct Dim3 grid_tmp3;    /* Address-exposed local */\n  struct Dim3 block_tmp3;    /* Address-exposed local */\n  struct Dim3Packed grid_tmp3_packed;    /* Address-exposed local */\n  struct Dim3Packed block_tmp3_packed;    /* Address-exposed local */\n  uint32_t block_threads_x;\n  int32_t grid_x_blocks_1;\n  int32_t grid_y_blocks_1;\n  uint32_t i;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  int32_t grid_x_blocks_2;\n  int32_t grid_y_blocks_2;\n  int32_t grid_x_blocks_3;\n  int32_t grid_y_blocks_3;\n\n  block_threads_x = (TOTAL_THREADS_PER_BLOCK / BLOCK_DIM_Y);\n  block.x = block_threads_x;\n  block.y = BLOCK_DIM_Y;\n  block.z = BLOCK_DIM_Z;\n  grid_x_blocks_1 = num_blocks(ni, block.x);\n  grid_y_blocks_1 = num_blocks(nj, block.y);\n  grid.x = grid_x_blocks_1;\n  grid.y = grid_y_blocks_1;\n  grid.z = GRID_DIM_Z;\n  memcpy(((uint8_t*)(&grid_tmp1)), ((uint8_t*)(&grid)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp1)), ((uint8_t*)(&block)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&grid_tmp1_packed)), ((uint8_t*)(&grid_tmp1)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp1_packed)), ((uint8_t*)(&block_tmp1)), DIM3_STRUCT_BYTES);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < grid_x_blocks_1;   i = i + 1){\nfor(int32_t j = 0; j < grid_y_blocks_1;   j = j + 1){\nfor(int32_t k = 0; k < BLOCK_DIM_X;   k = k + 1){\nfor(int32_t l = 0; l < BLOCK_DIM_Y;   l = l + 1){\nkernel_A_mul_B(ni, nj, nk, E, A, B, grid_x_blocks_1, grid_y_blocks_1, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  grid_x_blocks_2 = num_blocks(nj, block.x);\n  grid_y_blocks_2 = num_blocks(nl, block.y);\n  grid.x = grid_x_blocks_2;\n  grid.y = grid_y_blocks_2;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&grid_tmp2)), ((uint8_t*)(&grid)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp2)), ((uint8_t*)(&block)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&grid_tmp2_packed)), ((uint8_t*)(&grid_tmp2)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp2_packed)), ((uint8_t*)(&block_tmp2)), DIM3_STRUCT_BYTES);\n// INSERT COMMENT LOOP: kernel::header.010\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < grid_x_blocks_2;   i = i + 1){\nfor(int32_t j = 0; j < grid_y_blocks_2;   j = j + 1){\nfor(int32_t k = 0; k < BLOCK_DIM_X;   k = k + 1){\nfor(int32_t l = 0; l < BLOCK_DIM_Y;   l = l + 1){\nkernel_A_mul_B(nj, nl, nm, F, C, D, grid_x_blocks_2, grid_y_blocks_2, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  grid_x_blocks_3 = num_blocks(ni, block.x);\n  grid_y_blocks_3 = num_blocks(nl, block.y);\n  grid.x = grid_x_blocks_3;\n  grid.y = grid_y_blocks_3;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&grid_tmp3)), ((uint8_t*)(&grid)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp3)), ((uint8_t*)(&block)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&grid_tmp3_packed)), ((uint8_t*)(&grid_tmp3)), DIM3_STRUCT_BYTES);\n  memcpy(((uint8_t*)(&block_tmp3_packed)), ((uint8_t*)(&block_tmp3)), DIM3_STRUCT_BYTES);\n// INSERT COMMENT LOOP: kernel::header.030\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < grid_x_blocks_3;   i = i + 1){\nfor(int32_t j = 0; j < grid_y_blocks_3;   j = j + 1){\nfor(int32_t k = 0; k < BLOCK_DIM_X;   k = k + 1){\nfor(int32_t l = 0; l < BLOCK_DIM_Y;   l = l + 1){\nkernel_A_mul_B(ni, nl, nj, G, E, F, grid_x_blocks_3, grid_y_blocks_3, GRID_DIM_Z, block_threads_x, BLOCK_DIM_Y, BLOCK_DIM_Z, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t ni, uint32_t nl, double* G) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  fprintf(stderr, (double_format_str), G[(i * ni + j)]);\n  if ((int)(i * ni + j) % (int)PRINT_ELEMS_PER_LINE == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline_str));\n  }\n}\n}\n  fprintf(stderr, (newline_str));\n}\n\n```"
}