{
  "system_prompt": "You are an expert C programmer specializing in code readability and style.\nYour task is to analyze C code and identify unnecessary parentheses that can be safely removed without changing program behavior or readability.\n\nConsider these guidelines when deciding which parentheses to remove:\n- Remove parentheses around single variables: `(x)` \u2192 `x`\n- Remove redundant parentheses that don't affect operator precedence\n- Keep parentheses that clarify complex expressions or override precedence\n- Keep parentheses in function calls, declarations, and control structures\n- Consider readability: sometimes parentheses help clarity even if technically unnecessary\n\nFor each unnecessary parenthesis you identify, suggest:\n1. The exact line number where it appears\n2. The parenthesis expression to remove\n3. Why it can be safely removed\n\nReturn your response as JSON with this structure:\n{\n    \"removals\": [\n        {\n            \"line_number\": 42,\n            \"expression\": \"(x + y)\",\n            \"replacement\": \"x + y\",\n            \"reasoning\": \"Parentheses are unnecessary as + has lower precedence than surrounding operators\"\n        }\n    ]\n}\n\nOnly suggest removals for parentheses that are truly unnecessary and improve readability.",
  "user_prompt": "Analyze this C code and identify unnecessary parentheses that can be safely removed.\n\nFound 126 potential parentheses to evaluate:\n\nLine 241: D[(i * nm + j)] = normalized_prod4;\n  Potential parentheses to evaluate: (noinline)\nLine 277: j = blockDim_y * blockIdx_y + threadIdx_y;\n  Potential parentheses to evaluate: (noinline, nothrow)\nLine 412: \n  Potential parentheses to evaluate: (uint32_t, uint32_t), (noinline, nothrow), (noinline, nothrow), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (uint32_t a, uint32_t b), (uint64_t a, uint64_t b), (uint32_t a, uint32_t b), (int32_t a, int32_t b), (int32_t a, int32_t b), (argv[1]), (argv[2]), (argv[3]), (argv[4]), (argv[5]), (argv[6]), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (uint8_t*), (double*), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (double), (uint32_t num, uint32_t factor), (ni, block.x), (nj, block.y), (uint8_t*), (&temp_grid_copy1), (uint8_t*), (&grid), (uint8_t*), (&temp_block_copy1), (uint8_t*), (&block), (uint8_t*), (&packed_grid_copy1), (uint8_t*), (&temp_grid_copy1), (uint8_t*), (&packed_block_copy1), (uint8_t*), (&temp_block_copy1), (2), (ni, nj, nk, E, A, B, num_blocks_ni_by_blockx, num_blocks_nj_by_blocky, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0), (nj, block.x), (nl, block.y), (uint8_t*), (&temp_grid_copy2), (uint8_t*), (&grid), (uint8_t*), (&temp_block_copy2), (uint8_t*), (&block), (uint8_t*), (&packed_grid_copy2), (uint8_t*), (&temp_grid_copy2), (uint8_t*), (&packed_block_copy2), (uint8_t*), (&temp_block_copy2), (2), (nj, nl, nm, F, C, D, num_blocks_nj_by_blockx, num_blocks_nl_by_blocky, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0), (ni, block.x), (nl, block.y), (uint8_t*), (&temp_grid_copy3), (uint8_t*), (&grid), (uint8_t*), (&temp_block_copy3), (uint8_t*), (&block), (uint8_t*), (&packed_grid_copy3), (uint8_t*), (&temp_grid_copy3), (uint8_t*), (&packed_block_copy3), (uint8_t*), (&temp_block_copy3), (2), (ni, nl, nj, G, E, F, num_blocks_ni_by_blockx_2, num_blocks_nl_by_blocky_2, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0), (double_fmt_space), (int), (int), (newline_str), (newline_str)\n\nFor each unnecessary parenthesis, provide the exact expression to replace and explain why it can be safely removed. Focus only on parentheses that are truly redundant and don't affect readability.\n\nFull source code:\n```c\n/* Provide Declarations */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n\n#ifndef _MSC_VER\n#define __forceinline __attribute__((always_inline)) inline\n#endif\n\n#if defined(__GNUC__)\n#define  __ATTRIBUTELIST__(x) __attribute__(x)\n#else\n#define  __ATTRIBUTELIST__(x)  \n#endif\n\n#ifdef _MSC_VER  /* Can only support \"linkonce\" vars with GCC */\n#define __attribute__(X)\n#endif\n\n\n\n/* Global Declarations */\n\n/* Types Declarations */\nstruct io_file_t;\nstruct dim3_t;\nstruct packed_dim3_t;\n\n/* Function definitions */\n\n/* Types Definitions */\nstruct uint8_array1_t {\n  uint8_t array[1];\n};\nstruct uint8_array_20_t {\n  uint8_t array[20];\n};\nstruct io_file_t {\n  uint32_t flags;\n  uint8_t* read_ptr;\n  uint8_t* write_ptr;\n  uint8_t* buf_base;\n  uint8_t* buf_end;\n  uint8_t* save_base;\n  uint8_t* save_end;\n  uint8_t* marker;\n  uint8_t* chain;\n  uint8_t* lock_ptr;\n  uint8_t* cookie_ptr;\n  uint8_t* cookie_io_functions;\n  void* data_ptr;\n  struct io_file_t* next_file;\n  uint32_t file_flags2;\n  uint32_t orientation;\n  uint64_t read_count;\n  uint16_t mode;\n  uint8_t ungetc_char;\n  uint8_t small_buffer[1];\n  uint8_t* wide_data_ptr;\n  uint64_t lock_owner;\n  void* codecvt_ptr;\n  void* locale_ptr;\n  struct io_file_t* prev_file;\n  uint8_t* buffer2_ptr;\n  uint64_t cookie_size;\n  uint32_t reserved32;\n  uint8_t padding20[20];\n};\nstruct dim3_t {\n  uint32_t x;\n  uint32_t y;\n  uint32_t z;\n};\nstruct packed_dim3_t {\n  uint64_t packed_dim3_t_field0;\n  uint32_t packed_dim3_t_field1;\n};\n\n/* External Global Variable Declarations */\n\n/* Function Declarations */\nuint32_t cudaSetupArgument(uint8_t*, uint64_t, uint64_t);\nuint32_t cudaLaunch(uint8_t*);\nint main(int, char **) __ATTRIBUTELIST__((noinline));\nvoid init_array(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaMemcpy(uint8_t*, uint8_t*, uint64_t, uint32_t);\nvoid kernel(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, double*, double*, double*, double*, double*, double*, double*) __ATTRIBUTELIST__((noinline));\nvoid print_array(uint32_t, uint32_t, double*) __ATTRIBUTELIST__((noinline));\nuint32_t num_blocks(uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\nuint32_t cudaConfigureCall(uint64_t, uint32_t, uint64_t, uint32_t, uint64_t, void*);\nuint32_t cudaMalloc(uint8_t**, uint64_t);\nvoid kernel_A_mul_B(uint32_t, uint32_t, uint32_t, double*, double*, double*, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) __ATTRIBUTELIST__((noinline, nothrow));\n\n\n/* Global Variable Definitions and Initialization */\nuint8_t double_fmt_space[8] = { \"%0.2lf \" };\nuint8_t newline_str[2] = { \"\\n\" };\n\n\n/* LLVM Intrinsic Builtin Function Bodies */\nstatic __forceinline uint32_t llvm_add_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a + b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_add_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a + b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sub_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a - b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_mul_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a * b;\n  return r;\n}\nstatic __forceinline uint64_t llvm_mul_u64(uint64_t a, uint64_t b) {\n  uint64_t r = a * b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_udiv_u32(uint32_t a, uint32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_sdiv_u32(int32_t a, int32_t b) {\n  uint32_t r = a / b;\n  return r;\n}\nstatic __forceinline uint32_t llvm_srem_u32(int32_t a, int32_t b) {\n  uint32_t r = a % b;\n  return r;\n}\n\n\n/* Function Bodies */\nint main(int argc, char ** argv) {\n  int32_t dump_code;\n  int32_t ni;\n  int32_t nj;\n  int32_t nk;\n  int32_t nl;\n  int32_t nm;\n  uint8_t* A;\n  uint8_t* B;\n  uint8_t* C;\n  uint8_t* D;\n  uint8_t* E;\n  uint8_t* F;\n  uint8_t* G;\n  int32_t tmp_call68;\n  int32_t tmp_call96;\n\n// INSERT COMMENT IFELSE: main::entry\n  dump_code = atoi(argv[1]);\n  ni = atoi(argv[2]);\n  nj = atoi(argv[3]);\n  nk = atoi(argv[4]);\n  nl = atoi(argv[5]);\n  nm = atoi(argv[6]);\n  A = malloc(ni * nk * 8);\n  B = malloc(nk * nj * 8);\n  C = malloc(nj * nm * 8);\n  D = malloc(nm * nl * 8);\n  E = malloc(ni * nj * 8);\n  F = malloc(nj * nl * 8);\n  G = malloc(ni * nl * 8);\n  init_array(ni, nj, nk, nl, nm, ((double*)A), ((double*)B), ((double*)C), ((double*)D), ((double*)E), ((double*)F), ((double*)G));\n;\n  kernel(ni, nj, nk, nl, nm, ((double*)E), ((double*)A), ((double*)B), ((double*)F), ((double*)C), ((double*)D), ((double*)G));\n;\n  if (dump_code == 1) { // IFELSE MARKER: entry IF\nprint_array(ni, nl, ((double*)G));\n  }\nfree(((uint8_t*)((double*)E)));\nfree(((uint8_t*)((double*)A)));\nfree(((uint8_t*)((double*)B)));\nfree(((uint8_t*)((double*)F)));\nfree(((uint8_t*)((double*)C)));\nfree(((uint8_t*)((double*)D)));\nfree(((uint8_t*)((double*)G)));\n  return 0;\n}\n// INSERT COMMENT FUNCTION: init_array\nvoid init_array(uint32_t ni, uint32_t nj, uint32_t nk, uint32_t nl, uint32_t nm, double* A, double* B, double* C, double* D, double* E, double* F, double* G) {\n  int64_t i;\n  int64_t j;\n\n// INSERT COMMENT LOOP: init_array::for.cond\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nk;   j = j + 1){\n  __auto_type i_d = (double)i;\n  __auto_type j_d = (double)j;\n  __auto_type prod_i_j = i_d * j_d;\n  __auto_type ni_d = (double)ni;\n  __auto_type normalized_prod1 = prod_i_j / ni_d;\n  __auto_type idx_a = i * ni + j;\n  A[(i * ni + j)] = normalized_prod1;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond10\nfor(int64_t i = 0; i < nk;   i = i + 1){\nfor(int64_t j = 0; j < nj;   j = j + 1){\n  __auto_type i_d2 = (double)i;\n  __auto_type j_plus1 = j + 1;\n  __auto_type j1_d = (double)j_plus1;\n  __auto_type prod_i_j1 = i_d2 * j1_d;\n  __auto_type nj_d = (double)nj;\n  __auto_type normalized_prod2 = prod_i_j1 / nj_d;\n  __auto_type idx_b = i * nk + j;\n  B[(i * nk + j)] = normalized_prod2;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond32\nfor(int64_t i = 0; i < nj;   i = i + 1){\nfor(int64_t j = 0; j < nm;   j = j + 1){\n  __auto_type i_d3 = (double)i;\n  __auto_type j_plus3 = j + 3;\n  __auto_type j3_d = (double)j_plus3;\n  __auto_type prod_i_j3 = i_d3 * j3_d;\n  __auto_type nl_d = (double)nl;\n  __auto_type normalized_prod3 = prod_i_j3 / nl_d;\n  __auto_type idx_c = i * nj + j;\n  C[(i * nj + j)] = normalized_prod3;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond54\nfor(int64_t i = 0; i < nm;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  __auto_type i_d4 = (double)i;\n  __auto_type j_plus2 = j + 2;\n  __auto_type j2_d = (double)j_plus2;\n  __auto_type prod_i_j2 = i_d4 * j2_d;\n  __auto_type nk_d = (double)nk;\n  __auto_type normalized_prod4 = prod_i_j2 / nk_d;\n  __auto_type idx_d = i * nm + j;\n  D[(i * nm + j)] = normalized_prod4;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond76\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nj;   j = j + 1){\n  E[(i * ni + j)] = 0;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond92\nfor(int64_t i = 0; i < nj;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  F[(i * nj + j)] = 0;\n}\n}\n// INSERT COMMENT LOOP: init_array::for.cond108\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  G[(i * ni + j)] = 0;\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: num_blocks\nuint32_t num_blocks(uint32_t num, uint32_t factor) {\n  return ((num + factor) - 1) / factor;\n}\n// INSERT COMMENT FUNCTION: kernel_A_mul_B\nvoid kernel_A_mul_B(uint32_t ni, uint32_t nj, uint32_t nk, double* C, double* A, double* B, uint32_t gridDim_x, uint32_t gridDim_y, uint32_t gridDim_z, uint32_t blockDim_x, uint32_t blockDim_y, uint32_t blockDim_z, uint32_t blockIdx_x, uint32_t blockIdx_y, uint32_t blockIdx_z, uint32_t threadIdx_x, uint32_t threadIdx_y, uint32_t threadIdx_z) {\n  int32_t i;\n  int32_t j;\n  int64_t k;\n  double dot;\n\n// INSERT COMMENT IFELSE: kernel_A_mul_B::entry\n  i = blockDim_x * blockIdx_x + threadIdx_x;\n  j = blockDim_y * blockIdx_y + threadIdx_y;\n  if (i < ni) { // IFELSE MARKER: entry IF\n  if (j < nj) { // IFELSE MARKER: land.lhs.true IF\n  dot = 0;\nfor(int64_t k = 0; k < nk;   k = k + 1){\n  dot = (dot + (A[(i * nk + k)] * B[(k * nj + j)]));\n}\n  C[(i * nj + j)] = dot;\n  }\n  }\n  return;\n}\n// INSERT COMMENT FUNCTION: kernel\nvoid kernel(uint32_t ni, uint32_t nj, uint32_t nk, uint32_t nl, uint32_t nm, double* E, double* A, double* B, double* F, double* C, double* D, double* G) {\n  struct dim3_t block;    /* Address-exposed local */\n  struct dim3_t grid;    /* Address-exposed local */\n  struct dim3_t temp_grid_copy1;    /* Address-exposed local */\n  struct dim3_t temp_block_copy1;    /* Address-exposed local */\n  struct packed_dim3_t packed_grid_copy1;    /* Address-exposed local */\n  struct packed_dim3_t packed_block_copy1;    /* Address-exposed local */\n  struct dim3_t temp_grid_copy2;    /* Address-exposed local */\n  struct dim3_t temp_block_copy2;    /* Address-exposed local */\n  struct packed_dim3_t packed_grid_copy2;    /* Address-exposed local */\n  struct packed_dim3_t packed_block_copy2;    /* Address-exposed local */\n  struct dim3_t temp_grid_copy3;    /* Address-exposed local */\n  struct dim3_t temp_block_copy3;    /* Address-exposed local */\n  struct packed_dim3_t packed_grid_copy3;    /* Address-exposed local */\n  struct packed_dim3_t packed_block_copy3;    /* Address-exposed local */\n  uint32_t warps_per_block;\n  int32_t num_blocks_ni_by_blockx;\n  int32_t num_blocks_nj_by_blocky;\n  uint8_t* byte_ptr1;\n  uint8_t* byte_ptr2;\n  uint8_t* byte_ptr3;\n  uint8_t* byte_ptr4;\n  uint32_t i;\n  uint32_t j;\n  uint32_t k;\n  uint32_t l;\n  int32_t num_blocks_nj_by_blockx;\n  int32_t num_blocks_nl_by_blocky;\n  uint8_t* byte_ptr5;\n  uint8_t* byte_ptr6;\n  uint8_t* byte_ptr7;\n  uint8_t* byte_ptr8;\n  int32_t num_blocks_ni_by_blockx_2;\n  int32_t num_blocks_nl_by_blocky_2;\n  uint8_t* byte_ptr9;\n  uint8_t* byte_ptr10;\n  uint8_t* byte_ptr11;\n  uint8_t* byte_ptr12;\n\n  warps_per_block = (256 / 32);\n  block.x = warps_per_block;\n  block.y = 32;\n  block.z = 1;\n  num_blocks_ni_by_blockx = num_blocks(ni, block.x);\n  num_blocks_nj_by_blocky = num_blocks(nj, block.y);\n  grid.x = num_blocks_ni_by_blockx;\n  grid.y = num_blocks_nj_by_blocky;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&temp_grid_copy1)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&temp_block_copy1)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&packed_grid_copy1)), ((uint8_t*)(&temp_grid_copy1)), 12);\n  memcpy(((uint8_t*)(&packed_block_copy1)), ((uint8_t*)(&temp_block_copy1)), 12);\n// INSERT COMMENT LOOP: kernel::header.0\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_ni_by_blockx;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_nj_by_blocky;   j = j + 1){\nfor(int32_t k = 0; k < 8;   k = k + 1){\nfor(int32_t l = 0; l < 32;   l = l + 1){\nkernel_A_mul_B(ni, nj, nk, E, A, B, num_blocks_ni_by_blockx, num_blocks_nj_by_blocky, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  num_blocks_nj_by_blockx = num_blocks(nj, block.x);\n  num_blocks_nl_by_blocky = num_blocks(nl, block.y);\n  grid.x = num_blocks_nj_by_blockx;\n  grid.y = num_blocks_nl_by_blocky;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&temp_grid_copy2)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&temp_block_copy2)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&packed_grid_copy2)), ((uint8_t*)(&temp_grid_copy2)), 12);\n  memcpy(((uint8_t*)(&packed_block_copy2)), ((uint8_t*)(&temp_block_copy2)), 12);\n// INSERT COMMENT LOOP: kernel::header.010\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_nj_by_blockx;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_nl_by_blocky;   j = j + 1){\nfor(int32_t k = 0; k < 8;   k = k + 1){\nfor(int32_t l = 0; l < 32;   l = l + 1){\nkernel_A_mul_B(nj, nl, nm, F, C, D, num_blocks_nj_by_blockx, num_blocks_nl_by_blocky, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  num_blocks_ni_by_blockx_2 = num_blocks(ni, block.x);\n  num_blocks_nl_by_blocky_2 = num_blocks(nl, block.y);\n  grid.x = num_blocks_ni_by_blockx_2;\n  grid.y = num_blocks_nl_by_blocky_2;\n  grid.z = 1;\n  memcpy(((uint8_t*)(&temp_grid_copy3)), ((uint8_t*)(&grid)), 12);\n  memcpy(((uint8_t*)(&temp_block_copy3)), ((uint8_t*)(&block)), 12);\n  memcpy(((uint8_t*)(&packed_grid_copy3)), ((uint8_t*)(&temp_grid_copy3)), 12);\n  memcpy(((uint8_t*)(&packed_block_copy3)), ((uint8_t*)(&temp_block_copy3)), 12);\n// INSERT COMMENT LOOP: kernel::header.030\n#pragma omp parallel for collapse(2)\nfor(int32_t i = 0; i < num_blocks_ni_by_blockx_2;   i = i + 1){\nfor(int32_t j = 0; j < num_blocks_nl_by_blocky_2;   j = j + 1){\nfor(int32_t k = 0; k < 8;   k = k + 1){\nfor(int32_t l = 0; l < 32;   l = l + 1){\nkernel_A_mul_B(ni, nl, nj, G, E, F, num_blocks_ni_by_blockx_2, num_blocks_nl_by_blocky_2, 1, warps_per_block, 32, 1, i, j, 0, k, l, 0);\n}\n}\n}\n}\n  return;\n}\n// INSERT COMMENT FUNCTION: print_array\nvoid print_array(uint32_t ni, uint32_t nl, double* G) {\n  int64_t i;\n  int64_t j;\n  int32_t tmp_i32;\n\n// INSERT COMMENT LOOP: print_array::for.cond\nfor(int64_t i = 0; i < ni;   i = i + 1){\nfor(int64_t j = 0; j < nl;   j = j + 1){\n  fprintf(stderr, (double_fmt_space), G[(i * ni + j)]);\n  if ((int)(i * ni + j) % (int)20 == 0) { // IFELSE MARKER: for.body3 IF\n  fprintf(stderr, (newline_str));\n  }\n}\n}\n  fprintf(stderr, (newline_str));\n}\n\n```"
}